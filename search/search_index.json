{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#home","title":"Home","text":"<p>Hyl\u00e9 is a lean blockchain that lets you easily take your provable application onchain.</p> <p>Note</p> <p>This developer portal and the project itself are still evolving. Join us on Telegram if you need assistance or wish to provide feedback. Issues and PRs on this documentation's GitHub repository are also very welcome!</p>"},{"location":"#why-choose-hyle","title":"Why choose Hyl\u00e9","text":"<ul> <li>Native zero-knowledge proof verification on our sovereign L1: we're fast and lean.</li> <li>No onchain execution or virtual machine needed: only efficient proof verification.</li> <li>Run complex logic off-chain and only submit proofs onchain for maximum scalability.</li> <li>Proof composability: seamlessly combine multiple proofs into single, verifiable transactions.</li> <li>Pipelined proving: send provable blobs, don't worry about proving times.</li> <li>Choose your proving scheme and your language: we verify all proofs.</li> </ul>"},{"location":"#how-hyle-works","title":"How Hyl\u00e9 works","text":"<p>Here\u2019s what happens when you use Hyl\u00e9\u2019s sovereign verification-focused Layer 1:</p> <p></p> <ol> <li>Sequencing: Send a provable blob of information to Hyl\u00e9: say what information you expect to prove later. We'll sequence the transaction immediately and give you time to prove it. Read more about pipelined proving.</li> <li>Proof submission: when the proofs for your transaction are ready, send them to Hyl\u00e9.</li> <li>Verification: Hyl\u00e9 validators receive the transaction. They verify the proofs natively, without the limitations of a bulky virtual machine.</li> <li>Consensus: if the proofs are valid, Hyl\u00e9 settles your transaction's state onchain. You're good to go!</li> </ol> <p>With this system, execution and storage happen anywhere you like. You only need a fast and trustworthy verifier: that\u2019s Hyl\u00e9.</p>"},{"location":"#links","title":"Links","text":"<ul> <li>Rust node</li> <li>Example contracts</li> <li>Hyle.eu</li> <li>Hyl\u00e9 blog</li> </ul> <p>Reach out to the team for more information:</p>  Github  Twitter  Farcaster  LinkedIn  Youtube  Telegram Hyl\u00e9 @hyle_org @hyle-org Hyl\u00e9 @Hyl\u00e9 @hyle_org"},{"location":"developers/","title":"\ud83d\udc69\u200d\ud83d\udcbb Developer documentation","text":""},{"location":"developers/#developer-documentation","title":"\ud83d\udc69\u200d\ud83d\udcbb Developer documentation","text":"<p>Welcome to the developer documentation for Hyl\u00e9!</p> <ul> <li>Quickstart</li> <li>General documentation about Hyl\u00e9</li> <li>SDK</li> <li>Explorer</li> </ul> <p>You may also be interested in:</p> <ul> <li>Examples GitHub repository</li> </ul>"},{"location":"developers/explorer/","title":"Explorer","text":"<p>Hyl\u00e9ou (a French pun for \"Il est o\u00f9\" or \"Where is it?\") is the blockchain explorer for the Hyl\u00e9 ecosystem.</p> <p>The explorer is live at hyleou.hyle.eu.  </p> <p>The source code is available on GitHub. We welcome PRs and issues!</p>"},{"location":"developers/explorer/#features","title":"Features","text":"<p>All features are in active development. </p>"},{"location":"developers/explorer/#live-features","title":"Live features","text":"<p>Currently, you can:</p> <ul> <li>View the latest blocks</li> <li>View the latest transactions.</li> <li>View detailed information about specific blocks and transactions.</li> <li>Fetch a .json state for the <code>hyllar</code> and <code>hydentity</code> contracts.</li> </ul>"},{"location":"developers/explorer/#upcoming-features","title":"Upcoming features","text":"<p>Planned features include:</p> <ul> <li>Register new contracts.</li> <li>Send transactions by uploading ZK proofs to specific contracts.</li> </ul>"},{"location":"developers/general-doc/","title":"General documentation","text":"<p>Welcome to the developer documentation for Hyl\u00e9.</p> <p>This section includes general documentation topics, such as:</p> <ul> <li>The difference between Hyl\u00e9 and traditional blockchains</li> <li>Identity management on Hyl\u00e9</li> <li>Pipelined proving</li> <li>Proof composability</li> <li>What smart contracts look like on Hyl\u00e9</li> <li>What a transaction looks like on Hyl\u00e9</li> <li>Our supported proving schemes</li> </ul> <p>You can also refer to our Getting Started step-by-step guide.</p>"},{"location":"developers/general-doc/hyle-vs-vintage-blockchains/","title":"Hyl\u00e9 vs. vintage blockchains","text":""},{"location":"developers/general-doc/hyle-vs-vintage-blockchains/#hyle-vs-vintage-blockchains","title":"Hyl\u00e9 vs. vintage blockchains","text":"<p>If you're used to traditional blockchains such as Ethereum or Solana, keep these Hyl\u00e9 characteristics in mind.</p>"},{"location":"developers/general-doc/hyle-vs-vintage-blockchains/#no-evm-or-execution-layer","title":"No EVM or execution layer","text":"<p>Hyl\u00e9 does not include a Virtual Machine.</p> <p>There is no dedicated execution engine or specific programming language (like Solidity) you should use.</p> <p>Our approach is simple: onchain, we verify zero-knowledge proofs natively. Offchain, you do everything else, the way you prefer.</p>"},{"location":"developers/general-doc/hyle-vs-vintage-blockchains/#no-onchain-state","title":"No onchain state","text":"<p>The network maintains proofs of state transitions rather than the entire onchain state.</p> <p>Transactions on Hyl\u00e9 verify and settle transitions without storing full intermediary states onchain.</p> <p>This architecture reduces storage overhead and promotes scalability while maintaining trustlessness.</p>"},{"location":"developers/general-doc/hyle-vs-vintage-blockchains/#privacy-is-built-in","title":"Privacy is built-in","text":"<p>Unlike Ethereum, where privacy solutions must be implemented on top of the platform, Hyl\u00e9 integrates privacy features natively.</p> <p>The proof is public, but your inputs don't need to be, as execution happens offchain.</p>"},{"location":"developers/general-doc/identity/","title":"Identity management","text":""},{"location":"developers/general-doc/identity/#identity-management","title":"Identity management","text":""},{"location":"developers/general-doc/identity/#where-is-identity-relevant-on-hyle","title":"Where is identity relevant on Hyl\u00e9?","text":"<p>A <code>BlobTransaction</code> on Hyl\u00e9 includes:</p> <ul> <li>As many <code>blob</code>s as wanted;</li> <li>One <code>blob</code> which corresponds to the identity of the person who initiated the transaction.</li> </ul> <p>Note that:</p> <ul> <li>Every blob transaction requires a single identity.</li> <li>All provable blobs within a transaction must share the same identity.</li> </ul> <p>Any contract can be an identity. Hyl\u00e9 ships a native <code>hydentity</code> contract, but you can use any source as an identity proving scheme.</p>"},{"location":"developers/general-doc/identity/#whats-special-about-identity-on-hyle","title":"What's special about identity on Hyl\u00e9","text":"<p>Any smart contract can be an identity provider, and there is true interoperability: a transaction can send Hyl\u00e9 tokens from your Metamask wallet to an email and password account seamlessly.</p>"},{"location":"developers/general-doc/identity/#implementation","title":"Implementation","text":"<p>Note</p> <p>Please contact us directly to know more about identity management on Hyl\u00e9. We are aiming to publish implementation instructions in January 2025.</p>"},{"location":"developers/general-doc/pipelined-proving/","title":"Pipelined proving","text":""},{"location":"developers/general-doc/pipelined-proving/#pipelined-proving","title":"Pipelined proving","text":""},{"location":"developers/general-doc/pipelined-proving/#the-problem-base-state-conflicts","title":"The problem: base state conflicts","text":"<p>Hyl\u00e9 ensures both privacy and scalability by verifying only the state transitions of smart contracts. This approach reduces computational overhead but introduces a critical issue for provable applications: base state conflicts.</p> <p>Proof generation can be slow, especially on less powerful devices. An app with a lot of usage will see conflicting operations, where multiple transactions reference the same base state, waiting for the previous state change to be settled.</p> <p>Since proof generation lags behind sequencing, users submitting transactions cannot be certain which state their operation will build upon, causing:</p> <ul> <li>Proof generation latency: the time spent generating proofs delays transaction finality.</li> <li>Timekeeping uncertainty: proofs require accurate timestamps, but users can't predict when their transaction will be sequenced.</li> <li>Parallelization limits: multiple transactions may reference the same base state, creating invalid proofs when one is settled before the other.</li> </ul> <p>We solve these issues by splitting sequencing from settlement; an operation includes two transactions.</p>"},{"location":"developers/general-doc/pipelined-proving/#blob-transaction-vs-proof-transaction","title":"Blob-transaction vs. Proof-transaction","text":"<p>To address base state conflicts, Hyl\u00e9 splits operations into two transactions:</p> <ol> <li>Blob-transaction: outlines a state change for sequencing.</li> <li>Proof-transaction: provides a proof of the state change for settlement.</li> </ol> <p>From Hyl\u00e9\u2019s perspective, the blob-transaction's content does not matter: it simply represents incoming information that your contract will process. For a developer, sequencing provides you with a fixed order and timestamp before proving begins. Once the transactions are sequenced, the provers can easily know upon which state they should base their proof.</p> <p>Settlement happens when the corresponding proof transaction is verified and added to a block. During settlement, unproven blob transactions linked to the contract are executed in their sequencing order.</p> <p></p> <p>This separation solves all three issues shown above. The blob transaction immediately reserves a place in execution order, allowing proof generation to run without blocking other transactions. It provides an immutable timestamp, so provers know which base state to use when generating proofs and can parallelize actions.</p>"},{"location":"developers/general-doc/pipelined-proving/#unprovable-transactions","title":"Unprovable transactions","text":"<p>Even with pipelined proving, the delay in proof generation and submission can delay transaction finality and create uncertainty when determining the initial state of subsequent transactions.</p> <p>To remove this bottleneck, Hyl\u00e9 enforces timeouts for blob transactions.</p> <p>Each blob transaction is assigned a specific time limit for the associated proof to be submitted and verified. If the proof is not successfully provided within this window, the transaction is rejected: it is ignored for state updates but remains recorded in the block.</p> <p>The inclusion of the unproven transaction in the block ensures transparency, as the transaction data remains accessible.</p> <p>Subsequent transactions can proceed without waiting indefinitely.</p>"},{"location":"developers/general-doc/proof-composability/","title":"Proof composition and cross-contract calls","text":""},{"location":"developers/general-doc/proof-composability/#proof-composition-and-cross-contract-calls","title":"Proof composition and cross-contract calls","text":"<p>To understand the concept of proof composability on Hyl\u00e9, we recommend you read this blog post.</p> <p>To understand proof composition in practice, check out our quickstart example.</p>"},{"location":"developers/general-doc/proof-composability/#what-is-proof-composition","title":"What is proof composition?","text":"<p>Proof composition happens when two contracts depend on each other. Proof composability is the fact that Hyl\u00e9 allows you to manage this situation while keeping their proofs independent.</p> <p>Most zero-knowledge systems deal with cross-contract calls by enforcing recursive proof verification:</p> <ul> <li>Program A verifies proof of correct execution of Program B;</li> <li>Program B verifies proof of correct execution of Program A.</li> </ul> <p>Hyl\u00e9 allows you to write Program A and add an input that says \u00ab this only applies if Program B is valid \u00bb. At settlement, with both contracts in the same proof transaction, it will verify both programs and the whole operation will fail if one proof fails to verify.</p>"},{"location":"developers/general-doc/proof-composability/#writing-a-cross-contract-call","title":"Writing a cross-contract call","text":"<p>Your program does not need to verify the execution of another program directly.</p> <p>Instead, it uses a representation of the called contracts, which looks like this: <code>MoneyApp::transfer(10, A, B) == true</code> or <code>TicketApp::get(A) == ticket</code>.</p> <p>This representation consists of:</p> <ul> <li>the app</li> <li>the function</li> <li>the function's parameters</li> <li>a claim on the results.</li> </ul> <p>In our quickstart example, the source code looks like this.</p>"},{"location":"developers/general-doc/proof-composability/#how-hyle-settles-multiple-proofs","title":"How Hyl\u00e9 settles multiple proofs","text":"<p>When you submit multiple proofs to Hyl\u00e9:</p> <ul> <li>Proof generation can be parallelized: proving times do not compound since proofs do not depend on each other.</li> <li>Proof verification is asynchronous thanks to pipelined proving. As soon as one proof is ready, it can be verified on Hyl\u00e9, even if the other proofs aren't ready yet.</li> <li>Once all proofs related to the transaction are verified, the transaction is settled on Hyl\u00e9. If one proof verification fails, then the entire transaction fails.</li> </ul> <p>Read more on our blog.</p>"},{"location":"developers/general-doc/smart-contracts/","title":"Smart contracts","text":""},{"location":"developers/general-doc/smart-contracts/#smart-contracts","title":"Smart contracts","text":"<p>Hyl\u00e9 is a fully programmable blockchain that optimizes data storage by keeping only the essential information needed to validate smart contract proofs. This design ensures that Hyl\u00e9 smart contracts are lightweight and efficient.</p> <p>Where traditional blockchains keep all smart contract information onchain, Hyl\u00e9 splits offchain data (your contract's execution) and onchain data, which is retrieved through our ABI.</p>"},{"location":"developers/general-doc/smart-contracts/#onchain-data-about-smart-contracts","title":"Onchain data about smart contracts","text":"<p>Hyl\u00e9 smart contracts' onchain data consists of:</p> <ul> <li>Name: the unique identifier for your contract</li> <li>Verifier: the proof system (e.g. \"risc0\" or \"gnark-groth16-te-BN254\")</li> <li>Program ID: the unique identifier for your program in that proof system</li> <li>State digest: current state commitment of the contract</li> </ul>"},{"location":"developers/general-doc/smart-contracts/#explanation-of-the-contract-fields","title":"Explanation of the contract fields","text":""},{"location":"developers/general-doc/smart-contracts/#name","title":"Name","text":"<p>The name of your contract must be unique.</p>"},{"location":"developers/general-doc/smart-contracts/#verifier-and-program-identifier","title":"Verifier and program identifier","text":"<p>Smart contracts on Hyl\u00e9 rely on a pairing of a zero-knowledge proof scheme (verifier) and a program identifier. Together, these components validate contract proofs.</p> Proving scheme Verifier Program ID Noir noir Verification key. Risc Zero risc0 Image ID without a prefix. ex. 0x123 becomes 123. SP1 sp1 Verification key."},{"location":"developers/general-doc/smart-contracts/#state-digest","title":"State digest","text":"<p>The state digest is a minimal yet comprehensive representation of the contract's current state. It serves as the basis for verifying the integrity of the contract's data.</p> <p>Some examples of valid state commitments:</p> <ul> <li>The full state, for a sufficiently small program (e.g. a smart contract with a nonce)</li> <li>A merkle root of the state, for larger programs</li> <li>A hash of the full state</li> </ul>"},{"location":"developers/general-doc/smart-contracts/#smart-contract-abi","title":"Smart contract ABI","text":"<p>All inputs in Hyl\u00e9 smart contracts must be known at proof generation time. This includes elements that would be known at execution time on other blockchains, such as the origin of the transaction (tx.origin) and the block number.</p> <p>Here is the Rust structure specifying the output of a Hyl\u00e9 smart contract:</p> <pre><code>pub struct HyleOutput {\n    pub version: u32,\n    pub initial_state: StateDigest,\n    pub next_state: StateDigest,\n    pub identity: Identity,\n    pub tx_hash: TxHash,\n    pub index: BlobIndex,\n    pub blobs: Vec&lt;u8&gt;,\n    pub success: bool,\n    pub program_outputs: Vec&lt;u8&gt;,\n}\n</code></pre>"},{"location":"developers/general-doc/smart-contracts/#explanation-of-the-abi-fields","title":"Explanation of the ABI fields","text":""},{"location":"developers/general-doc/smart-contracts/#version","title":"Version","text":"<p>For now, <code>version</code> should always be set to 1.</p>"},{"location":"developers/general-doc/smart-contracts/#initial-state-and-next-state","title":"Initial state and next state","text":"<p>Blockchains transactions are fundamentally state transitions. These fields handle state changes securely.</p> <ul> <li><code>initial_state</code>: Matches the onchain <code>state_digest</code> before the transaction. The <code>initial_state</code> must match the onchain <code>state_digest</code>. Otherwise, the state transition is invalid.</li> <li><code>next_state</code>: Represents the new onchain <code>state_digest</code> after the transaction.</li> </ul> <p>Smart contracts can adapt the actual structure of this field. In the future, fees will depend in part on the size of the <code>state_digest</code>, so we encourage you to keep it small.</p>"},{"location":"developers/general-doc/smart-contracts/#identity","title":"Identity","text":"<p>The <code>identity</code> field identifies the person who initiates a transaction.</p> <p>Hyl\u00e9 does not have a native signature type. Instead, it uses the <code>identity</code> field of the first proof in the transaction to identify the sender. This allows you to use any kind of identity verification.</p> <p>The identity is in two parts:</p> <ol> <li>An address;</li> <li>The name of the contract that the proof was generate for.</li> </ol> <p>For example, if a smart contract was registered onchain to verify Ethereum EOAs, the <code>identity</code> for them would look like <code>0x1234...5678.eth_eoa</code> where <code>eth_eoa</code> is the name of the contract and the first part matches a regular Ethereum address.</p> <p>Note: All proofs in a transaction must declare the same identity as the first transaction or an empty identity.</p>"},{"location":"developers/general-doc/smart-contracts/#tx-hash","title":"TX Hash","text":"<p>The <code>tx_hash</code> field hashes transaction data, preventing replay attacks and providing a means for contracts to access this information.</p> <p>The field is not validated by the protocol.</p>"},{"location":"developers/general-doc/smart-contracts/#blob-index-and-blobs","title":"Blob index and blobs","text":"<p>Since a blob transaction can include several blobs, the design includes:</p> <ul> <li><code>pub index: BlobIndex</code>: uniquely identifies a specific blob within a transaction.</li> <li><code>pub blobs: Vec&lt;u8&gt;</code>: all blobs included in the transaction.</li> </ul>"},{"location":"developers/general-doc/smart-contracts/#success","title":"Success","text":"<p>This boolean field indicates whether the proof is for a successful transaction or a failure. It can be useful to prove that a transaction is invalid.</p> <p>Use case example: Vibe Check.</p>"},{"location":"developers/general-doc/smart-contracts/#other-program-specific-outputs","title":"Other program-specific outputs","text":"<p>Smart contracts can provide additional outputs as part of the proof they generate.</p> <p>These outputs mostly serve to provide data availability.</p>"},{"location":"developers/general-doc/smart-contracts/#events","title":"Events","text":"<p>Hyl\u00e9 does not include events. The protocol replaces traditional event systems with blobs, which act as containers for offchain data.</p>"},{"location":"developers/general-doc/supported-proving-schemes/","title":"Proving schemes","text":""},{"location":"developers/general-doc/supported-proving-schemes/#proving-schemes","title":"Proving schemes","text":"<p>Proving schemes are the cryptographic protocols that make zero-knowledge proofs usable.</p> <p>We support as many as we can, giving you the flexibility to choose the most suitable protocol for your specific use case.</p>"},{"location":"developers/general-doc/supported-proving-schemes/#supported-proving-schemes","title":"Supported proving schemes","text":"<p>As of December 2024, Hyl\u00e9 currently supports the following zero-knowledge proving schemes:</p> <ul> <li>Noir</li> <li>Risc0</li> <li>SP1</li> </ul>"},{"location":"developers/general-doc/supported-proving-schemes/#native-verification","title":"Native verification","text":"<p>We verify these natively, without the need for a ZK proof.</p> <ul> <li>sha3_256</li> <li>BLST signatures</li> </ul>"},{"location":"developers/general-doc/supported-proving-schemes/#planned-future-support","title":"Planned future support","text":"<p>We plan to support all major proving schemes eventually.</p> <p>The next proving schemes we're aiming to support are:</p> <ul> <li>Cairo via Stwo</li> <li>Groth16</li> </ul>"},{"location":"developers/general-doc/transaction/","title":"Transactions on Hyl\u00e9","text":""},{"location":"developers/general-doc/transaction/#transactions-on-hyle","title":"Transactions on Hyl\u00e9","text":"<p>On traditional blockchains,  users sign their transactions with a wallet and submit them to a node for block inclusion.</p> <p>On Hyl\u00e9, onchain operations are split into two distinct transactions:</p> <ul> <li>Blob transaction: describes the intended operation.</li> <li>Proof transaction: proves the correct execution of the operation.</li> </ul> <p>We cut these in two steps because ZK proofs take longer to generate than traditional signature.</p> <p>Why two steps ? Because zkProof are not as fast to generate as traditional signatures. By sequencing your intent with a blob transaction, you can later update the state with a proof transaction after the proof is ready. For more details, read our pipelined proving principles.</p> <p>Each proof transaction (unless using recursion) proves a single blob. If a blob transaction contains multiple blobs, a separate proof is needed for each blob.</p> <p>Once all blobs are proven, the blob transaction is considered settled, and the states of the referenced contracts are updated.</p>"},{"location":"developers/general-doc/transaction/#example-token-transfer","title":"Example: token transfer","text":"<p>For a token transfer, a blob transaction contains two blobs:</p> <ul> <li>Identity blob: verifies the sender\u2019s identity and authorizes the transfer.</li> <li>Transfer: executes the token transfer.</li> </ul> <p>These two blobs require two corresponding proof transactions.</p>"},{"location":"developers/general-doc/transaction/#blob-transaction-structure","title":"Blob transaction structure","text":"<p>A blob transaction includes two key fields:</p> <ul> <li>An identity string. See the dedicated page on identity.</li> <li>A list of blobs, each containing:</li> <li>A contract name string.</li> <li>A data binary field, which will be parsed by the contract.</li> </ul> <p>For the token transfer example, the blob transaction looks like this:</p> <pre><code>{\n    \"identity\": \"bob.hydentity\",\n    \"blobs\": [\n        {\n            \"contract_name\": \"hydentity\",\n             // Binary data for the operation of hydentity contract\n             // VerifyIdentity { account: \"bob.hydentity\", nonce: \"2\" }\n            \"data\": \"[...]\" \n        },\n        {\n            \"contract_name\": \"hyllar\",\n             // Binary data for the operation of hyllar contract\n             // Transfer { recipient: \"alice.hydentity\", ammount: \"20\" }\n            \"data\": \"[...]\"\n        }\n    ]\n}\n</code></pre>"},{"location":"developers/general-doc/transaction/#proof-transaction-structure","title":"Proof transaction structure","text":"<p>A Proof transaction is made of</p> <ul> <li>A contract name (string)</li> <li>The proof data (binary field), holding:</li> <li>the ZK proof;</li> <li>the smart contract output.</li> </ul> <p>For Risc0 &amp; SP1, the proof data's smart contract output is <code>HyleOutput</code>, as defined in the contract-sdk. It includes the following information:</p> <ul> <li>The initial state of the contract</li> <li>The new state of the contract</li> <li>The identity that made the operation</li> <li>A reference to the proven blob, composed of a transaction hash and an index</li> <li>Additional fields for proof validation, built by the SDK.</li> </ul> <p>For the token transfer example, the two proofs will look like this:</p> <pre><code>{\n    \"contract_name\": \"hydentity\",\n    // Binary proof, holding a HyleOutput with :\n    // initial_state: the state of the contract \"hydentity\" \n    //    before the blob transaction execution \n    //    (nonce of bob is 1)\n    // next_state: the state of the contract \"hydentity\" \n    //    after the blob transaction execution \n    //    (nonce of bob is 2)\n    // identity: \"bob.hydentity\"\n    // tx_hash: the above blob transaction hash \n    // index: 0\n    \"proof\": \"[...]\"\n}\n</code></pre> <p>and</p> <pre><code>{\n    \"contract_name\": \"hyllar\",\n    // Binary proof, holding a HyleOutput with :\n    // initial_state: the state of the contract \"hyllar\" \n    //    before the blob transaction execution \n    //    (balance of bob is 100 and alice is 0)\n    // next_state: the state of the contract \"hyllar\" \n    //    after the blob transaction execution \n    //    (balance of bob is 80 and alice is 20)\n    // identity: \"bob.hydentity\"\n    // tx_hash: the above blob transaction hash \n    // index: 1\n    \"proof\": \"[...]\"\n}\n</code></pre>"},{"location":"developers/quickstart/","title":"Quickstart","text":"<p>Welcome to the Quickstart guide for Hyl\u00e9.</p> <p>This page will help you configure your environment and start using Hyl\u00e9.</p> <p>Use the sidebar to navigate through the guide, or click on the links below to jump to a specific section:</p> <ol> <li>Run your local devnet</li> <li>Create your first smart contract</li> <li>Use your favorite identity contract</li> <li>Call several contracts in one transaction with proof composition</li> </ol>"},{"location":"developers/quickstart/custom-identity-contract/","title":"Using a custom identity contract","text":""},{"location":"developers/quickstart/custom-identity-contract/#using-a-custom-identity-contract","title":"Using a custom identity contract","text":""},{"location":"developers/quickstart/custom-identity-contract/#when-to-use-identity-contracts-on-hyle","title":"When to use identity contracts on Hyl\u00e9","text":"<p>On Hyl\u00e9, any smart contract can serve as proof of identity. This flexibility allows you to register your preferred identity source as a smart contract for account identification. Hyl\u00e9 also ships a native <code>hydentity</code> contract for simplicity.</p> <p>This guide walks you through creating and deploying your first simple identity contract using Hyl\u00e9 and RISC Zero. We'll use our simple identity example, which mirrors our simple token transfer example.</p> <p>For a deeper understanding of smart contracts, explore our identity management documentation.</p>"},{"location":"developers/quickstart/custom-identity-contract/#run-the-example","title":"Run the example","text":"<p>Warning</p> <p>Our examples work on Hyl\u00e9 v0.7.2. Subsequent versions introduce breaking changes which have not yet been reflected in our examples.</p> <p>Info</p> <p>You can jump to Code Snippets for an in-depth look at the contract.</p>"},{"location":"developers/quickstart/custom-identity-contract/#prerequisites","title":"Prerequisites","text":"<ul> <li>Install Rust (you'll need <code>rustup</code> and Cargo).</li> <li>Install openssl-dev (e.g. <code>apt install openssl-dev</code> or <code>cargo add openssl</code>).</li> <li>For our example, install RISC Zero.</li> <li>Start a single-node devnet. We recommend using dev-mode with <code>-e RISC0_DEV_MODE=1</code> for faster iterations during development.</li> </ul>"},{"location":"developers/quickstart/custom-identity-contract/#build-and-register-the-identity-contract","title":"Build and register the identity contract","text":"<p>To build all methods and register the smart contract on the local node from the source, from the cloned Examples folder, run:</p> <pre><code>cargo run -- register-contract\n</code></pre> <p>The expected output is <code>\ud83d\udcdd Registering new contract simple_identity</code>.</p>"},{"location":"developers/quickstart/custom-identity-contract/#register-an-account-sign-up","title":"Register an account / Sign up","text":"<p>To register an account with a username (<code>alice</code>) and password (<code>abc123</code>), execute:</p> <pre><code>cargo run -- register-identity alice.simple_identity abc123\n</code></pre> <p>The node's logs will display:</p> <pre><code>INFO hyle::data_availability::node_state::verifiers: \u2705 Risc0 proof verified.\nINFO hyle::data_availability::node_state::verifiers: \ud83d\udd0e Program outputs: Successfully registered identity for account: alice.simple_identity\n</code></pre>"},{"location":"developers/quickstart/custom-identity-contract/#verify-identity-login","title":"Verify identity / Login","text":"<p>To verify <code>alice</code>'s identity:</p> <pre><code>cargo run -- verify-identity alice.simple_identity abc123 0\n</code></pre> <p>This command will:</p> <ol> <li>Send a blob transaction to verify <code>alice</code>'s identity.</li> <li>Generate a ZK proof of that identity. It will only be valid once, thus the inclusion of a nonce.</li> <li>Send the proof to the devnet.</li> </ol> <p>Upon reception of the proof, the node will:</p> <ol> <li>Verify the proof.</li> <li>Settle the blob transaction.</li> <li>Update the contract's state.</li> </ol> <p>The node's logs will display:</p> <pre><code>INFO hyle::data_availability::node_state::verifiers: \u2705 Risc0 proof verified.\nINFO hyle::data_availability::node_state::verifiers: \ud83d\udd0e Program outputs: Identity verified for account: alice.simple_identity\n</code></pre> <p>See your contract's state digest at: <code>https://hyleou.hyle.eu/contract/$CONTRACT_NAME</code>.</p> <p>See your transaction on Hyl\u00e9's explorer: <code>https://hyleou.hyle.eu/tx/$TX_HASH</code>.</p>"},{"location":"developers/quickstart/custom-identity-contract/#development-mode","title":"Development mode","text":"<p>We recommend activating dev-mode during your early development phase for faster iteration upon code changes with <code>-e RISC0_DEV_MODE=1</code>.</p> <p>You may also want to get insights into the execution statistics of your project: add the environment variable <code>RUST_LOG=\"[executor]=info\"</code> before running your project.</p> <p>The full command to run your project in development mode while getting execution statistics is:</p> <pre><code>RUST_LOG=\"[executor]=info\" RISC0_DEV_MODE=1 cargo run\n</code></pre>"},{"location":"developers/quickstart/custom-identity-contract/#code-snippets","title":"Code snippets","text":"<p>Find the full annotated code in our examples repository.</p> <p>Info</p> <p>Learn more on the Transactions on Hyl\u00e9 page.</p>"},{"location":"developers/quickstart/custom-identity-contract/#registering-the-contract","title":"Registering the contract","text":"<p>This part is the same as for Your first smart contract.</p>"},{"location":"developers/quickstart/custom-identity-contract/#register-an-identity","title":"Register an identity","text":""},{"location":"developers/quickstart/custom-identity-contract/#build-the-blob-transaction","title":"Build the blob transaction","text":"<p>This is a simplified code snippet:</p> <pre><code>let action = RegisterIdentity {\n    account: identity,\n};\nlet blob = sdk::Blob {\n    contract_name: contract_name,\n    data: action.as_blob_data(), // Note: This function does not exist. Used here for clarity\n};\nlet blob_tx = BlobTransaction {\n    identity: identity,\n    blobs: vec![blob],\n};\n</code></pre> <p>You can compare these to the fields described in the Transactions on Hyl\u00e9 page.</p>"},{"location":"developers/quickstart/custom-identity-contract/#prove-the-registration","title":"Prove the registration","text":""},{"location":"developers/quickstart/custom-identity-contract/#on-the-backend-side","title":"On the backend side","text":"<p>(The backend is called \"host\" in Risc0.)</p> <p>Hyl\u00e9 transactions are settled in two steps, following pipelined proving principles. After sending the blob, your transaction is sequenced, but not settled.</p> <p>For the transaction to be settled, it needs to be proven. You'll start with building the contract input, specifying:</p> <ul> <li>the initial state</li> <li>the identity of the transaction initiator</li> <li>the transaction hash, which can be found in the explorer after sequencing</li> <li>information about the blobs.</li> <li>The password as a private input for proof generation in <code>private_blob</code></li> <li><code>blobs</code>: full list of blobs in the transaction (must match the blob transaction)</li> <li><code>index</code>: each blob of a transaction must be proven separately for now, so you need to specify the index of the blob you're proving.</li> </ul> <pre><code>// Build the contract input\nlet inputs = ContractInput {\n    initial_state: initial_state.as_digest(),\n    identity: blob_tx.identity,\n    tx_hash: blob_tx_hash,\n    private_blob: sdk::BlobData(password),\n    blobs: blobs,\n    index: sdk::BlobIndex(0),\n};\n</code></pre>"},{"location":"developers/quickstart/custom-identity-contract/#on-the-contract-side","title":"On the contract side","text":"<p>(The contract is called \"guest\" in Risc0.)</p> <p>These inputs are then used by the sdk to initialize the contract :</p> <pre><code>    // Parse contract inputs\n    let (input, action) = sdk::guest::init_raw::&lt;IdentityAction&gt;();\n</code></pre> <ul> <li>The input variable is the above constructed ContractInput</li> <li>The action contains the <code>let action RegisterIdentity { account: identity };</code> defined in the blob.</li> </ul> <p>The password is retrieved by the guest:</p> <pre><code>    // Extract private information\n    let password = from_utf8(&amp;input.private_blob.0).unwrap();\n</code></pre> <p>The action is then handled by the contract:</p> <pre><code>    // We clone the inital state to be updated\n    let mut next_state: Identity = input.initial_state.clone();\n\n    // Execute the given action\n    let res = sdk::identity_provider::execute_action(&amp;mut next_state, action, password);\n</code></pre> <p>And the contract then commits the new state:</p> <pre><code>    sdk::guest::commit(input, next_state, res);\n</code></pre> <p>The <code>guest::commit</code> function includes the <code>HyleOutput</code> as explained in Transactions on Hyl\u00e9.</p>"},{"location":"developers/quickstart/custom-identity-contract/#verify-an-identity","title":"Verify an identity","text":"<p>The process is the same as for registering a new identity, but the action is different:</p> <pre><code>let action = VerifyIdentity {\n    account: identity,\n    nonce,\n};\n</code></pre> <p>Check the full annotated code in our GitHub example.</p>"},{"location":"developers/quickstart/devnet/","title":"Run your local devnet","text":""},{"location":"developers/quickstart/devnet/#run-your-local-devnet","title":"Run your local devnet","text":"<p>Follow the instructions below to start building on Hyl\u00e9 by running a local devnet. (Instructions for a testnet will be added when we launch it.)</p> <p>Warning</p> <p>Our examples work on Hyl\u00e9 v0.7.2: <code>git checkout tags/v0.7.2</code>.</p>"},{"location":"developers/quickstart/devnet/#recommended-getting-started-with-docker","title":"Recommended: Getting started with Docker","text":"<p>Follow these instructions to run a node, keeping in mind that this is unstable and can break with upcoming updates.</p> <p>Download the Docker image:</p> <pre><code>docker pull ghcr.io/hyle-org/hyle:v0.7.2\n</code></pre> <p>Run the image:</p> <pre><code>docker run -v ./data:/hyle/data -p 4321:4321 ghcr.io/hyle-org/hyle:v0.7.2\n</code></pre> <p>If you run into an error, you may want to add the <code>--privileged</code> flag:</p> <pre><code>docker run --privileged -v ./data:/hyle/data -p 4321:4321 ghcr.io/hyle-org/hyle:v0.7.2\n</code></pre> <p>If you want to run with an indexer add the parameter <code>-e HYLE_RUN_INDEXER=true</code>, you will need a running PostgreSQL server. You can set it up with Docker:</p> <p>Run the postgres server:</p> <pre><code>docker run -d --rm --name pg_hyle -p 5432:5432 -e POSTGRES_PASSWORD=postgres postgres\n</code></pre> <p>And the node linked to it:</p> <pre><code>docker run -v ./data:/hyle/data \\\n    -e HYLE_RUN_INDEXER=true \\\n    -e HYLE_DATABASE_URL=postgres://postgres:postgres@pg_hyle:5432/postgres \\\n    --link pg_hyle \\\n    -p 4321:4321 \\\n    ghcr.io/hyle-org/hyle:v0.7.2\n</code></pre> <p>You can now create your first smart contract.</p> <p>Tip</p> <p>To restart your devnet from scratch, you should delete your <code>./data</code> folder and start over; otherwise, you risk re-registering a contract that still exists.</p>"},{"location":"developers/quickstart/devnet/#build-the-docker-image-locally","title":"Build the Docker image locally","text":"<p>If you want to, you can rebuild the image locally from source:</p> <pre><code>docker build -t Hyle-org/hyle . &amp;&amp; docker run -dit Hyle-org/hyle\n</code></pre>"},{"location":"developers/quickstart/devnet/#alternative-getting-started-from-source","title":"Alternative: Getting started from source","text":"<p>To start a single-node devnet (with consensus disabled), which is useful to build &amp; debug smart contracts, run:</p> <pre><code>cargo build\nHYLE_RUN_INDEXER=false cargo run --bin hyle\n</code></pre> <p>To run our examples, please <code>git checkout tags/v0.7.2</code>: this is the version they run on.</p>"},{"location":"developers/quickstart/devnet/#configuration","title":"Configuration","text":"<p>You can configure your setup using environment variables or by editing a configuration file.</p>"},{"location":"developers/quickstart/devnet/#using-environment-variables","title":"Using environment variables","text":"<p>All variables can be customized on your single-node instance.</p> Variable Default value Description HYLE_ID node Node identifier in the consensus. Usage subject to change in future releases. HYLE_SINGLE_NODE true Whether the network runs as a single node or with a multi-node consensus. HYLE_P2P_LISTEN true Mandatory (true) if multi-node consensus. The node should listen to new peers. HYLE_HOST 127.0.0.1:1231 Host &amp; port to listen for the P2P protocol. HYLE_PEERS [] List of peers to connect to at startup to follow a running consensus. HYLE_STORAGE__INTERVAL 10 unused HYLE_LOG_FORMAT full \u201cfull\u201d or \u201cjson\u201d HYLE_REST 127.0.0.1:4321 Host &amp; port for the REST API endpoint. HYLE_DATA_DIRECTORY data_node Directory name to store node state. HYLE_DATABASE_URL postgres://postgres:postgres @localhost:5432/postgres PostgreSQL server address (necessary if you want to use an indexer). HYLE_CONSENSUS__SLOT_DURATION 1000 Duration between blocks. HYLE_CONSENSUS__GENESIS_STAKERS {} Keys are all nodes \u201cid\u201d, and values are the stake amount for each one of them. Map of stakers for the genesis block. HYLE_P2P__PING_INTERVAL 10 Interval the p2p layer does a ping to check aliveness of other peers. HYLE_RUN_INDEXER true Whether there should be an indexer. HYLE_DA_ADDRESS 127.0.0.1:4141 Host &amp; port of the data availability module, which streams historical &amp; new blocks. It might be used by indexers."},{"location":"developers/quickstart/devnet/#using-a-configuration-file","title":"Using a configuration file","text":"<p>To use a configuration file, copy the default settings where you run the node. If a file named config.ron is present, it will be automatically loaded by the node at startup.</p> <p>If you're using Docker:</p> <pre><code>docker run -v ./data:/hyle/data -v ./config.run:/hyle/config.ron -e HYLE_RUN_INDEXER=false -p 4321:4321 -p 1234:1234 ghcr.io/hyle-org/hyle:v0.7.2\n</code></pre> <p>Then, whether you're using Docker or building from source:</p> <pre><code>cp ./src/utils/conf_defaults.ron config.ron\n</code></pre>"},{"location":"developers/quickstart/proof-composition/","title":"Proof composition with Ticket App","text":""},{"location":"developers/quickstart/proof-composition/#proof-composition-with-ticket-app","title":"Proof composition with Ticket App","text":"<p>Hyl\u00e9 enables proof composition, allowing you to use different proving systems in a single operation. This eliminates constraints on provers and significantly boosts interoperability and efficiency. Read this introduction to proof composability to understand how this works.</p> <p>In this guide, we\u2019ll build a Ticket App that leverages proof composition. Users can buy a ticket using a simple-token, and Hyl\u00e9 will verify multiple proofs in a single transaction.</p> <p>Find the source code for all contracts here:</p> <ul> <li>ticket-app</li> <li>simple-identity</li> <li>simple-token</li> </ul> <p>Traditional verification systems often require all proofs to be generated using the same proving system. Hyl\u00e9 removes this limitation, allowing:</p> <ul> <li>Interoperability: use different proof systems within a single transaction.</li> <li>Atomicity: either all proofs verify, or none do. This ensures fail-safe execution.</li> <li>Efficiency: parallel processing of proofs without requiring a single proving standard.</li> </ul>"},{"location":"developers/quickstart/proof-composition/#how-this-example-works","title":"How this example works","text":"<p>In this example, <code>Alice</code> and <code>Bob</code> both want to buy a ticket from Ticket App for 15 <code>simple-tokens</code>. Only Bob has enough tokens to complete the transaction.</p> <p>Let\u2019s walk through an example where Bob and Alice want to buy a ticket from Ticket App, which costs <code>15 simple-tokens</code>. Bob has enough balance, Alice does not.</p>"},{"location":"developers/quickstart/proof-composition/#step-1-create-the-blob-transaction","title":"Step 1: Create the blob transaction","text":"<p>The Ticket App backend creates and sends a blob transaction to Hyl\u00e9, including three blobs:</p> <ul> <li>an identity blob (see our custom identity contract quickstart) confirming that Bob (<code>bob.id</code>) is initiating the transaction;</li> <li>a simple-token blob performing a transfer of 15 simple-tokens taken from <code>bob.id</code>'s balance;</li> <li>a ticket-app blob sending <code>bob.id</code> a ticket if conditions are met.</li> </ul> <p>For now, Hyl\u00e9 sequences this transaction, but it\u2019s not processed yet. Read more about pipelined proving.</p>"},{"location":"developers/quickstart/proof-composition/#step-2-prove-the-blobs","title":"Step 2: Prove the blobs","text":"<p>The Ticket App backend now generates ZK proofs of each blob.</p> <p>During this time, the code of the <code>ticket-app</code> contract is executed. During execution, the <code>ticket-app</code> smart contract checks that there is a <code>simple-token</code> blob performing a transfer of 15 simple-tokens taken from <code>bob.id</code>'s balance to the <code>ticket-app</code> contract.</p> <p>At this step, it cannot yet confirm Bob has enough tokens, but that\u2019s fine: if the token transfer fails in Step 3, the entire transaction fails.</p> <p>Check out what the source code looks like.</p>"},{"location":"developers/quickstart/proof-composition/#step-3-settlement","title":"Step 3: Settlement","text":"<p>Once TicketApp has sent the proofs for the previously sequenced blobs, Hyl\u00e9 verifies these proofs:</p> <ul> <li>identity blob: verifies that <code>bob.id</code> has initiated the transaction.</li> <li>simple-token blob: verifies that <code>bob.id</code> paid the correct amount for his ticket.</li> <li>ticket-app blob: verifies that <code>bob.id</code> has received the ticket.</li> </ul> <p>If all proofs are valid, the simple-token balance and ticket-app ticket balance are updated simultaneously at transaction settlement: <code>bob.id</code> sends 15 simple-tokens and gains one ticket.</p> <p>If any proof fails, the entire transaction fails. Neither state is updated: <code>bob.id</code>'s token balance does not change and still has no ticket.</p> <p>To see proof composition in action in a different setting, you can check out our Vibe Check demo, which mixes Cairo and Noir proofs.</p>"},{"location":"developers/quickstart/proof-composition/#run-the-example","title":"Run the example","text":"<p>Warning</p> <p>Our examples work on Hyl\u00e9 v0.7.2. Later versions introduce breaking changes which have not yet been reflected in our examples.</p>"},{"location":"developers/quickstart/proof-composition/#prerequisites","title":"Prerequisites","text":"<ul> <li>Install Rust (you'll need <code>rustup</code> and Cargo).</li> <li>For our example, install RISC Zero.</li> <li>Start a single-node devnet.</li> </ul> <p>This quickstart guide will take you through the following steps:</p> <ul> <li>Simple-identity preparation: register an identity contract &amp; two identities.</li> <li>Simple-token preparation: register a token contract and faucet the users with this token.</li> <li>Register the ticket-app contract</li> <li>Buy a ticket on ticket-app</li> </ul>"},{"location":"developers/quickstart/proof-composition/#simple-identity-preparation","title":"Simple-identity preparation","text":"<p>Let's start with registering an identity contract and two identities.</p> <p>Go to the <code>./simple-identity</code> folder and run:</p> <pre><code>cargo run -- --contract-name id register-contract\n</code></pre> <p>Now we have an identity contract called <code>id</code>. We can use it to declare our users:</p> <pre><code>cargo run -- --contract-name id register-identity bob.id pass\ncargo run -- --contract-name id register-identity alice.id pass\n</code></pre> <p>Let's verify it quickly with:</p> <pre><code>cargo run -- --contract-name id verify bob.id pass 0\n</code></pre> <p>0 is a nonce: every time we verify successfully bob's identity, it increments. Now if we want to verify it again, we should use 1 as nonce. (We also use \u00ab pass \u00bb as our default password.)</p> <p>We now do the same for alice:</p> <pre><code>cargo run -- --contract-name id verify alice.id pass 0\n</code></pre> <p><code>bob.id</code> is bob's identity on the simple-identity contract. Check out our Identity management and custom identity contract pages to know more.</p>"},{"location":"developers/quickstart/proof-composition/#simple-token-preparation","title":"Simple-token preparation","text":""},{"location":"developers/quickstart/proof-composition/#register-simple-token","title":"Register simple-token","text":"<p>Go to <code>./simple-token</code> folder and run:</p> <pre><code>cargo run -- --contract-name simple-token register 1000\n</code></pre> <p>On the node's logs, you will see:</p> <p>\ud83d\udcdd Registering new contract simple_token</p> <p>You just registered a token contract named simple-token with an initial supply of 1000.</p>"},{"location":"developers/quickstart/proof-composition/#transfer-tokens","title":"Transfer tokens","text":"<p>Now let's transfer some tokens to our user <code>bob</code>.</p> <p>To send 50 tokens to <code>bob</code> and 10 tokens to <code>alice</code>, run:</p> <pre><code>cargo run -- -contract-name simple-token transfer faucet.simple-token bob.id 50\ncargo run -- -contract-name simple-token transfer faucet.simple-token alice.id 10\n</code></pre> <p>The node's log will show:</p> <p>INFO hyle::data_availability::node_state::verifiers: \u2705 Risc0 proof verified.</p> <p>INFO hyle::data_availability::node_state::verifiers: \ud83d\udd0e Program outputs: Transferred 50 to bob.ticket_app INFO hyle::data_availability::node_state::verifiers: \ud83d\udd0e Program outputs: Transferred 10 to alice.ticket_app</p>"},{"location":"developers/quickstart/proof-composition/#check-onchain-balance","title":"Check onchain balance","text":"<p>Check onchain balance:</p> <pre><code>cargo run -- --contract-name simple-token balance faucet.simple-token\n\ncargo run -- --contract-name simple-token balance bob.id\ncargo run -- --contract-name simple-token balance alice.id\n</code></pre> <p>You should see that <code>bob</code> has a balance of 50 and <code>alice</code> has a balance of 10.</p>"},{"location":"developers/quickstart/proof-composition/#using-ticket-app","title":"Using ticket-app","text":"<p>Now that <code>bob</code> has some tokens, let's buy him a ticket.</p>"},{"location":"developers/quickstart/proof-composition/#register-ticket-app","title":"Register ticket-app","text":"<p>Register the ticket app by going to <code>./ticket-app</code> folder and running:</p> <pre><code>cargo run -- --contract-name ticket-app register simple-token 15\n</code></pre> <p>ticket-app sells bob a ticket for 15 simple-token.</p>"},{"location":"developers/quickstart/proof-composition/#buy-a-ticket","title":"Buy a ticket","text":"<p>Let's buy a ticket for <code>bob</code>:</p> <pre><code>cargo run -- --contract-name ticket-app --user bob.id buy-ticket\n</code></pre> <p>Let's try with <code>alice</code>:</p> <pre><code>cargo run -- --contract-name ticket-app --user alice.id buy-ticket\n</code></pre> <p>You will get an error while executing the TicketApp program: <code>Execution failed ! Program output: Insufficient balance</code>. This is because Alice has a balance of 10 and the ticket costs 15.</p>"},{"location":"developers/quickstart/proof-composition/#check-ticket-and-token-balance","title":"Check ticket and token balance","text":"<p>Check that <code>bob</code> has a ticket:</p> <pre><code>cargo run -- --contract-name ticket-app --user bob.id has-ticket\n</code></pre> <p>You can also check <code>bob</code>'s balance and see he now has 35 tokens.</p> <p>With proof composition, Hyl\u00e9 empowers you to leverage multiple proving systems in a single transaction, making advanced functionality like the Ticket App easier than ever.</p>"},{"location":"developers/quickstart/your-first-smart-contract/","title":"Your first smart contract","text":""},{"location":"developers/quickstart/your-first-smart-contract/#your-first-smart-contract","title":"Your first smart contract","text":"<p>This guide will walk you through creating and deploying your first token transfer contract using Hyl\u00e9's tools and infrastructure. We'll use our sample token transfer example as the basis for this tutorial.</p> <p>You can also check out the same example built with SP1.</p> <p>For an in-depth understanding of smart contracts, check out the anatomy of a smart contract.</p>"},{"location":"developers/quickstart/your-first-smart-contract/#example","title":"Example","text":"<p>Warning</p> <p>Our examples work on Hyl\u00e9 v0.7.2. Subsequent versions introduce breaking changes which have not yet been reflected in our examples.</p>"},{"location":"developers/quickstart/your-first-smart-contract/#prerequisites","title":"Prerequisites","text":"<ul> <li>Install Rust (you'll need <code>rustup</code> and Cargo).</li> <li>Install openssl-dev (e.g. <code>apt install openssl-dev</code> or <code>cargo add openssl</code>).</li> <li>For our example, install RISC Zero.</li> <li>Start a single-node devnet. We recommend using dev-mode with <code>-e RISC0_DEV_MODE=1</code> for faster iterations during development.</li> </ul>"},{"location":"developers/quickstart/your-first-smart-contract/#quickstart","title":"Quickstart","text":""},{"location":"developers/quickstart/your-first-smart-contract/#build-and-register-the-contract","title":"Build and register the contract","text":"<p>To build all methods and register the smart contract on the local node from the source, from the cloned Examples folder, run:</p> <pre><code>cargo run -- register 1000\n</code></pre> <p>The expected output is <code>\ud83d\udcdd Registering new contract simple_token</code>.</p>"},{"location":"developers/quickstart/your-first-smart-contract/#transfer-tokens","title":"Transfer tokens","text":"<p>To transfer 2 tokens from the Hyl\u00e9 <code>faucet</code> to <code>Bob</code>:</p> <pre><code>cargo run -- transfer faucet.simple_token bob.simple_token 2\n</code></pre> <p>This command will:</p> <ol> <li>Send a blob transaction to transfer 2 tokens from <code>faucet</code> to <code>bob</code>. To better understand what a blob transaction is, read more about transactions on Hyl\u00e9.</li> <li>Generate a ZK proof of that transfer.</li> <li>Send the proof to the devnet. (Scroll down to see what that looks like in code.)</li> </ol>"},{"location":"developers/quickstart/your-first-smart-contract/#verify-settled-state","title":"Verify settled state","text":"<p>Upon reception of the proof, the node will:</p> <ol> <li>Verify the proof</li> <li>Settle the blob transaction</li> <li>Update the contract's state</li> </ol> <p>The node's logs will display:</p> <pre><code>INFO hyle::data_availability::node_state::verifiers: \u2705 Risc0 proof verified.\nINFO hyle::data_availability::node_state::verifiers: \ud83d\udd0e Program outputs: Transferred 2 to bob.simple_token\n</code></pre> <p>And on the following slot:</p> <pre><code>INFO hyle::data_availability::node_state: Settle tx TxHash(\"[..]\")\n</code></pre>"},{"location":"developers/quickstart/your-first-smart-contract/#check-onchain-balance","title":"Check onchain balance","text":"<p>Verify onchain balances:</p> <pre><code>cargo run -- balance faucet.simple_token\ncargo run -- balance bob.simple_token\n</code></pre> <p>Note</p> <p>In this example, we do not verify the identity of the person who initiates the transaction. We use <code>.simple_token</code> as a suffix for the \"from\" and \"to\" transfer fields. Usually, we'd use the identity scheme as the suffix. More information about identity management will be added to the documentation in January 2025.</p> <p>See your contract's state digest at: <code>https://hyleou.hyle.eu/contract/$CONTRACT_NAME</code>.</p> <p>See your transaction on Hyl\u00e9's explorer: <code>https://hyleou.hyle.eu/tx/$TX_HASH</code>.</p>"},{"location":"developers/quickstart/your-first-smart-contract/#detailed-information","title":"Detailed information","text":""},{"location":"developers/quickstart/your-first-smart-contract/#development-mode","title":"Development mode","text":"<p>We recommend activating dev-mode during your early development phase for faster iteration upon code changes with <code>-e RISC0_DEV_MODE=1</code>.</p> <p>You may also want to get insights into the execution statistics of your project: add the environment variable <code>RUST_LOG=\"[executor]=info\"</code> before running your project.</p> <p>The full command to run your project in development mode while getting execution statistics is:</p> <pre><code>RUST_LOG=\"[executor]=info\" RISC0_DEV_MODE=1 cargo run\n</code></pre>"},{"location":"developers/quickstart/your-first-smart-contract/#annotated-code-snippets","title":"Annotated code snippets","text":"<p>Find the full annotated code in our examples repository.</p> <p>These code snippets show you what your code could look like when writing your own smart contracts.</p>"},{"location":"developers/quickstart/your-first-smart-contract/#registering-the-contract","title":"Registering the contract","text":"<p>Set up information about your contract. To register the contract, you'll need:</p> <ul> <li><code>owner</code>: we put \"examples\" as the <code>owner</code>, but you can put anything you like. This field is currently not leveraged; it will be in future versions.</li> <li><code>verifier</code>: for this example, the verifier is <code>risc0</code></li> <li><code>program_id</code>: RISC Zero programs are identified by their image ID, without a prefix.</li> <li><code>state_digest</code>: usually a MerkleRootHash of the contract's initial state. For this example, we use a hexadecimal representation of the state encoded in binary format. The state digest cannot be empty, even if your app is stateless.</li> <li><code>contract_name</code> as set up above.</li> </ul> <pre><code>// Build initial state of contract\nlet initial_state = Token::new(supply, format!(\"faucet.{}\", contract_name).into());\nprintln!(\"Initial state: {:?}\", initial_state);\n\n// Send the transaction to register the contract\nlet register_tx = RegisterContractTransaction {\n    owner: \"examples\".to_string(),\n    verifier: \"risc0\".into(),\n    program_id: sdk::ProgramId(sdk::to_u8_array(&amp;GUEST_ID).to_vec()),\n    state_digest: initial_state.as_digest(),\n    contract_name: contract_name.clone().into(),\n};\nlet res = client\n    .send_tx_register_contract(&amp;register_tx)\n    .await\n    .unwrap()\n    .text()\n    .await\n    .unwrap();\n\nprintln!(\"\u2705 Register contract tx sent. Tx hash: {}\", res);\n</code></pre> <p>In the explorer, this will look like this:</p> <pre><code>{\n    \"tx_hash\": \"321b7a4b2228904fc92979117e7c2aa6740648e339c97986141e53d967e08097\",\n    \"owner\": \"examples\",\n    \"verifier\": \"risc0\",\n    \"program_id\":\"e085fa46f2e62d69897fc77f379c0ba1d252d7285f84dbcc017957567d1e812f\",\n    \"state_digest\": \"fd00e876481700000001106661756365742e687964656e74697479fd00e876481700000000\",\n    \"contract_name\": \"simple_token\"\n}\n</code></pre>"},{"location":"developers/quickstart/your-first-smart-contract/#create-blob-transaction","title":"Create blob transaction","text":"<pre><code>// The action to execute, that will be proved later\nlet action = sdk::erc20::ERC20Action::Transfer {\n    recipient: to.clone(),\n    amount,\n};\n// Into a BlobTransaction to be sent on chain\nlet blobs = vec![sdk::Blob {\n    contract_name: contract_name.clone().into(),\n    data: sdk::BlobData(\n        bincode::encode_to_vec(action, bincode::config::standard())\n            .expect(\"failed to encode BlobData\"),\n    ),\n}];\nlet blob_tx = BlobTransaction {\n    identity: from.into(),\n    blobs,\n};\n\n// Send the blob transaction\nlet blob_tx_hash = client.send_tx_blob(&amp;blob_tx).await.unwrap();\nprintln!(\"\u2705 Blob tx sent. Tx hash: {}\", blob_tx_hash);\n</code></pre>"},{"location":"developers/quickstart/your-first-smart-contract/#prove-the-transaction","title":"Prove the transaction","text":"<p>Hyl\u00e9 transactions are settled in two steps, following pipelined proving principles. After this step, your transaction is sequenced, but not settled.</p> <p>For the transaction to be settled, it needs to be proven. You'll start with building the contract input, specifying:</p> <ul> <li>the initial state as set above</li> <li>the identity of the transaction initiator</li> <li>the transaction hash, which can be found in the explorer after sequencing</li> <li>information about the blobs.</li> <li>private input for proof generation in <code>private_blob</code></li> <li><code>blobs</code>: full list of blobs in the transaction (must match the blob transaction)</li> <li><code>index</code>: each blob of a transaction must be proven separately for now, so you need to specify the index of the blob you're proving.</li> </ul> <pre><code>// Build the contract input\nlet inputs = ContractInput::&lt;Token&gt; {\n    initial_state,\n    identity: from.clone().into(),\n    tx_hash: \"\".into(),\n    private_blob: sdk::BlobData(vec![]),\n    blobs: blobs.clone(),\n    index: sdk::BlobIndex(0),\n};\n\n// Generate the zk proof\nlet receipt = prove(cli.reproducible, inputs).unwrap();\n\nlet proof_tx = ProofTransaction {\n    blob_tx_hash,\n    proof: ProofData::Bytes(borsh::to_vec(&amp;receipt).expect(\"Unable to encode receipt\")),\n    contract_name: contract_name.clone().into(),\n};\n\n// Send the proof transaction\nlet proof_tx_hash = client\n    .send_tx_proof(&amp;proof_tx)\n    .await\n    .unwrap()\n    .text()\n    .await\n    .unwrap();\nprintln!(\"\u2705 Proof tx sent. Tx hash: {}\", proof_tx_hash);\n</code></pre> <p>Check the full annotated code in our GitHub example.</p>"},{"location":"developers/sdk/","title":"SDK","text":""},{"location":"developers/sdk/#sdk","title":"SDK","text":"<p>Our contract SDK includes helper functions for building a smart contract on Hyl\u00e9.</p> <p>Read more: SDK README.</p>"},{"location":"resources/","title":"\ud83d\udcda Resources","text":"<ul> <li>Introduction to zero-knowledge proofs</li> <li>Roadmap</li> <li>Release notes</li> <li>Find us</li> <li>Grants</li> </ul>"},{"location":"resources/find-us/","title":"Find us","text":""},{"location":"resources/find-us/#useful-links","title":"Useful links","text":"<ul> <li>Rust node</li> <li>Hyle.eu</li> <li>Hyl\u00e9 blog</li> </ul>"},{"location":"resources/find-us/#contact-us","title":"Contact us","text":"<p>Reach out to the team for more information:</p>  Github  Twitter  Farcaster  LinkedIn  Youtube  Telegram Hyl\u00e9 @hyle_org @hyle-org Hyl\u00e9 @Hyl\u00e9 @hyle_org"},{"location":"resources/grants/","title":"Contribute to Hyl\u00e9","text":""},{"location":"resources/grants/#contribute-to-hyle","title":"Contribute to Hyl\u00e9","text":""},{"location":"resources/grants/#contribution-opportunities","title":"Contribution opportunities","text":"<p>You can contribute to Hyl\u00e9 in several ways. We are active participants in OnlyDust projects and welcome maintainers.</p> <p>You can also check out our Careers page for longer-term opportunities.</p>"},{"location":"resources/grants/#grant-program","title":"Grant program","text":"<p>We have a grant program supporting developers who want to work on trust infrastructure and programmable cryptography on Hyl\u00e9.</p>"},{"location":"resources/grants/#what-are-our-grants-like","title":"What are our grants like?","text":"<ul> <li>You apply with an original idea or an idea from the list on our repo.</li> <li>We fund your project. You get some money upfront, so you can build without financial worries, and the rest upon completion of the project.</li> <li>You meet regularly with our CEO for guidance and to help you refine your ideas.</li> <li>You are in a Telegram group with our other grantees to share ideas and solutions.</li> <li>Our tech team supports you via Telegram and in meetings.</li> <li>Our business team helps you showcase your idea through external speaking opportunities, co-marketing, and other assets.</li> </ul> <p>To read more, see our grant ideas, and apply, please go to our Grants page on the main Hyl\u00e9 repository. If you represent an organization, we'd love to discuss co-grants ideas.</p> <p>For questions that aren't answered on the Grants page, reach out in our Telegram group.</p>"},{"location":"resources/grants/#current-and-past-grants","title":"Current and past grants","text":"<p>Here are two past grants:</p> <ul> <li>Provable play-by-email games library</li> <li>Proof of residency app</li> </ul> <p>Find the full list on our Grants page on the main Hyl\u00e9 repository.</p>"},{"location":"resources/intro-to-zkp/","title":"Understanding zero-knowledge proofs","text":"<p>Here are some resources on zero-knowledge proofs and how to generate them.</p>"},{"location":"resources/intro-to-zkp/#when-to-use-zero-knowledge-proofs","title":"When to use zero-knowledge proofs","text":"<p>There are three moments when ZK is the right tool for you:</p> <ul> <li>Computing power imbalance (which includes improved scalability): I run resource-heavy computation anywhere and verify the result.</li> <li>Adversarial environment: I can verify a result without knowing trade secrets that attained this result.</li> <li>Anonymity: I share only the information I want to share.</li> </ul>"},{"location":"resources/intro-to-zkp/#how-to-use-zero-knowledge-proofs","title":"How to use zero-knowledge proofs","text":"<p>There are many ZK languages. Hyl\u00e9 aims to verify as many as possible.</p> <p>DSLs, like Circom, are specific languages that usually compile down to a specific circuit. They're good, but they're complex and may have a high learning curve.</p> <p>zkVMs prove the correct execution of arbitrary code. They allow you to build ZK applications in a certain language without having to build a circuit around it. There are two main types of zkVMs: Cairo and RISC-V. You can benchmark your Rust code and find the best zkVM for your needs with the any-zkvm template.</p> <p>We currently support RISC\u2013V-based zkVMs Risc0 and SP1 and will support more types, including Cairo-based zkVMs and DSLs, in the future.</p>"},{"location":"resources/intro-to-zkp/#read-more","title":"Read more","text":"<ul> <li>Zero-knowledge proofs explained at 5 levels of difficulty (22')</li> <li>awesome-zk link repository on GitHub</li> <li>Hyl\u00e9's very simple introduction to zero-knowledge proofs</li> <li>Lauri Peltonen's blog series on ZK</li> </ul>"},{"location":"resources/release-notes/","title":"Release notes","text":""},{"location":"resources/release-notes/#release-notes","title":"Release notes","text":"<p>Read our full changelogs on GitHub or the short versions in our Telegram group.</p>"},{"location":"resources/release-notes/#2025-01-27-v080","title":"2025-01-27 \u2212 v0.8.0","text":"<p>\ud83d\udca5 Breaking changes:</p> <ul> <li>Hyle-contracts: Merged the contracts \u2018metadata\u2019 feature into \u2018client\u2019</li> <li>There are no more <code>RegisterContract</code> transactions: contracts are now registered with <code>BlobTransactions</code>, like everything else.</li> <li>Contract registration has been reworked using proof outputs; we introduced UUID contract names (see uuid-tld for an example).</li> <li>Removed <code>hyled</code> and <code>hyrun</code>. If you were using them, check out our SDK instead.</li> </ul> <p>\u2728New features:</p> <ul> <li>You can now settle transactions that have a proof of failure before they timeout</li> <li>Made progress on the implementation of our consensus</li> </ul> <p>\ud83d\ude85 Improvements:</p> <ul> <li>We now enforce a recent Rust version to avoid errors.</li> </ul> <p>\ud83d\udee0\ufe0f No longer broken:</p> <ul> <li>Bug fixes include Dockerfile, environment variables, and identities.</li> </ul> <p>\ud83d\udcda Documentation:</p> <ul> <li>Our SDK has a README now!</li> </ul> <p>Read the full changelog on GitHub.</p>"},{"location":"resources/release-notes/#2025-01-21-v071-v072","title":"2025-01-21 \u2212 v0.7.1 &amp; v0.7.2","text":"<p>Small patches for our SDK.</p> <p>Read release notes for v0.7.1 and v0.7.2; see new SDK readme for more info.</p>"},{"location":"resources/release-notes/#2025-01-20-v070","title":"2025-01-20 \u2212 v0.7.0","text":"<p>\ud83d\udca5 Breaking changes:</p> <ul> <li>We completely rewrote the dependencies for the SDK.</li> </ul> <p>\u2728 New features;</p> <ul> <li>Adding support of native verifiers. Verify hash signatures, TEE executions without needing a ZK proof! Currently supported: sha3_256 &amp; BLST signatures.</li> <li>You can now use <code>tx hash</code> inside contracts</li> </ul> <p>\ud83d\ude85 Improvements:</p> <ul> <li>Several performance improvements following our latest loadtest</li> <li>Reduce log verbosity and frequency</li> <li>Dependencies: updated risc0-zkvm to 1.2.1, sp1-sdk to 4.0.0</li> </ul> <p>\ud83d\udee0\ufe0f No longer broken:</p> <ul> <li>Loads of bug fixes \u2212 check the full release to know more.</li> </ul> <p>\ud83d\udcda Documentation:</p> <ul> <li>Transactions on Hyl\u00e9</li> <li>Identity management</li> </ul> <p>Read the full changelog on GitHub and receive future release notes in our Telegram group.</p>"},{"location":"resources/release-notes/#2025-01-13-v060","title":"2025-01-13 \u2212 v0.6.0","text":"<p>\u2728 New features:</p> <ul> <li>Added the SP1 prover to the client SDK.</li> </ul> <p>\ud83d\ude85 Improvements:</p> <ul> <li>Upgraded to SP1 4.0.0-rc8.</li> </ul> <p>\ud83d\udee0\ufe0f No longer broken:</p> <ul> <li>Fixed the default configurations.</li> <li>Fixed loading state when restarting a node.</li> </ul> <p>\ud83d\udcda Documentation:</p> <ul> <li>Rewrote our Quickstart guide.</li> </ul> <p>Read the full changelog on GitHub and receive future release notes in our Telegram group.</p>"},{"location":"resources/roadmap/","title":"Roadmap","text":"<p>We do not have a public roadmap at this time. Stay tuned for updates or ask specific questions in our Telegram group.</p>"},{"location":"resources/roadmap/#testnet","title":"Testnet","text":"<p>We will release our testnet in Q2 2025.</p> <p>While we\u2019re working towards launching the testnet, you can get hands-on right now:</p> <ul> <li>Explore our public devnet or spin up your own instance to start building today!</li> <li>Read our release notes for the devnet.</li> <li>If you are an individual, join us for ODBoost weeks.</li> </ul>"},{"location":"resources/roadmap/#proving-schemes","title":"Proving schemes","text":"<p>Check the list of the proving schemes we currently support and the ones we'll work on next.</p>"}]}