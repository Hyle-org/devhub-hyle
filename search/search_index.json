{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Hyl\u00e9 developer docs","text":"<p>Note</p> <p>This developer portal and the project itself are still in early development. See below on how to reach out to us if you need anything that isn't here.</p> <p>Hyl\u00e9 is your minimal layer one, focused only on verifying zero-knowledge proofs.</p> <p>By sending a simple proof to be verified on Hyl\u00e9, you can build a fully off-chain application powered by ZKPs that still has the security guarantees of the blockchain.</p> <ul> <li>Hyl\u00e9 only verifies zero-knowledge proofs: settlement is all you need.</li> <li>Hyl\u00e9 uses minimal storage: we only store the source of truth and our nodes are very light.</li> <li>Hyl\u00e9 is modular by design, for full flexibility.</li> <li>Hyl\u00e9 does not reinvent the wheel: we leverage existing tech stacks (Cairo, Risc0, SP1, etc.)</li> </ul> <p></p> <p>For more information, check out our website.</p>"},{"location":"#getting-started","title":"Getting started","text":"<ol> <li>Check out how to install the CLI</li> <li>Learn how to create your first smart contract</li> </ol>"},{"location":"#our-use-cases","title":"Our use cases","text":"<ul> <li>Hyl\u00e9 for ZKApps </li> <li>Hyl\u00e9 for identity providers &amp; wallets</li> <li>Hyl\u00e9 for RAAS &amp; ZK Coprocessors (coming soon)</li> <li>...</li> </ul>"},{"location":"#contact-us","title":"Contact us","text":"<p>Feel free to reach out to the team for more information:  </p> <ul> <li>X @hyle_org</li> <li>Farcaster @hyle-org</li> <li>Telegram @hyle_org</li> <li>Mail contact@hyle.eu</li> </ul>"},{"location":"#useful-links","title":"Useful links","text":"<ul> <li>Main repository (cosmos SDK app)</li> <li>Hyl\u00e9.eu</li> </ul>"},{"location":"testnet/","title":"Wen testnet ?","text":"<p>Soon\u2122</p> <p>In the meantime, we have a public devnet live, and you can also run your own!</p>"},{"location":"about/","title":"About Hyl\u00e9","text":"<p>Hyl\u00e9 is your minimal layer one, focused only on verifying zero-knowledge proofs.</p> <p>By sending a simple proof to be verified on Hyl\u00e9, you can build a fully off-chain application powered by ZKPs that still has the security guarantees of the blockchain.</p> <p></p>"},{"location":"about/#why-hyle","title":"Why Hyl\u00e9?","text":"<ul> <li>Leverage the power of zero-knowledge proofs for maximum trustlessness and privacy</li> <li>Run complex logic in your smart contracts thanks to off-chain execution</li> <li>Lower your storage costs with efficient and trustless storage proofs</li> <li>Enjoy better readability with our native on-chain Name System</li> <li>Freely create transactions composing private and public inputs</li> </ul> <p>You can execute your smart contracts off-chain anywhere you like, on a rollup, on-premise or even client-side.</p> <p>You can store your data securely in your backend, IPFS, Arweave or any other long-term solution: Hyl\u00e9 provides the verifiable source of truth for your end user.</p> <p>You can choose your proving scheme, your language, your prover, and still get instant finality and enhanced security.</p>"},{"location":"about/#how-does-it-work","title":"How does it work?","text":"<p>Using Hyl\u00e9\u2019s sovereign verification-focused Layer 1, here\u2019s what happens:</p> <ol> <li>No need for a verifier contract: just call the native function.</li> <li>Proof generation: This doesn\u2019t change. Off-chain, the prover generates a zero-knowledge proof of a specific computation.</li> <li>Proof submission: the prover sends the proof and the results of the computation to Hyl\u00e9\u2019s Layer 1 as part of a transaction.</li> <li>Verification: Hyl\u00e9 validators receive the transaction. They use the native verification programs to check the validity of the proof as fast as possible, without being limited by the bulky virtual machine.</li> <li>Consensus and block inclusion: if the proof is valid, the block producer puts the results of the computation on the Hyl\u00e9 blockchain.</li> </ol> <p>And that\u2019s it.</p> <p>With this system, execution and storage happen anywhere you like, without cost barriers. You only need a fast and trustworthy verifier: that\u2019s Hyl\u00e9.</p> <p>For more information, check out our website.</p>"},{"location":"about/anatomy-smart-contracts/","title":"Anatomy of a smart contract","text":"<p>Hyl\u00e9 is a fully programmable blockchain. However, we only store the minimal amount of data required to validate smart contract proofs. Hyl\u00e9 smart contracts are made of a name, a program identifier and a state commitment.</p>"},{"location":"about/anatomy-smart-contracts/#program-identifier","title":"Program Identifier","text":"<p>Smart Contracts in Hyl\u00e9 are identified by a zero knowledge proof scheme and a matching identifier. This tuple is required to verify proofs.</p>"},{"location":"about/anatomy-smart-contracts/#risc-zero","title":"Risc Zero","text":"<p>Risc Zero smart contracts are identified by their <code>image ID</code>. Two identical programs will have identical image IDs.</p>"},{"location":"about/anatomy-smart-contracts/#groth16","title":"Groth16","text":"<p>Groth16 programs require a trusted ceremony. As such, their identifier is the verifying key corresponding to the matching private key, which will be unique for each program &amp; ceremony.</p>"},{"location":"about/anatomy-smart-contracts/#state-commitment","title":"State Commitment","text":"<p>The state commitment is intended to be the minimal amount of data required to attest to the full state of the smart contract. Some example of such structures include:</p> <ul> <li>The full state, for a sufficiently small program (e.g. a fibonacci counter, or a smart-contract with a nonce)</li> <li>A merkle root of the state, for larger programs</li> <li>A hash of the full state could also be used</li> </ul>"},{"location":"about/data-availability/","title":"Data Availability","text":"<p>Hyl\u00e9 will provide self-sufficient permissionless data availability, but not necessarily data retrievability.</p>"},{"location":"about/data-availability/#how-hyle-avoids-the-data-availability-problem","title":"How Hyl\u00e9 avoids the data availability problem","text":"<p>Hyl\u00e9 is a layer one blockchain, and will be decentralised in the future. As such, all validators and full nodes must have access to all data required to accept new blocks. There is therefore no data availability problem for Hyl\u00e9 full nodes.</p> <p>They must however access the full proofs inside each block. Thankfully, because our proofs are proofs of state commitment transitions, they are rather lightweight by themselves.</p>"},{"location":"about/data-availability/#light-nodes","title":"Light nodes","text":"<p>There are currently no light nodes in Hyl\u00e9. In the mid- to long-term, blocks generation will become provable: light nodes will be able to rely on the block headers and proof of block, in the same way that full nodes do. There will be essentially no difference between light and full nodes.</p> <p>Note however that the design of the chain is intended to make full nodes as lightweight as possible, so the need for light nodes is not as pressing as it is for other chains.</p>"},{"location":"about/data-availability/#permissionless-da-for-smart-contracts","title":"Permissionless DA for smart contracts","text":"<p>Because the protocol only requires proofs of the transitions between state commitments, the full state-diff may be hidden. This is by design and enables privacy. </p> <p>For smart contracts that intend to be permissionless, this can lead to DOS. In this case, the program must force the proof to contain the full state-diff.</p> <p>If the proof contains the full state-diff, valid transactions sent to Hyl\u00e9 contain it too and external indexers are able to reconstruct the full state.</p> <p>This solves the data availability problem, assuming that transaction data is available long enough for any honest indexer to reconstruct the full state. </p> <p>This is a rather weak assumption  and our plan is to provide between 7 and 28 days of guaranteed DA, like Ethereum blobs.  </p>"},{"location":"about/data-availability/#data-retrievability","title":"Data retrievability","text":"<p>Historical data is not provided by the protocol, as it is unnecessary to create new blocks. </p> <p>Starting a new node from scratch or reading past transactions for events may still be useful at times. To that end, Hyl\u00e9 nodes can be archive nodes which store the full state of the blockchain, including transactions, from the genesis block.</p> <p>Our current plan is that Hyl\u00e9 will provide a full archive node.</p>"},{"location":"about/data-availability/#proving-past-blocks","title":"Proving past blocks","text":"<p>Ethereum provides no native way to easily verify whether a given block belongs to the chain. This prevents leveraging historical data in smart contracts.</p> <p>Hyl\u00e9 blocks will, in the long term, contain the root of a merkle-mountain-range of all past blocks, allowing the generation of inclusion proofs of past blocks.</p>"},{"location":"about/supported-proving-schemes/","title":"Supported proving schemes","text":"<p>This is the list of zero-knowledge proving schemes currently supported by Hyl\u00e9.</p> <p>We plan to support all major proving schemes.</p> <p>Supported:</p> <ul> <li>Risc Zero</li> <li>Groth16 (using gnark and BN254)</li> </ul> <p>Upcoming:</p> <ul> <li>Cairo</li> <li>Starknet OS</li> <li>SP1</li> <li>PlonK</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to the Getting Started guide for Hyl\u00e9. This page will help you configure your environment and start using Hyl\u00e9.</p> <p>Use the sidebar to navigate through the guide, or click on the links below to jump to a specific section:</p> <ol> <li>Install the CLI</li> <li>Connect to the public devnet</li> <li>Create your first smart contract<ol> <li>Get inspiration from our in-depth Collatz example</li> </ol> </li> </ol>"},{"location":"getting-started/collatz-example-in-depth/","title":"Collatz example in depth","text":"<p>Hyl\u00e9 smart contracts can be written in any language that targets one of our supported proving schemes. To provide a simple example, we'll use the RISC Zero Collatz Conjecture program, which can be found here.</p> <p>The Collatz Conjecture is a simple mathematical problem that can be expressed as a program. The conjecture states that, for any positive integer <code>n</code>:</p> <ul> <li>if <code>n</code> is even, divide it by 2</li> <li>if <code>n</code> is odd, multiply it by 3 and add 1</li> <li>repeat this process, and you will eventually reach 1.</li> </ul> <p>The program is implemented in rust, and compiles to the RISC Zero ZkVM.</p>"},{"location":"getting-started/collatz-example-in-depth/#compiling-the-program","title":"Compiling the program","text":"<p>To compile the program, you will need to have the RISC Zero toolchain installed. Follow the official instructions to get the most up-to-date information.</p> <p>Once that is done, you should be able to run <code>cargo build</code>.</p>"},{"location":"getting-started/collatz-example-in-depth/#running-the-collatz-conjecture-program","title":"Running the Collatz Conjecture program","text":"<p>Hyl\u00e9 smart contracts can be executed client-side, enabling strong decentralisation and permissionlessness. Executing the smart contract is thus as simple as running the program with the correct inputs.</p> <pre><code># Compute a proof of a transition between the number 12 and 6\ncargo run next 12\n\n# Compute a proof of a transition between the number 17 and 52\ncargo run next 17\n\n# Compute a proof where the state of the contract is assumed to be 1, and the state should be reset to 31\ncargo run reset 31\n</code></pre> <p>Every time, a <code>proof.json</code> file containing the receipt will be generated. You can use this proof, along with the inputs, to trigger state transitions on Hyl\u00e9 (see Your first smart contract for more details).</p>"},{"location":"getting-started/collatz-example-in-depth/#invalid-transitions","title":"Invalid transitions","text":"<p>The Collatz smart contract demonstrates how the code of the smart contract enforces constraints on the state. For example, you cannot generate valid proofs of transition between numbers that are not part of the Collatz sequence. The contract will also reject attempts to reset to 0, as there would no longer be any next state.</p>"},{"location":"getting-started/connect-to-devnet/","title":"Connect to the public devnet","text":"<p>Hyl\u00e9 provides a public devnet where you can test your applications.</p> <p>Note</p> <p>We currently make no guarantees on the public devnet stability. It can be reset at any time. We will keep this page updated with the latest information.</p>"},{"location":"getting-started/connect-to-devnet/#create-your-wallet-on-our-public-devnet","title":"Create your wallet on our public devnet","text":""},{"location":"getting-started/connect-to-devnet/#configure-your-environment","title":"Configure your environment","text":"<pre><code># This script automatically sets up the devnet configuration\n./scripts/configure.sh\n# Create yourprivate key, you can name it however you want\n./hyled keys add my-key\nexport ADDRESS=$(./hyled keys show my-key -a) # for convenience\n</code></pre>"},{"location":"getting-started/connect-to-devnet/#claim-hyle-tokens-on-the-faucet-with-your-newly-created-address","title":"Claim HYLE tokens on the faucet with your newly created address","text":"<pre><code>curl --header \"Content-Type: application/json\" \\\n  --request POST \\\n  --data \"{\\\"denom\\\":\\\"hyle\\\",\\\"address\\\":\\\"$ADDRESS\\\"}\" \\\n  https://faucet.devnet.hyle.eu/credit\n</code></pre>"},{"location":"getting-started/connect-to-devnet/#check-your-balance","title":"Check your balance","text":"<p><pre><code>./hyled query bank balance $ADDRESS hyle\n</code></pre> You can also visit <code>https://explorer.hyle.eu/hyle/account/$ADDRESS</code></p>"},{"location":"getting-started/connect-to-devnet/#urls","title":"URLs","text":"<ul> <li>Explorer: https://explorer.hyle.eu/ </li> <li>Faucet: https://faucet.devnet.hyle.eu/ </li> <li>REST: https://api.devnet.hyle.eu/ </li> <li>RPC: https://rpc.devnet.hyle.eu/ </li> <li>CometBFT: https://cometbft.devnet.hyle.eu/ </li> </ul>"},{"location":"getting-started/hyled-install-instructions/","title":"CLI Installation instructions","text":"<p>The simplest way to interact with Hyl\u00e9 is using <code>hyled</code>, the cosmos-SDK powered CLI.</p> <p>Clone the Hyl\u00e9 repository and install it.</p>"},{"location":"getting-started/hyled-install-instructions/#mac-linux-windows-with-wsl","title":"Mac, Linux, Windows with WSL","text":"<p>You will need to have installed <code>make</code> and <code>go</code>, v1.20 and above, on your system.</p> <p>Here are the commands: <pre><code>git clone https://github.com/Hyle-org/hyle.git\ncd hyle\nmake build # or make install\n</code></pre></p> <p>You can then get a list of commands with <code>hyled help</code>.</p>"},{"location":"getting-started/hyled-install-instructions/#running-a-devnet","title":"Running a devnet","text":"<p>Run:</p> <pre><code>make init # This resets the blockchain data\n./hyled start\n</code></pre> <p>Your node should start from block 0. Note that it persists data in a folder named <code>hyled-data</code> in the current working directory by default.</p>"},{"location":"getting-started/your-first-smart-contract/","title":"Your first smart contract","text":"<p>Our public devnet is now live!</p> <p>Warning</p> <p>The Hyl\u00e9 API is currently a basic proof of concept. Everything here will change and improve.</p>"},{"location":"getting-started/your-first-smart-contract/#coding-your-smart-contract","title":"Coding your smart contract","text":"<p>You can use any zkVM or proving scheme supported by Hyl\u00e9.</p> <p>For this example, we'll assume you're using the RISC Zero Collatz Conjecture program, which can be found here. See the Collatz example in depth page for more details.</p>"},{"location":"getting-started/your-first-smart-contract/#installing-the-hyle-cli-tool","title":"Installing the Hyl\u00e9 CLI tool","text":"<p>The simplest way to interact with Hyl\u00e9 is using <code>hyled</code>, the cosmos-SDK powered CLI. Follow the installation instructions.</p>"},{"location":"getting-started/your-first-smart-contract/#registering-your-smart-contract","title":"Registering your smart contract","text":"<p>Hyl\u00e9 smart contracts are made of:</p> <ul> <li>a Name, which must be unique</li> <li>a tuple of (verifier, program_id) which identifies the smart contract. The <code>verifier</code> is the proof system (currently either \"risczero\" or \"gnark-groth16-te-BN254\"), and the <code>program_id</code> is the unique identifier of the program in that proof system, either the image ID in risczero of the verifying key in groth16 circuits.</li> <li>a state digest, holding the current state commitment of the contract. This can be any type of state commitment you want, and can currently be any size you want (this will have fee implications in the future).</li> </ul> <p>To register a contract on-chain, run the following command:</p> <pre><code># Owner is the address of the contract owner, which must match the transaction signer for now.\nhyled tx zktx register [owner] [contract_name] [verifier] [program_id] [state_digest]\n</code></pre> <p>In the case of the Collatz Conjecture program, as RISC Zero programs are identified by their image ID, without a prefix, we use the number <code>0xb48e70c79688b41fc8f0daf8370d1ddb3f44ada934c10c6e0b0f5915102a363b</code>. This will change every time the contract logic is modified. The initial state is set to \"1\", so that it can be reset to any number. This is encoded in base 64 as <code>AAAAAQ==</code> (because of the rust library used to decode the state).</p> <p>NB: this might fail on the public devnet, as the contract name might already exist - try a different name in that case.</p> <pre><code># Replace $OWNER with your address\nhyled tx zktx register $OWNER collatz risczero b48e70c79688b41fc8f0daf8370d1ddb3f44ada934c10c6e0b0f5915102a363b AAAAAQ==\n</code></pre> <p>You can check on Hyl\u00e9's explorer to see your transaction: <code>https://explorer.Hyl\u00e9.eu/Hyl\u00e9/tx/$TXHASH</code> </p> <p>Your contract state is visible at: <code>https://explorer.Hyl\u00e9.eu/Hyl\u00e9/cosmwasm/0/transactions?contract=$CONTRACT_NAME</code></p>"},{"location":"getting-started/your-first-smart-contract/#interacting-with-hyle","title":"Interacting with Hyl\u00e9","text":""},{"location":"getting-started/your-first-smart-contract/#stateful-transactions","title":"Stateful transactions","text":"<p>Once your contract has been registered, you can send valid proofs of state transition to permissionlessly update the state of the smart contract. Hyl\u00e9 requires some specific variables in the output of the proof to process the transaction, namely:</p> <ul> <li>the initial state</li> <li>the next state</li> </ul> <p>This will change in the future to include caller address, block timestamp, etc. Other components can also be added, those will not be used by the Hyl\u00e9 protocol but will be provided as part of our DA. For private computations, you can simply provide a proof of state commitment transitions.</p> <pre><code># Signer is the address of the transaction signer.\nhyled tx zktx execute [contract_name] [receipt] [initial_state] [final_state] [signer]\n</code></pre> <p>In the case of the Collatz Conjecture program, we can for example generate a proof of state transition from 1 to 24, and send it to the contract.</p> <pre><code># Generate the proof in 'collatz-contract'\ncargo run reset 24\ncd ../hyle\n\n# Make sure the name matches the contract you registered\nhyled tx zktx execute collatz ../collatz-contract/proof.json AAAAAQ== AAAAGA== $OWNER\n</code></pre> <p>You can then check that the contract was updated onchain by running the command below or checking in the explorer directly.</p> <pre><code>hyled query zktx contract collatz\n</code></pre>"},{"location":"getting-started/your-first-smart-contract/#stateless-transactions-verification-only","title":"Stateless transactions / Verification only","text":"<p>Hyl\u00e9 supports verification of transactions without state changes. This can be used either to aggregate proofs, or to do other coputations out-of-band or off-chain using the Hyl\u00e9 DA. The format is similar to stateful transactions, and you still need a registered contract, but there is no need to provide the initial and final state. <pre><code># Signer is the address of the transaction signer.\nhyled tx zktx verify [contract_name] [receipt] [signer]\n</code></pre></p>"},{"location":"use-cases/","title":"Use cases","text":"<p>Note</p> <p>This whole section is very much under construction. Coming soon!</p> <p>The Use cases section of the Hyl\u00e9 documentation shows how to use Hyl\u00e9 in different scenarios.</p> <ul> <li>Hyl\u00e9 for ZKApps </li> <li>Hyl\u00e9 for identity providers &amp; wallets</li> <li>Hyl\u00e9 for RAAS &amp; ZK Coprocessors (coming soon)</li> <li>...</li> </ul>"},{"location":"use-cases/for-identity-providers/","title":"Hyl\u00e9 for Identity Providers","text":"<p>Hyl\u00e9 does not specify what an \"account\" is, or even what identity particularly means. This gives it unprecedented flexibility in handling identity, including: - EOAs like Ethereum native wallets - Smart accounts of any kind - Regular web2 identity - Passports &amp; other national identity documents.</p> <p>Warning</p> <p>You are entering TODO area, none of this is currently implemented.</p> <p>Hyl\u00e9 handles identity relying on the caller contract in a multicall.</p> <p>When a user crafts a transaction, their first call should be a proof-of-identity, for example a call to the native <code>/eth</code> smart contract, which validates Ethereum-like EOA signatures.</p> <p>Any subsequent call will see that the user is indeed the owner of an <code>/eth</code> address, e.g. <code>0xfoobar/eth</code> and will be able to use that address name trustlessly.</p>"},{"location":"use-cases/for-identity-providers/#registering-your-own-stateless-identity-provider","title":"Registering your own stateless identity provider","text":"<p>A stateless identity provider such as the Ethereum EOA smart contract has two components: - A smart contract registered on Hyl\u00e9, authenticating proofs - A client-side library that can craft proofs</p> <p>See the Ethereum EOA smart contract for an example of such a provider.</p>"},{"location":"use-cases/for-identity-providers/#adding-support-for-your-smart-wallet","title":"Adding support for your smart wallet","text":""},{"location":"use-cases/for-identity-providers/#registering-a-stateful-private-identity-provider","title":"Registering a stateful, private identity provider","text":"<p>This can be used by games, SSO providers, or any other use-case that needs to handle user identity in a more traditional way.</p>"},{"location":"use-cases/for-zk-apps/","title":"Hyl\u00e9 for ZKApps","text":"<p>Hyl\u00e9 is a full featured settlement layer, providing fast finality and cheap TX cost. This makes it a great fit for use-cases that would require appchains or L3s in other ecosystems.</p>"},{"location":"use-cases/for-zk-apps/#registering-your-smart-contract","title":"Registering your smart contract","text":"<p>See Your First Smart Contract for details.</p>"},{"location":"use-cases/for-zk-apps/#bring-your-own-accounts","title":"Bring your own accounts","text":"<p>See Hyl\u00e9 for Identity Providers</p>"}]}