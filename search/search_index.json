{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Hyl\u00e9 developer docs","text":"<p>!!! note     This developer portal and the project itself are still in early development. See below on how to reach out to us if you need anything that isn't here.</p> <p>Hyl\u00e9 is your minimal layer one, focused only on verifying zero-knowledge proofs.</p> <p>By sending a simple proof to be verified on Hyl\u00e9, you can build a fully off-chain application powered by ZKPs that still has the security guarantees of the blockchain.</p> <ul> <li>Hyl\u00e9 only verifies zero-knowledge proofs: settlement is all you need.</li> <li>Hyl\u00e9 uses minimal storage: we only store the source of truth and our nodes are very light.</li> <li>Hyl\u00e9 is modular by design, for full flexibility.</li> <li>Hyl\u00e9 does not reinvent the wheel: we leverage existing tech stacks (Cairo, Risc0, SP1, etc.)</li> </ul> <p></p> <p>For more information, check out our website.</p>"},{"location":"#getting-started","title":"Getting started","text":"<ol> <li>Check out how to install the CLI</li> <li>Connect to our public devnet</li> <li>Learn how to create your first smart contract</li> </ol>"},{"location":"#our-use-cases","title":"Our use cases","text":"<ul> <li>Hyl\u00e9 for ZKApps </li> <li>Hyl\u00e9 for identity providers &amp; wallets</li> <li>Hyl\u00e9 for RAAS &amp; ZK Coprocessors (coming soon)</li> <li>...</li> </ul>"},{"location":"#useful-links","title":"Useful links","text":"<ul> <li>Main repository (cosmos SDK app)</li> <li>Hyle.eu</li> <li>Hyl\u00e9 blog</li> </ul>"},{"location":"#contact-us","title":"Contact us","text":"<p>Feel free to reach out to the team for more information:  </p> <ul> <li> Github: @hyle_org</li> <li> Twitter: @hyle_org</li> <li> Farcaster: @hyle-org</li> <li> LinkedIn: Hyl\u00e9</li> <li> Youtube: @Hyl\u00e9</li> <li> Telegram: @hyle_org</li> </ul>"},{"location":"developers/","title":"Developer documentation","text":"<p>Welcome to the developer documentation for Hyl\u00e9. In this section you will find all the information you need to start developing on Hyl\u00e9, as well as general information about the project.</p> <p>The general technical details are in the General documentation.</p>"},{"location":"developers/examples/","title":"Detailed examples","text":"<p>Here, we show a few detailed examples of Hyl\u00e9 applications.</p> <ul> <li>Vibe Check</li> </ul> <p>Soon, you'll also be able to follow our blog for more use cases!</p> <p>You should also check out our partners.</p>"},{"location":"developers/examples/collatz-example-in-depth/","title":"Collatz example in depth","text":"<p>Hyl\u00e9 smart contracts can be written in any language that targets one of our supported proving schemes. To provide a simple example, we'll use the RISC Zero Collatz Conjecture program, which can be found here.</p> <p>The Collatz Conjecture is a simple mathematical problem that can be expressed as a program. The conjecture states that, for any positive integer <code>n</code>:</p> <ul> <li>if <code>n</code> is even, divide it by 2</li> <li>if <code>n</code> is odd, multiply it by 3 and add 1</li> <li>repeat this process, and you will eventually reach 1.</li> </ul> <p>The program is implemented in rust, and compiles to the RISC Zero ZkVM.</p>"},{"location":"developers/examples/collatz-example-in-depth/#compiling-the-program","title":"Compiling the program","text":"<p>To compile the program, you will need to have the RISC Zero toolchain installed. Follow the official instructions to get the most up-to-date information.</p> <p>Once that is done, you should be able to run <code>cargo build</code>.</p>"},{"location":"developers/examples/collatz-example-in-depth/#running-the-collatz-conjecture-program","title":"Running the Collatz Conjecture program","text":"<p>Hyl\u00e9 smart contracts can be executed client-side, enabling strong decentralisation and permissionlessness. Executing the smart contract is thus as simple as running the program with the correct inputs.</p> <pre><code># Compute a proof of a transition between the number 12 and 6\ncargo run next 12\n\n# Compute a proof of a transition between the number 17 and 52\ncargo run next 17\n\n# Compute a proof where the state of the contract is assumed to be 1, and the state should be reset to 31\ncargo run reset 31\n</code></pre> <p>Every time, a <code>proof.json</code> file containing the receipt will be generated. You can use this proof, along with the inputs, to trigger state transitions on Hyl\u00e9 (see Your first smart contract for more details).</p>"},{"location":"developers/examples/collatz-example-in-depth/#invalid-transitions","title":"Invalid transitions","text":"<p>The Collatz smart contract demonstrates how the code of the smart contract enforces constraints on the state. For example, you cannot generate valid proofs of transition between numbers that are not part of the Collatz sequence. The contract will also reject attempts to reset to 0, as there would no longer be any next state.</p>"},{"location":"developers/examples/vibe-check/","title":"Vibe Check","text":"<p>The general idea of the Vibe Check app is to give people a SmileToken to reward them for smiling. </p> <p>Watch Sylve's demo at ETHCC[7].</p> <p>Find the code in the dedicated GitHub repository.</p>"},{"location":"developers/examples/vibe-check/#context","title":"Context","text":"<p>The step-by-step process:</p> <ol> <li>I identify myself.<ol> <li>I use WebAuthn, with a Yubikey on a computer, a fingerprint on a phone, or any other accepted device.</li> <li>Vibe Check runs the Noir prover in-browser.</li> <li>The prover generates a Noir proof that the webauthn-signature is correct.</li> </ol> </li> <li>I take a selfie where I\u2019m smiling to generate a proof of my shiny, bubbly personality.<ol> <li>Vibe Check uses a machine-learning model that the Hyl\u00e9 team has transformed into a Cairo program using Giza's transpiler.</li> <li>I send my selfie to this Cairo program, which runs on a virtual machine.</li> <li>The machine-learning model checks that I am smiling.</li> <li>If I am smiling, the Cairo-prover generates a proof.</li> </ol> </li> <li>Vibe Check gives me a SmileToken.<ol> <li>Vibe Check locally updates the state of the SmileToken.</li> <li>Vibe Check generates a Cairo proof that the state transition was done correctly.</li> </ol> </li> <li>Hyl\u00e9 verifies the proofs.<ol> <li>Hyl\u00e9 updates the SmileToken state if everything is correct. If so, I am rewarded with that SmileToken to congratulate me for my good vibes.</li> <li>Since Hyl\u00e9\u2019s state is checkpointed on different networks, I could get that token on any bridged network like Starknet or even Ethereum.</li> </ol> </li> </ol>"},{"location":"developers/examples/vibe-check/#how-it-works","title":"How it works","text":""},{"location":"developers/examples/vibe-check/#understanding-the-components-of-the-demo","title":"Understanding the components of the demo","text":"<p>The Vibe Check demo consists of three components: the app, the proof generators, and the Hyl\u00e9 node.</p> <p>The app helps the user craft a transaction through 2 interactions:</p> <ul> <li>Identification with WebAuthn for a proof of ID</li> <li>Photo of the user smiling for a proof of smile</li> </ul> <p>The app sends these inputs to the proof generators.</p> <p>The proof generators execute programs and generate proofs.</p> <p>They can be run locally in the browser or remotely to maximize performance. Local proof generation is possible by compiling the Cairo VM/Cairo Prover/Noir Prover into WASM, but it is inefficient. Proving is a memory-consuming activity, and browsers usually have a low limit.</p> <p>The proof generators generate three proofs:</p> <ol> <li>Proof of ID: verification of the WebAuthn ECDSA signature in Noir</li> <li>Proof of smile: running the machine-learning model in Cairo</li> <li>Token (ERC-20) transfer: initiated in Cairo if the first two proofs are valid.</li> </ol> <p>The app sends the three proofs through one single transaction to the Hyl\u00e9 node.</p> <p>The Hyl\u00e9 node:</p> <ol> <li>Unpacks the three proofs.</li> <li>Verifies each proof with the correct verifier: Noir for WebAuthn and Cairo for the two others.</li> <li>Ensures consistency by checking the public data contained in the proofs to ensure they all relate to the same transaction.</li> </ol> <p></p>"},{"location":"developers/examples/vibe-check/#multiple-proving-schemes","title":"Multiple proving schemes","text":"<p>A proving scheme is a protocol or framework for generating proofs and verifying them.</p> <p>In Vibe Check, we use Noir and Cairo.</p> <p>We use Noir to generate ECDSA proofs. Its Typescript SDK makes it easy to integrate into an app.</p> <p>We use Cairo for two proofs:</p> <ul> <li>That there is a smile on the screenshot</li> <li>The coin transfer, with an ERC-20 specification.</li> </ul> <p>We used the LambdaClass CairoVM. Because of the current dependency mismatches between the prover and the runner, the Cairo prover and the Cairo runner had to be compiled separately.</p>"},{"location":"developers/examples/vibe-check/#using-giza-for-zkml","title":"Using Giza for zkML","text":"<p>ZkML is one of ZK's many use cases. It helps you assert that a prediction's result was obtained with the right model, trained on the right dataset, and fed with the right input.</p> <p>Giza focuses on helping developers create a provable machine-learning model.</p> <p>Here is the flow we followed:</p> <ol> <li>We used a simple classifier from the XGBoost library in Python, which Giza fully supports. </li> <li>We serialized our model in json thanks to the Giza SDK.</li> <li>We used the Giza API to turn our model into a Cairo program.</li> <li>We compiled the Cairo ML into Sierra using <code>scarb</code></li> <li>We executed our model in the Cairo VM we were using.</li> </ol> <p>Deep learning models, especially CNNs, would typically be more appropriate for image recognition, but some primitives used by those are not yet supported. Larger models are also extremely hard to run in a Cairo VM because of their high memory requirements.</p>"},{"location":"developers/examples/vibe-check/#the-actual-code","title":"The actual code","text":"<p>Find the code in the dedicated GitHub repository!</p>"},{"location":"developers/general-doc/","title":"General documentation","text":"<p>Welcome to the developer documentation for Hyl\u00e9.</p> <p>You can also refer to our Getting Started step-by-step guide.</p>"},{"location":"developers/general-doc/anatomy-smart-contracts/","title":"Anatomy of a smart contract","text":"<p>Hyl\u00e9 is a fully programmable blockchain. However, we only store the minimal amount of data required to validate smart contract proofs. Hyl\u00e9 smart contracts are made of a name, a program identifier and a state commitment.</p>"},{"location":"developers/general-doc/anatomy-smart-contracts/#program-identifier","title":"Program Identifier","text":"<p>Smart Contracts in Hyl\u00e9 are identified by a zero knowledge proof scheme and a matching identifier. This tuple is required to verify proofs.</p> <ul> <li>Cairo: Cairo smart contracts will be identified by their Class Hash in the future.</li> <li>Noir: Noir smart contracts are identified by they verifying key.</li> <li>Risc Zero: Risc Zero smart contracts are identified by their <code>image ID</code>. Two identical programs will have identical image IDs.</li> <li>Groth16: Groth16 programs require a trusted ceremony. As such, their identifier is the verifying key corresponding to the matching private key, which will be unique for each program &amp; ceremony.</li> </ul>"},{"location":"developers/general-doc/anatomy-smart-contracts/#state-commitment","title":"State Commitment","text":"<p>The state commitment is intended to be the minimal amount of data required to attest to the full state of the smart contract. Some example of such structures include:</p> <ul> <li>The full state, for a sufficiently small program (e.g. a fibonacci counter, or a smart-contract with a nonce)</li> <li>A merkle root of the state, for larger programs</li> <li>A hash of the full state could also be used</li> </ul>"},{"location":"developers/general-doc/data-availability/","title":"Data Availability","text":"<p>Hyl\u00e9 will provide self-sufficient permissionless data availability, but not necessarily data retrievability.</p>"},{"location":"developers/general-doc/data-availability/#how-hyle-avoids-the-data-availability-problem","title":"How Hyl\u00e9 avoids the data availability problem","text":"<p>Hyl\u00e9 is a layer one blockchain, and will be decentralised in the future. As such, all validators and full nodes must have access to all data required to accept new blocks. There is therefore no data availability problem for Hyl\u00e9 full nodes.</p> <p>They must however access the full proofs inside each block. Thankfully, because our proofs are proofs of state commitment transitions, they are rather lightweight by themselves.</p>"},{"location":"developers/general-doc/data-availability/#light-nodes","title":"Light nodes","text":"<p>There are currently no light nodes in Hyl\u00e9. In the mid- to long-term, blocks generation will become provable: light nodes will be able to rely on the block headers and proof of block, in the same way that full nodes do. There will be essentially no difference between light and full nodes.</p> <p>Note however that the design of the chain is intended to make full nodes as lightweight as possible, so the need for light nodes is not as pressing as it is for other chains.</p>"},{"location":"developers/general-doc/data-availability/#permissionless-da-for-smart-contracts","title":"Permissionless DA for smart contracts","text":"<p>Because the protocol only requires proofs of the transitions between state commitments, the full state-diff may be hidden. This is by design and enables privacy. </p> <p>For smart contracts that intend to be permissionless, this can lead to DOS. In this case, the program must force the proof to contain the full state-diff.</p> <p>If the proof contains the full state-diff, valid transactions sent to Hyl\u00e9 contain it too and external indexers are able to reconstruct the full state.</p> <p>This solves the data availability problem, assuming that transaction data is available long enough for any honest indexer to reconstruct the full state. </p> <p>This is a rather weak assumption  and our plan is to provide between 7 and 28 days of guaranteed DA, like Ethereum blobs.  </p>"},{"location":"developers/general-doc/data-availability/#data-retrievability","title":"Data retrievability","text":"<p>Historical data is not provided by the protocol, as it is unnecessary to create new blocks. </p> <p>Starting a new node from scratch or reading past transactions for events may still be useful at times. To that end, Hyl\u00e9 nodes can be archive nodes which store the full state of the blockchain, including transactions, from the genesis block.</p> <p>Our current plan is that Hyl\u00e9 will provide a full archive node.</p>"},{"location":"developers/general-doc/data-availability/#proving-past-blocks","title":"Proving past blocks","text":"<p>Ethereum provides no native way to easily verify whether a given block belongs to the chain. This prevents leveraging historical data in smart contracts.</p> <p>Hyl\u00e9 blocks will, in the long term, contain the root of a merkle-mountain-range of all past blocks, allowing the generation of inclusion proofs of past blocks.</p>"},{"location":"developers/general-doc/smart-contract-abi/","title":"Smart Contract ABI","text":"<p>Hyl\u00e9 focuses on verifying zk-proofs. Because of this, writing smart contracts on Hyl\u00e9 has some specificities, with other elements being the same as with most other blockchains.</p> <p>Depending on the type of zk-proof circuits you use, there are some superficial differences, but the overall idea is that all inputs are known at proof generation time. This includes unusual elements such as the origin of the transaction (<code>tx.origin</code> in Ethereum) and the block number.</p> <p>The Hyl\u00e9 protocol enforces several invariants on transactions to maximize security. For this reason, we must specify some of the data within a zero-knowledge proof.</p> <p>This page uses the Rust structures to demonstrate, but you can use the following repos for other languages:</p> <ul> <li>Rust example: https://github.com/Hyle-org/collatz-conjecture</li> <li>Gnark / Groth16 example (currently outdated): https://github.com/Hyle-org/groth16-example</li> </ul>"},{"location":"developers/general-doc/smart-contract-abi/#overview","title":"Overview","text":"<p>Here is the rust struct specifying the output of a Hyl\u00e9 smart contract:</p> <pre><code>pub struct HyleOutput&lt;T&gt; {\n    pub version: u32,\n    pub initial_state: Vec&lt;u8&gt;,\n    pub next_state: Vec&lt;u8&gt;,\n    pub identity: String,\n    pub tx_hash: Vec&lt;u8&gt;,\n    pub payload_hash: Vec&lt;u8&gt;,\n    pub success: bool,\n    pub program_outputs: T\n}\n</code></pre> <p>The <code>version</code> field should currently be set to 1.</p>"},{"location":"developers/general-doc/smart-contract-abi/#initial-state-and-next-state","title":"Initial State and Next State","text":"<p>Blockchains transactions are fundamentally state transitions. These fields handle the state transitions securely in the protocol.</p> <p>The <code>initial_state</code> field should match the state digest of the contract before the transaction. This could consist of several things, such as:</p> <ul> <li>the hash of the previous state</li> <li>the Merkle root of the previous state tree</li> <li>the state itself if it's small enough</li> </ul> <p>The protocol enforces that this <code>initial_state</code> matches the onchain <code>state_digest</code> it knows. Otherwise, the state transition is invalid.</p> <p>The <code>next_state</code> field represents the new onchain <code>state_digest</code> after the transaction.</p> <p>Smart contracts can adapt the actual structure of this field. In the future, fees will depend on the size of the <code>state_digest</code> (among other criteria), so we encourage you to keep it small.</p>"},{"location":"developers/general-doc/smart-contract-abi/#identity","title":"Identity","text":"<p>The <code>identity</code> field is the identifier of the person who initiated the transaction.</p> <p>Unlike other blockchains, Hyl\u00e9 does not have a native signature type. Instead, Hyl\u00e9 uses the <code>identity</code> field of the first proof to identify the TX sender. To ensure security, the field is composite and ends with the name of the contract that the proof was generated for.</p> <p>Hyl\u00e9 could for example support Ethereum EOAs, if a smart contract is registered onchain to verify them. The <code>identity</code> would then look something like <code>0x1234...5678.eth_eoa</code>, where <code>eth_eoa</code> is the name of the contract, and the first part matches a regular Ethereum address.</p> <p>This gives us massive flexibility in the future to support any kind of identity verification, including WebAuthn, social media accounts, etc.</p> <p>!!! note For now, any subsequent proof in a TX must declare the same <code>identity</code> or an empty one, or the transaction will be rejected.</p>"},{"location":"developers/general-doc/smart-contract-abi/#tx-hash","title":"TX Hash","text":"<p>The <code>tx_hash</code> field is intended to hash transaction data, preventing replay attacks and providing a means for contracts to access this information.</p> <p>The field is currently completely unspecified and isn't validated by the protocol.</p>"},{"location":"developers/general-doc/smart-contract-abi/#payload-hash","title":"Payload Hash","text":"<p>This should match the hash of the payload that was sent to the network initially. Currently we use pedersen hashing for Cairo, no hashing for Risc0. Others are unimplemented. This is very WIP (as of August 2024) and will change soon.</p>"},{"location":"developers/general-doc/smart-contract-abi/#success","title":"Success","text":"<p>This is a boolean - whether the proof is for a succesful proof or a failure case. It can be useful to prove that a transaction is invalid. See our example in Vibe Check.</p>"},{"location":"developers/general-doc/smart-contract-abi/#other-program-specific-outputs","title":"Other program-specific outputs","text":"<p>Smart contracts can provide other outputs as part of the proof they generate.</p> <p>This can be used for a variety of purposes, but mostly serves to provide Data Availability. See Data Availability for more information.</p>"},{"location":"developers/general-doc/smart-contract-abi/#events","title":"Events","text":"<p>Hyl\u00e9 does not currently ship native events. We are looking into implementing them in the near future.</p>"},{"location":"developers/hyleou/","title":"Hyl\u00e9ou - blockchain explorer for Hyl\u00e9","text":"<p>Hyl\u00e9ou (a French pun for \"Il est o\u00f9\" or \"where are they?\") is a blockchain explorer for Hyl\u00e9. It is a web application that allows users to explore the blockchain, view transactions, and interact with the network.</p> <p>The project is live at hyleou.hyle.eu. The repository can be found on github. We are open to PRs and issues !</p>"},{"location":"developers/hyleou/#features","title":"Features","text":"<p>All features are curently very WIP.</p> <ul> <li>View the latest blocks and transactions</li> <li>View detailed information about blocks and transactions</li> <li>Register new contracts</li> <li>Send transactions by uploading ZK proofs to specific contracts (multicall not yet supported)</li> </ul>"},{"location":"developers/using-the-cli/","title":"Getting Started","text":"<p>Welcome to the Getting Started guide for Hyl\u00e9. This page will help you configure your environment and start using Hyl\u00e9.</p> <p>Use the sidebar to navigate through the guide, or click on the links below to jump to a specific section:</p> <ol> <li>Install the CLI</li> <li>Connect to the public devnet</li> <li>Create your first smart contract<ol> <li>Get inspiration from our in-depth Collatz example</li> <li>Understand Hyl\u00e9's smart contract ABI</li> </ol> </li> </ol>"},{"location":"developers/using-the-cli/connect-to-devnet/","title":"Connect to the public devnet","text":"<p>Hyl\u00e9 provides a public devnet where you can test your applications.</p> <p>!!!note We currently make no guarantees on the public devnet stability. It can be reset at any time. We will keep this page updated with the latest information.</p>"},{"location":"developers/using-the-cli/connect-to-devnet/#create-your-wallet-on-our-public-devnet","title":"Create your wallet on our public devnet","text":""},{"location":"developers/using-the-cli/connect-to-devnet/#configure-your-environment","title":"Configure your environment","text":"<pre><code># This script automatically sets up the devnet configuration\n./scripts/configure.sh\n# Create yourprivate key, you can name it however you want\n./hyled keys add my-key\n</code></pre>"},{"location":"developers/using-the-cli/connect-to-devnet/#urls","title":"URLs","text":"<ul> <li>Explorer: https://hyleou.hyle.eu/</li> <li>REST: https://api.devnet.hyle.eu/</li> <li>RPC: https://rpc.devnet.hyle.eu/</li> <li>CometBFT: https://cometbft.devnet.hyle.eu/</li> </ul>"},{"location":"developers/using-the-cli/hyled-install-instructions/","title":"CLI Installation instructions","text":"<p>Hyl\u00e9 is currently using the Cosmos SDK as a base, and the CLI provides both a way to interact with the chain, and a way to start the devnet.</p> <p>Clone the Hyl\u00e9 repository and install it.</p>"},{"location":"developers/using-the-cli/hyled-install-instructions/#mac-linux-windows-with-wsl","title":"Mac, Linux, Windows with WSL","text":"<p>You will need to have installed <code>make</code> and <code>go</code>, v1.20 and above, on your system.</p> <p>Here are the commands:</p> <pre><code>git clone https://github.com/Hyle-org/hyle.git\ncd hyle\nmake build # or make install\n</code></pre> <p>You can then get a list of commands with <code>hyled help</code>.</p>"},{"location":"developers/using-the-cli/hyled-install-instructions/#setting-up-the-cli","title":"Setting up the CLI","text":"<p>Running the following command will setup your CLI and reset the local blockchain data if any.</p> <pre><code>make init\n</code></pre>"},{"location":"developers/using-the-cli/hyled-install-instructions/#running-a-devnet","title":"Running a devnet","text":"<p>Run:</p> <pre><code>./hyled start\n</code></pre> <p>Your node should start from block 0. Note that it persists data in a folder named <code>hyled-data</code> in the current working directory by default.</p>"},{"location":"developers/using-the-cli/your-first-smart-contract/","title":"Your first smart contract","text":"<p>Our public devnet is now live!</p> <p>!!! warning The Hyl\u00e9 API is currently a basic proof of concept. Everything here will change and improve.</p>"},{"location":"developers/using-the-cli/your-first-smart-contract/#coding-your-smart-contract","title":"Coding your smart contract","text":"<p>You can use any zkVM or proving scheme supported by Hyl\u00e9.</p> <p>For this example, we'll assume you're using the RISC Zero Collatz Conjecture program, which can be found here. See the Collatz example in depth page for more details.</p>"},{"location":"developers/using-the-cli/your-first-smart-contract/#installing-the-hyle-cli-tool","title":"Installing the Hyl\u00e9 CLI tool","text":"<p>In this example, we'll show you how to use the CLI to register and interact with your smart contract. It's likely easier and faster to use our explorer, Hyl\u00e9ou.</p> <p>To begin, follow the CLI installation instructions.</p>"},{"location":"developers/using-the-cli/your-first-smart-contract/#registering-your-smart-contract","title":"Registering your smart contract","text":"<p>Hyl\u00e9 smart contracts are made of:</p> <ul> <li>a Name, which must be unique</li> <li>a tuple of (verifier, program_id) which identifies the smart contract. The <code>verifier</code> is the proof system (e.g. \"risczero\" or \"gnark-groth16-te-BN254\"), and the <code>program_id</code> is the unique identifier of the program in that proof system, either the image ID in risczero of the verifying key in groth16 circuits.</li> <li>a state digest, holding the current state commitment of the contract. This can be any type of state commitment you want, and can currently be any size you want (this will have fee implications in the future).</li> </ul> <p>To register a contract on-chain, run the following command:</p> <pre><code># Owner is currently unused, but could be used in the future to manage contract permissions\nhyled tx zktx register [owner] [verifier] [program_id] [contract_name] [state_digest]\n</code></pre> <p>In the case of the Collatz Conjecture program, as RISC Zero programs are identified by their image ID, without a prefix, we use the number <code>0xb48e70c79688b41fc8f0daf8370d1ddb3f44ada934c10c6e0b0f5915102a363b</code>. This will change every time the contract logic is modified. The initial state is set to \"1\", so that it can be reset to any number. This is encoded in base 64 as <code>AAAAAQ==</code> (because of the rust library used to decode the state).</p> <p>NB: this might fail on the public devnet, as the contract name might already exist - try a different name in that case.</p> <pre><code># Using \"default\" as an owner for now, but you cna put anything you like\nhyled tx zktx register default risczero b48e70c79688b41fc8f0daf8370d1ddb3f44ada934c10c6e0b0f5915102a363b collatz AAAAAQ==\n</code></pre> <p>You can check on Hyl\u00e9's explorer to see your transaction: <code>https://hyleou.hyle.eu/transaction/$TX_HASH</code></p> <p>Your contract state is visible at: <code>https://hyleou.hyle.eu/contract/$CONTRACT_NAME</code></p>"},{"location":"developers/using-the-cli/your-first-smart-contract/#interacting-with-hyle","title":"Interacting with Hyl\u00e9","text":""},{"location":"developers/using-the-cli/your-first-smart-contract/#publishing-payloads","title":"Publishing payloads","text":"<p>Hyl\u00e9 transactions are settled in two steps. First - you send the payloads of your transaction to the network. These are application-specific data and will depend on how the contract is implemented. In the case of the Collatz Conjecture program, this is a number encoded as a big-endian 32-bit integer.</p> <pre><code># Generate the proof in 'collatz-contract' - this will output the \"payload hash\" you must use.\ncargo run reset 5\n\nhyled tx zktx publish \"\" collatz AAAABQ== # the \"\" is a placeholder for identity - Collatz doesn't handle identity so this is empty.\n</code></pre> <p>You should then be able to check your transaction on Hyl\u00e9ou. At this point, your transaction has been sequenced, but not settled.</p>"},{"location":"developers/using-the-cli/your-first-smart-contract/#posting-proofs-of-your-payload-to-settle-it","title":"Posting proofs of your payload to settle it.","text":"<p>Hyl\u00e9 requires some specific variables in the output of the proof to process the transaction. Check the smart contract ABI for more details.</p> <p>Once your program conforms to the ABI, you can simply generate proofs and send them to Hyl\u00e9. Each payload of a transaction must be proven separately (for now), so you need to specify the index of the payload you're proving.</p> <pre><code>hyled tx zktx prove [tx_hash] [payload_index] [contract_name] [proof]\n</code></pre> <p>In the case of the Collatz Conjecture program, we can now prove our state transition from 1 to 5.</p> <pre><code># Make sure the name matches the contract you registered\nhyled tx zktx prove [tx_hash] 0 collatz [path_to_proof]\n</code></pre> <p>At this point, your transaction is settled and the state of the contract has been updated. You can then check that the contract was updated onchain by running the command below or checking in the explorer directly.</p> <pre><code>hyled query zktx contract collatz\n</code></pre>"},{"location":"overview/","title":"About Hyl\u00e9","text":"<p>Hyl\u00e9 is your minimal layer one, focused only on verifying zero-knowledge proofs.</p> <p>By sending a simple proof to be verified on Hyl\u00e9, you can build a fully off-chain application powered by ZKPs that still has the security guarantees of the blockchain.</p> <p></p>"},{"location":"overview/#why-hyle","title":"Why Hyl\u00e9?","text":"<ul> <li>Leverage the power of zero-knowledge proofs for maximum trustlessness and privacy</li> <li>Run complex logic in your smart contracts thanks to off-chain execution</li> <li>Lower your storage costs with efficient and trustless storage proofs</li> <li>Enjoy better readability with our native on-chain Name System</li> <li>Freely create transactions composing private and public inputs</li> </ul> <p>You can execute your smart contracts off-chain anywhere you like, on a rollup, on-premise or even client-side.</p> <p>You can store your data securely in your backend, IPFS, Arweave or any other long-term solution: Hyl\u00e9 provides the verifiable source of truth for your end user.</p> <p>You can choose your proving scheme, your language, your prover, and still get instant finality and enhanced security.</p>"},{"location":"overview/#how-does-it-work","title":"How does it work?","text":"<p>Using Hyl\u00e9\u2019s sovereign verification-focused Layer 1, here\u2019s what happens:</p> <ol> <li>No need for a verifier contract: just call the native function.</li> <li>Proof generation: This doesn\u2019t change. Off-chain, the prover generates a zero-knowledge proof of a specific computation.</li> <li>Proof submission: the prover sends the proof and the results of the computation to Hyl\u00e9\u2019s Layer 1 as part of a transaction.</li> <li>Verification: Hyl\u00e9 validators receive the transaction. They use the native verification programs to check the validity of the proof as fast as possible, without being limited by the bulky virtual machine.</li> <li>Consensus and block inclusion: if the proof is valid, the block producer puts the results of the computation on the Hyl\u00e9 blockchain.</li> </ol> <p>And that\u2019s it.</p> <p>With this system, execution and storage happen anywhere you like, without cost barriers. You only need a fast and trustworthy verifier: that\u2019s Hyl\u00e9.</p> <p>For more information, check out our website.</p>"},{"location":"resources/","title":"Resources","text":"<p>Coming soon!</p>"},{"location":"resources/find-us/","title":"Useful links","text":"<ul> <li>Main repository (cosmos SDK app)</li> <li>Hyle.eu</li> <li>Hyl\u00e9 blog</li> </ul>"},{"location":"resources/find-us/#contact-us","title":"Contact us","text":"<p>Feel free to reach out to the team for more information:  </p> <ul> <li>X @hyle_org</li> <li>Farcaster @hyle-org</li> <li>Telegram @hyle_org</li> <li>Mail contact@hyle.eu</li> </ul>"},{"location":"roadmap/","title":"Roadmap","text":"<p>This page is under construction. In the meantime, you can check out:</p> <ul> <li>info on our testnet</li> <li>currently supported proving schemes</li> </ul>"},{"location":"roadmap/supported-proving-schemes/","title":"Supported proving schemes","text":"<p>This is the list of zero-knowledge proving schemes currently supported by Hyl\u00e9.</p> <p>We plan to support all major proving schemes.</p> <p>Supported:</p> <ul> <li>RISC Zero</li> <li>Groth16 (over BN254, others can easily be implemented)</li> <li>Cairo via Stark Platinum (partial support)</li> <li>Noir over Barretenberg</li> </ul> <p>Upcoming:</p> <ul> <li>Cairo via Stwo / full Cairo support</li> <li>SP1</li> <li>PlonK</li> </ul>"},{"location":"roadmap/testnet/","title":"Wen testnet ?","text":"<p>Soon\u2122</p> <p>In the meantime, we have a public devnet live, and you can also run your own!</p>"},{"location":"use-cases/","title":"Use cases","text":"<p>!!! note     This whole section is very much under construction. Coming soon!</p> <p>The Use cases section of the Hyl\u00e9 documentation shows how to use Hyl\u00e9 in different scenarios.</p> <ul> <li>Hyl\u00e9 for ZKApps </li> <li>Hyl\u00e9 for identity providers &amp; wallets</li> <li>Hyl\u00e9 for RAAS &amp; ZK Coprocessors (coming soon)</li> <li>...</li> </ul>"},{"location":"use-cases/for-identity-providers/","title":"Hyl\u00e9 for Identity Providers","text":"<p>Hyl\u00e9 does not specify what an \"account\" is, or even what identity particularly means. This gives it unprecedented flexibility in handling identity, including:</p> <ul> <li>EOAs like Ethereum native wallets</li> <li>Smart accounts of any kind</li> <li>Regular web2 identity</li> <li>Passports &amp; other national identity documents.</li> </ul> <p>!!! warning     You are entering TODO area, none of this is currently implemented.</p> <p>Hyl\u00e9 handles identity relying on the caller contract in a multicall.</p> <p>When a user crafts a transaction, their first call should be a proof-of-identity, for example a call to the native <code>/eth</code> smart contract, which validates Ethereum-like EOA signatures.</p> <p>Any subsequent call will see that the user is indeed the owner of an <code>/eth</code> address, e.g. <code>0xfoobar/eth</code> and will be able to use that address name trustlessly.</p>"},{"location":"use-cases/for-identity-providers/#registering-your-own-stateless-identity-provider","title":"Registering your own stateless identity provider","text":"<p>A stateless identity provider such as the Ethereum EOA smart contract has two components:</p> <ul> <li>A smart contract registered on Hyl\u00e9, authenticating proofs</li> <li>A client-side library that can craft proofs</li> </ul> <p>See the Ethereum EOA smart contract for an example of such a provider.</p>"},{"location":"use-cases/for-identity-providers/#adding-support-for-your-smart-wallet","title":"Adding support for your smart wallet","text":""},{"location":"use-cases/for-identity-providers/#registering-a-stateful-private-identity-provider","title":"Registering a stateful, private identity provider","text":"<p>This can be used by games, SSO providers, or any other use-case that needs to handle user identity in a more traditional way.</p>"},{"location":"use-cases/for-zk-apps/","title":"Hyl\u00e9 for ZKApps","text":"<p>Hyl\u00e9 is a full featured settlement layer, providing fast finality and cheap TX cost. This makes it a great fit for use-cases that would require appchains or L3s in other ecosystems.</p>"},{"location":"use-cases/for-zk-apps/#registering-your-smart-contract","title":"Registering your smart contract","text":"<p>See Your First Smart Contract for details.</p>"},{"location":"use-cases/for-zk-apps/#bring-your-own-accounts","title":"Bring your own accounts","text":"<p>See Hyl\u00e9 for Identity Providers</p>"}]}