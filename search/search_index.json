{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#home","title":"Home","text":"<p>Hyl\u00e9 is the new-generation base layer for the era of unchained applications.</p>"},{"location":"#navigation","title":"Navigation","text":"<ul> <li> <p> Introduction</p> <p>A quick overview of Hyl\u00e9, the base layer for unchained apps.</p> <p> Introduction</p> </li> <li> <p> Quickstart</p> <p>Get started with Hyl\u00e9 in just a few minutes with a step-by-step annotated quickstart.</p> <p> Quickstart</p> </li> <li> <p> Concepts</p> <p>Hyl\u00e9-specific concepts and Hyl\u00e9's spin on industry classics explained in detail.</p> <p> Concepts</p> </li> <li> <p> Tooling</p> <p>Hyl\u00e9 tooling to improve your building experience.</p> <p> Tooling</p> </li> </ul> <p>Reach out on Telegram or open an issue if you need assistance or wish to provide feedback on the documentation: we're always looking to improve.</p>"},{"location":"#useful-links","title":"Useful links","text":"<ul> <li> Rust node</li> <li> Example contracts</li> <li> Website</li> <li> Hyl\u00e9 blog</li> </ul>"},{"location":"#lets-talk","title":"Let's talk!","text":"<p>Reach out to the team for more information:</p>  Github  Twitter  Farcaster  LinkedIn  Youtube  Telegram Hyl\u00e9 @hyle_org @hyle-org Hyl\u00e9 @Hyl\u00e9 @hyle_org"},{"location":"introduction/","title":"Introduction to Hyl\u00e9","text":""},{"location":"introduction/#introduction-to-hyle","title":"Introduction to Hyl\u00e9","text":"<p>Hyl\u00e9 is the new-generation base layer for the era of unchained applications.</p> <p>An unchained application runs offchain and settles onchain. It benefits from the Web2 user experience and the security of Web3.</p>"},{"location":"introduction/#why-choose-hyle","title":"Why choose Hyl\u00e9","text":"<p>Hyl\u00e9 is built for speed, flexibility, and seamless blockchain integration:</p> <ul> <li>Ultra-fast ZK verification on a sovereign L1.</li> <li>No EVMs, no bottlenecks: run complex logic off-chain, submit a proof, and we\u2019ll verify it natively before settling onchain.</li> <li>Frictionless onboarding: authenticate with any identity provider, no wallets required.</li> <li>High throughput, low latency with pipelined proving.</li> <li>Choose your tools: use any proving scheme, any language.</li> <li>Seamless interoperability: call other contracts with proof composition.</li> <li>Web2 speed, Web3 security: we use Autobahn consensus for DA &amp; settlement.</li> </ul>"},{"location":"introduction/#how-hyle-works","title":"How Hyl\u00e9 works","text":"<p>Here\u2019s what happens when you use Hyl\u00e9\u2019s next-generation base layer:</p> <p></p> <ol> <li>Sequencing: Send a provable blob of information to Hyl\u00e9: say what information you expect to prove later. We'll sequence the transaction immediately and give you time to prove it. Read more about pipelined proving.</li> <li>Proof submission: when the proofs for your transaction are ready, send them to Hyl\u00e9.</li> <li>Verification: Hyl\u00e9 validators receive the transaction. They verify the proofs natively, without the limitations of a bulky virtual machine.</li> <li>Consensus: if the proofs are valid, Hyl\u00e9 settles your transaction's state onchain. You're good to go!</li> </ol> <p>With this system, execution and storage happen anywhere you like. You only need a fast and trustworthy verifier: that\u2019s Hyl\u00e9.</p>"},{"location":"concepts/","title":"\ud83d\udca1 Concepts","text":""},{"location":"concepts/#concepts","title":"Concepts","text":"<p>Welcome to the developer documentation for Hyl\u00e9.</p> <p>This section includes general documentation topics. You can also refer to our Getting Started step-by-step guide.</p>"},{"location":"concepts/#hyle-specific-docs-on-industry-concepts","title":"Hyl\u00e9-specific docs on industry concepts","text":"<ul> <li> <p> Smart contracts</p> <p>Most smart contract information stays off-chain.</p> <p> Read more</p> </li> <li> <p> Transactions</p> <p>Understand blob transactions and proof transactions.</p> <p> Read more</p> </li> <li> <p> Proof generation</p> <p>Learn how to prove your blobs for Hyl\u00e9.</p> <p> Read more</p> </li> <li> <p> Identity</p> <p>Any smart contract can be an identity on Hyl\u00e9.</p> <p> Read more</p> </li> </ul>"},{"location":"concepts/#hyle-specific-concepts","title":"Hyl\u00e9-specific concepts","text":"<ul> <li> <p> Proof composition</p> <p>Compose several proof systems and manage cross-contract composition seamlessly.</p> <p> Read more</p> </li> <li> <p> Pipelined proving</p> <p>Separate sequencing and settlement and remove proving times from your app's critical path.</p> <p> Read more</p> </li> </ul>"},{"location":"concepts/#more","title":"More","text":"<ul> <li> <p> Hyl\u00e9 vs. vintage blockchains</p> <p>Learn the main differences between Hyl\u00e9 and traditional blockchains.</p> <p> Read more</p> </li> </ul>"},{"location":"concepts/hyle-vs-vintage-blockchains/","title":"Hyl\u00e9 vs. vintage blockchains","text":""},{"location":"concepts/hyle-vs-vintage-blockchains/#hyle-vs-vintage-blockchains","title":"Hyl\u00e9 vs. vintage blockchains","text":"<p>If you're used to traditional blockchains such as Ethereum or Solana, keep these Hyl\u00e9 characteristics in mind.</p>"},{"location":"concepts/hyle-vs-vintage-blockchains/#no-evm-or-execution-layer","title":"No EVM or execution layer","text":"<p>Hyl\u00e9 does not include a Virtual Machine.</p> <p>There is no dedicated execution engine or specific programming language (like Solidity) you should use.</p> <p>Our approach is simple: onchain, we verify zero-knowledge proofs natively. Offchain, you do everything else the way you prefer. This gives you higher throughput, faster finality, and lower gas fees.</p>"},{"location":"concepts/hyle-vs-vintage-blockchains/#minimal-onchain-state","title":"Minimal onchain state","text":"<p>The network maintains proofs of state transitions rather than the entire onchain state.</p> <p>Transactions on Hyl\u00e9 verify and settle transitions without storing full intermediary states onchain.</p> <p>This architecture reduces storage overhead and promotes scalability while maintaining trustlessness.</p>"},{"location":"concepts/hyle-vs-vintage-blockchains/#no-wallets","title":"No wallets","text":"<p>Stop asking yourself, \"Which wallet do I use? How do I bridge?\". You don\u2019t need to worry about wallets or bridges with Hyl\u00e9: any identity that can produce a valid proof works as your account.</p>"},{"location":"concepts/hyle-vs-vintage-blockchains/#every-app-is-a-rollup","title":"Every app is a rollup","text":"<p>On Hyl\u00e9, there is one general-purpose blockchain, and every app is its own based ZK-rollup, removing the problems associated with fragmentation.</p> <p>An app\u2019s transactions are sequenced directly on the Hyl\u00e9 base layer. They are split into a blob transaction, which allows for pipelined proving, and a proof transaction to store the state commitment onchain.</p>"},{"location":"concepts/hyle-vs-vintage-blockchains/#privacy-is-built-in","title":"Privacy is built-in","text":"<p>Unlike Ethereum, where privacy solutions must be implemented on top of the platform, Hyl\u00e9 integrates privacy features natively.</p> <p>The proof is public, but your inputs don't need to be, as execution happens offchain.</p>"},{"location":"concepts/identity/","title":"Identity management","text":""},{"location":"concepts/identity/#identity-management","title":"Identity management","text":"<p>Identity in traditional blockchains is often tied to a single wallet address, which limits flexibility and privacy.</p> <p>Hyl\u00e9 introduces a proof-based identity model. Instead of relying on fixed addresses or centralized registries, your application can use cryptographic proofs of identity.</p> <p>This approach allows users to authenticate with any identity source: meet users where they are and don't worry about onboarding and clunky wallets!</p>"},{"location":"concepts/identity/#choosing-an-identity-source","title":"Choosing an identity source","text":"<p>On Hyl\u00e9, any smart contract can be used as a proof of identity. This flexibility enables you to register your preferred identity source as a smart contract for account authentication.</p> <p>Here are some important aspects of identity contracts:</p> <ul> <li>Identity contracts define how proofs of identity are verified and validated.</li> <li>Applications decide which identities to accept. A contract can enforce specific identity types (e.g., Google accounts only) or support multiple sources simultaneously.</li> <li>A transaction can seamlessly send Hyl\u00e9 tokens between any identity types, such as from a Metamask wallet to an email and password-based account: using proofs as identities on Hyl\u00e9 means there is perfect interoperability.</li> <li>There are no Hyl\u00e9-specific wallets. Users authenticate using any proof supported by their application.</li> </ul> <p>A safe Identity provider should sign the whole blob transaction to ensure that the blobs have been approved by the user. One way of doing it is to let the user sign the blobs they agree to execute. The identity contract will then check that all the transaction's blobs are signed.</p> <p>If you don't want to create a custom identity source for early development, Hyl\u00e9 provides a native <code>hydentity</code> contract. This contract is not secure and must not be used in production.</p>"},{"location":"concepts/identity/#how-hyle-processes-identity-proofs","title":"How Hyl\u00e9 processes identity proofs","text":"<p>As explained in our transactions concept page, a <code>BlobTransaction</code> on Hyl\u00e9 can include multiple blobs. One of these blobs must be an identity claim.</p> <ul> <li>Each blob transaction requires a single identity.</li> <li>All provable blobs in a transaction must share the same identity.</li> <li>Identity proofs must include a nonce to prevent replay attacks.</li> <li>The proof verification process ensures the identity was correctly provided.</li> </ul>"},{"location":"concepts/identity/#custom-identity-contracts","title":"Custom identity contracts","text":"<p>Applications on Hyl\u00e9 can implement custom identity verification rules through smart contracts. A typical identity contract includes two core functions, as shown in our identity quickstart:</p> <ul> <li>Register: Users submit an initial proof of identity.</li> <li>Verify: The contract validates the proof against predefined rules.</li> </ul> <p>Applications can use this structure or define their own identity workflows as needed.</p>"},{"location":"concepts/pipelined-proving/","title":"Pipelined proving","text":""},{"location":"concepts/pipelined-proving/#pipelined-proving","title":"Pipelined proving","text":""},{"location":"concepts/pipelined-proving/#the-problem-base-state-conflicts","title":"The problem: base state conflicts","text":"<p>The Hyl\u00e9 base layer ensures both privacy and scalability by verifying only the state transitions of smart contracts, rather than re-executing them. This approach reduces computational overhead but introduces a critical issue for provable applications: base state conflicts.</p> <p>An app with a lot of usage will see conflicting operations, where multiple transactions reference the same base state, waiting for the previous state change to be settled.</p> <p>The time spent generating proofs delays transaction finality. Proofs require accurate timestamps, but users can't predict when their transaction will be sequenced.</p> <p>This causes parallelization limits: multiple transactions may reference the same base state, creating invalid proofs when one is settled before the other.</p> <p>We solve these issues by splitting sequencing from settlement; an operation includes two transactions.</p>"},{"location":"concepts/pipelined-proving/#blob-and-proof-transactions","title":"Blob- and proof-transactions","text":"<p>Read more on the content of blob and proof transactions on our transaction page.</p> <p>To address base state conflicts, Hyl\u00e9 splits operations into two transactions:</p> <ol> <li>Blob-transaction: outlines a state change for sequencing.</li> <li>Proof-transaction: provides a proof of the state change for settlement.</li> </ol> <p>From Hyl\u00e9\u2019s perspective, the blob-transaction's content does not matter: it simply represents incoming information that your contract will process. For a developer, sequencing provides you with a fixed order and timestamp before proving begins. Once the transactions are sequenced, the provers can easily know upon which state they should base their proof. As a developer, you can also decide on how much information is disclosed in your blob-transaction: this is app-specific.</p> <p>Settlement happens when the corresponding proof transaction is verified and added to a block. During settlement, unproven blob transactions linked to the contract are executed in their sequencing order.</p> <p></p> <p>This separation solves all three issues shown above. The blob transaction immediately reserves a place in execution order, allowing proof generation to run without blocking other transactions. The sequencing provides an immutable timestamp, so provers know which base state to use when generating proofs and can parallelize actions.</p>"},{"location":"concepts/pipelined-proving/#unprovable-transactions","title":"Unprovable transactions","text":"<p>Even with pipelined proving, sequenced transactions that never settle can slow down the network.</p> <p>To remove this risk, Hyl\u00e9 enforces timeouts for blob transactions.</p> <p>Each blob transaction is assigned a specific time limit for the associated proof to be submitted and verified. Subsequent transactions can proceed without waiting indefinitely.</p>"},{"location":"concepts/pipelined-proving/#failed-transactions","title":"Failed transactions","text":"<p>If the proof isn't submitted before timeout, or if the submitted proof is invalid, the transaction is included in the block, marked as Rejected, and is ignored for state updates.</p> <p>The inclusion of the unproven transaction in the block ensures transparency, as the transaction data remains accessible.</p> <p></p>"},{"location":"concepts/proof-composability/","title":"Proof composition","text":""},{"location":"concepts/proof-composability/#proof-composition","title":"Proof composition","text":"<p>Note</p> <p>To understand proof composition in practice, check out our quickstart example.</p>"},{"location":"concepts/proof-composability/#the-problem-clunky-interactions","title":"The problem: clunky interactions","text":"<p>In zero-knowledge systems, interactions between different proofs introduce complexity.</p> <p>Cross-contract interactions require recursive proof verification, where Program A verifies proof of the correct execution of Program B. This is inefficient and creates overhead at the proof generation and verification stages.</p> <p>The challenge becomes even greater when you start involving proofs that use different schemes.</p> <p>Most zero-knowledge systems force you to write your proofs in a unified scheme. By doing that, you lose all the advantages of specialization.</p> <p>Different proving schemes meet different needs. Some proof systems are best for client-side proving; others allow developers to use general-purpose programming languages.</p> <p>We solve this issue by allowing for native proof composition between contracts and proving schemes. Now, proofs interact seamlessly, and each one can be written in the language that works best.</p>"},{"location":"concepts/proof-composability/#the-solution-proof-composition","title":"The solution: proof composition","text":""},{"location":"concepts/proof-composability/#cross-contract-calls-with-proof-composition","title":"Cross-contract calls with proof composition","text":"<p>Proof composability means that Hyl\u00e9 enables these interactions while keeping each proof independent; proof composition is the action enabled by composability.</p> <p>Hyl\u00e9 gets rid of recursion by allowing Program A to specify: \"This only applies if all blobs in this operation are valid\". At settlement, both proofs are included in the same proof transaction. Hyl\u00e9 verifies them together, and the entire operation fails if any proof fails.</p> <p>This solution improves developer experience, lowers gas costs, and shortens proving time.</p>"},{"location":"concepts/proof-composability/#proofs-using-different-schemes","title":"Proofs using different schemes","text":"<p>Since proofs in Hyl\u00e9 remain independent, you can batch multiple proofs within a single transaction, each using its optimal proving scheme.</p> <p>Proofs are verified separately, eliminating the need to compromise for compatibility. This also enables cross-contract calls between applications using different proof systems.</p>"},{"location":"concepts/proof-composability/#when-to-use-proof-composition","title":"When to use proof composition","text":"<p>Proof composition is useful if:</p> <ul> <li>Your operation involves several apps.</li> <li>Your operation involves several proofs written in different languages.</li> <li>Your operation involves very different actions and has different optimal languages: you can now afford to use them.</li> </ul> <p>It has no effect if your operation's entire logic is in one single proof.</p>"},{"location":"concepts/proof-composability/#writing-a-cross-contract-call","title":"Writing a cross-contract call","text":"<p>Your program doesn't need to verify another program\u2019s execution directly. Instead, it references the external contract using a structured claim, such as:</p> <pre><code>MoneyApp::transfer(10, A, B) == true\nTicketApp::get(A) == ticket\n</code></pre> <p></p> <p>Each claim consists of:</p> <ul> <li>The application (MoneyApp, TicketApp)</li> <li>The function being called (transfer, get)</li> <li>The parameters used</li> <li>A result assertion (== true, == ticket)</li> </ul> <p>In our quickstart example, the source code looks like this.</p>"},{"location":"concepts/proof-composability/#how-hyle-settles-multiple-proofs","title":"How Hyl\u00e9 settles multiple proofs","text":"<p>When you submit multiple proofs to Hyl\u00e9, proof generation can be parallelized.</p> <p>Thanks to pipelined proving, proof verification is asynchronous. Proving times do not compound since proofs do not depend on each other, allowing proof generation to be parallelized.</p> <p>As soon as one proof is ready, it can be verified on Hyl\u00e9, even if the other proofs aren't ready yet.</p> <p>Once all proofs related to the transaction are verified, the transaction is settled on Hyl\u00e9. If one proof verification fails, then the entire transaction fails. If a proof times out, the transaction fails when the timeout occurs.</p>"},{"location":"concepts/proof-generation/","title":"Proof generation and submission","text":""},{"location":"concepts/proof-generation/#proof-generation-and-submission","title":"Proof generation and submission","text":"<p>Hyl\u00e9 allows you to build unchained applications by leveraging zero-knowledge proofs. They allow you to avoid onchain execution, guarantee privacy, and customize your application while maintaining composability with other smart contracts.</p> <p>With Hyl\u00e9, generate your proof wherever you prefer, then send it for native onchain verification and settlement. This process enables scalable, modular applications with customizable proving schemes.</p> <p>If you're a complete beginner with zero-knowledge proofs, our no-code introduction might help.</p>"},{"location":"concepts/proof-generation/#generating-zero-knowledge-proofs-for-hyle","title":"Generating zero-knowledge proofs for Hyl\u00e9","text":""},{"location":"concepts/proof-generation/#choose-what-you-prove","title":"Choose what you prove","text":"<p>Each application defines its proof logic. This means that each application developer can decide what information gets proven: for Hyl\u00e9, proof settlement is a Success or a Failure. You define what that means for your app.</p> <p>Each app developer also defines what the public and private inputs of their app will be: what information should remain private and what should go onchain?</p>"},{"location":"concepts/proof-generation/#how-to-generate-a-zero-knowledge-proof","title":"How to generate a zero-knowledge proof","text":"<p>There are many ZK languages. Hyl\u00e9 aims to verify as many as possible.</p> <p>DSLs, like Circom, are specific languages that usually compile down to a specific circuit. They're good, but they're complex and may have a high learning curve.</p> <p>zkVMs prove the correct execution of arbitrary code. They allow you to build ZK applications in a certain language without having to build a circuit around it. There are two main types of zkVMs: Cairo and RISC-V. You can benchmark your Rust code and find the best zkVM for your needs with the any-zkvm template.</p> <p>Each application can generate its proof in whichever place fits best.</p> Pros Cons When to use Client-side (browser, mobile app) Maximum privacyData ownership Requires robust client-side hardware Personal data that should remain private External prover or proving market No client-side costs or constraintsOffload proof generation to the experts Requires trusting the external prover with your inputs Resource-intensive and not privacy-sensitive proofs By the application itself Simple UXNo dependenciesCode can be private Higher infrastructure needsPotential liveness issue Confidential or centralized applications"},{"location":"concepts/proof-generation/#our-supported-proving-schemes","title":"Our supported proving schemes","text":"<p>Proving schemes are the cryptographic protocols that make zero-knowledge proofs usable. We support as many as we can, giving you the flexibility to choose the most suitable protocol for your specific use case.</p> <p>We've written templates for some of our supported programs. Clone them to get started with smart contract writing.</p> <p>We also verify these natively, without the need for a ZK proof.</p> <ul> <li>sha3_256</li> <li>BLST signatures</li> </ul> <p>We will support more types, including Cairo-based zkVMs and DSLs, in the future, and plan to support all major proving schemes eventually. The next proving schemes we're aiming to support are Cairo via Stwo and Groth16.</p>"},{"location":"concepts/proof-generation/#our-proof-generation-partners","title":"Our proof generation partners","text":"<p>If you choose to work with an external prover or proving market, you can choose from one of our partners in that area and benefit from a better Hyl\u00e9 integration.</p> <p>We recommend checking out Electron, Fermah, Kakarot, Marlin, Nexus, Nodekit, ZEROBASE, or zkCloud.</p>"},{"location":"concepts/proof-generation/#submitting-a-proof-to-hyle","title":"Submitting a proof to Hyl\u00e9","text":"<p>Read more about the transaction lifecycle on our transactions overview.</p> <p>First, your application sends a blob transaction to Hyl\u00e9.</p> <p>Thanks to pipelined proving, once a transaction is submitted, it is sequenced.</p> <p>You can then start generating your proof using the sequenced virtual base state as the base state for your operation. Read our quickstart for a concrete example of how to prove a transaction.</p> <p>Once sent, the proof goes through Hyl\u00e9\u2019s native verification, removing the need for verifier contracts.</p> <p>Once verified, the proof is settled onchain. Use this settled state to update your app accordingly outside of Hyl\u00e9.</p>"},{"location":"concepts/proof-generation/#external-resources","title":"External resources","text":"<ul> <li>Zero-knowledge proofs explained at 5 levels of difficulty (22')</li> <li>awesome-zk link repository on GitHub</li> <li>Hyl\u00e9's very simple introduction to zero-knowledge proofs</li> <li>Lauri Peltonen's blog series on ZK</li> </ul>"},{"location":"concepts/smart-contracts/","title":"Smart contracts","text":""},{"location":"concepts/smart-contracts/#smart-contracts","title":"Smart contracts","text":"<p>Hyl\u00e9 is a fully programmable blockchain designed for efficient data storage. Hyl\u00e9 only keeps the essential information needed to validate smart contract proofs, ensuring that smart contracts are lightweight and performant.</p> <p>Unlike traditional blockchains, which store all smart contract data onchain, Hyl\u00e9 separates execution data (managed offchain by each application) from onchain data, which can be retrieved via our ABI.</p>"},{"location":"concepts/smart-contracts/#onchain-smart-contract-data","title":"Onchain smart contract data","text":"<p>Hyl\u00e9 smart contracts store the following data onchain:</p> <ul> <li>Name: the unique identifier for the contract</li> <li>Verifier: the proof system used (e.g., \"risc0\" or \"gnark-groth16-te-BN254\")</li> <li>Program ID: the unique identifier for the program within that proof system</li> <li>State digest: current state commitment of the contract</li> </ul>"},{"location":"concepts/smart-contracts/#explanation-of-the-contract-fields","title":"Explanation of the contract fields","text":""},{"location":"concepts/smart-contracts/#name","title":"Name","text":"<p>The contract name must be unique.</p>"},{"location":"concepts/smart-contracts/#verifier-and-program-id","title":"Verifier and program ID","text":"<p>Smart contracts on Hyl\u00e9 rely on a pairing of a zero-knowledge proof scheme (verifier) and a program identifier. Together, these components validate contract proofs.</p> <p>Clone a template or write your own program to get started with smart contract writing.</p> Proving scheme Verifier Program ID Template Noir noir Verification key. Risc0 risc0 Image ID without a prefix. ex. 0x123 becomes 123. Template SP1 sp1 Verification key. Template"},{"location":"concepts/smart-contracts/#state-digest","title":"State digest","text":"<p>The state digest represents the contract's current state commitment. It allows Hyl\u00e9 to guarantee its integrity. It can take any form as long as it fulfills this purpose.</p> <p>The state digest can be expressed as a hash or even a serialization of the state if it's small enough.</p>"},{"location":"concepts/smart-contracts/#smart-contract-abi","title":"Smart contract ABI","text":"<p>All inputs in Hyl\u00e9 smart contracts must be known at proof generation time. This includes elements like the <code>tx_hash</code> which are typically available only at execution time on other blockchains.</p> <p>Here is the Rust structure specifying the output of a Hyl\u00e9 smart contract:</p> <pre><code>pub struct HyleOutput {\n    pub version: u32,\n    pub initial_state: StateDigest,\n    pub next_state: StateDigest,\n    pub identity: Identity,\n    pub index: BlobIndex,\n    pub blobs: Vec&lt;u8&gt;,\n    pub tx_hash: TxHash,\n    pub success: bool,\n    pub tx_ctx: Option&lt;TxContext&gt;,\n    pub registered_contracts: Vec&lt;RegisterContractEffect&gt;,\n    pub program_outputs: Vec&lt;u8&gt;, \n}\n</code></pre>"},{"location":"concepts/smart-contracts/#version","title":"Version","text":"<p>For now, <code>version</code> should always be set to 1.</p>"},{"location":"concepts/smart-contracts/#initial-state-and-next-state","title":"Initial state and next state","text":"<p>These fields define state transitions.</p> <ul> <li><code>initial_state</code>: must match the onchain <code>state_digest</code> before the transaction. If they don't match, the state transition is invalid.</li> <li><code>next_state</code>: Represents the new onchain <code>state_digest</code> after the transaction.</li> </ul> <p>In the future, <code>state_digest</code> size will be limited and fees will depend on proof size (which is affected by the digest's size). Keep them small!</p>"},{"location":"concepts/smart-contracts/#identity","title":"Identity","text":"<p>Info</p> <p>Read our identity documentation for details.</p> <p>Identity consists of:</p> <ol> <li>An identifier;</li> <li>The name of the contract that the proof was generated for.</li> </ol> <p>Example</p> <p>A contract verifying Ethereum EOAs might have an identity like <code>0x1234...5678.eth_eoa</code> where the first part matches a regular Ethereum address and <code>eth_eoa</code> is the name of the contract.</p>"},{"location":"concepts/smart-contracts/#blob-index-and-blobs","title":"Blob index and blobs","text":"<p>Each blob transaction includes multiple blobs:</p> <ul> <li><code>index</code> uniquely identifies a blob within a transaction.</li> <li><code>blobs</code> is a list of all blobs included in the transaction.</li> </ul>"},{"location":"concepts/smart-contracts/#tx-hash","title":"TX Hash","text":"<p><code>tx_hash</code> is the blob Transaction's hash.</p> <p>The protocol does not validate this field and <code>tx_hash</code> may be deprecated in later versions.</p>"},{"location":"concepts/smart-contracts/#success","title":"Success","text":"<p>This boolean field indicates whether the proof is for a successful or failed transactions. It can be used to prove that a transaction is invalid.</p> <p>If a proof returns <code>success = false</code>, the whole blob transaction will fail. In that case, there is no need to generate proofs for other blobs.</p>"},{"location":"concepts/smart-contracts/#transaction-context","title":"Transaction context","text":"<p>Transaction context allows the contract to know in which block (hash, height, timestamp) the blob transaction has been sequenced.</p> <p>This field is optional. If left empty, it will not be validated by Hyl\u00e9 or usable by the program.</p>"},{"location":"concepts/smart-contracts/#registered-contracts","title":"Registered contracts","text":"<p>A list of new contracts to register, which can be used to self-upgrade a contract.</p>"},{"location":"concepts/smart-contracts/#other-program-specific-outputs","title":"Other program-specific outputs","text":"<p>Smart contracts can generate additional outputs as proof data. These outputs ensure data availability.</p>"},{"location":"concepts/smart-contracts/#events","title":"Events","text":"<p>Hyl\u00e9 does not use traditional events. Instead, it relies on blobs, which serve as containers for offchain data.</p>"},{"location":"concepts/transaction/","title":"Transactions on Hyl\u00e9","text":""},{"location":"concepts/transaction/#transactions-on-hyle","title":"Transactions on Hyl\u00e9","text":"<p>Hyl\u00e9 introduces a novel transaction model that separates intent from proof, optimizing for scalability and privacy.</p> <p>Unlike traditional blockchains, where transactions are executed and proven in a single step, Hyl\u00e9 employs a two-step process called pipelined proving:</p> <ol> <li>Blob-transaction: outlines a state change for sequencing.</li> <li>Proof-transaction: provides a proof of the state change for settlement.</li> </ol> <p>Each proof transaction verifies a single blob, unless you use recursion. If a blob transaction contains multiple blobs, each requires a separate proof.</p> <p>Once all blobs are proven, the blob transaction is settled, and the referenced contract states are updated.</p>"},{"location":"concepts/transaction/#blob-transaction-structure","title":"Blob transaction structure","text":"<p>A blob transaction consists of:</p> <ul> <li>An identity string. See identity.</li> <li>A list of blobs, each containing:</li> <li>A contract name (string).</li> <li>A data field (binary), which the contract parses.</li> </ul>"},{"location":"concepts/transaction/#proof-transaction-structure","title":"Proof transaction structure","text":"<p>A proof transaction includes:</p> <ul> <li>A contract name (string).</li> <li>Proof data (binary), containing:</li> <li>A zero-knowledge proof.</li> <li>The smart contract output.</li> </ul> <p>For Risc0 and SP1, the proof data's smart contract output follows <code>HyleOutput</code> as defined in the smart contract ABI.</p>"},{"location":"concepts/transaction/#example-token-transfer","title":"Example: token transfer","text":"<p>A token transfer involves two blobs in a blob transaction:</p> <ul> <li>Identity blob: Verifies the sender\u2019s identity and authorizes the transfer.</li> <li>Transfer blob: Executes the token transfer.</li> </ul> <p>Each blob requires a corresponding proof transaction.</p>"},{"location":"concepts/transaction/#blob-transaction","title":"Blob transaction","text":"<pre><code>{\n    \"identity\": \"bob.hydentity\",\n    \"blobs\": [\n        {\n            \"contract_name\": \"hydentity\",\n             // Binary data for the operation of hydentity contract\n             // VerifyIdentity { account: \"bob.hydentity\", nonce: \"2\" }\n            \"data\": \"[...]\" \n        },\n        {\n            \"contract_name\": \"hyllar\",\n             // Binary data for the operation of hyllar contract\n             // Transfer { recipient: \"alice.hydentity\", ammount: \"20\" }\n            \"data\": \"[...]\"\n        }\n    ]\n}\n</code></pre>"},{"location":"concepts/transaction/#proof-transactions","title":"Proof transactions","text":""},{"location":"concepts/transaction/#identity-proof","title":"Identity proof","text":"<pre><code>{\n    \"contract_name\": \"hydentity\",\n    \"proof\": \"[...]\"\n}\n</code></pre> <p>The binary proof's output includes:</p> <ul> <li>Initial state: <code>bob.hydentity</code> nonce = 1.</li> <li>Next state: <code>bob.hydentity</code> nonce = 2.</li> <li>Index: 0 (first blob in the transaction).</li> </ul> <p>and</p> <pre><code>{\n    \"contract_name\": \"hyllar\",\n    \"proof\": \"[...]\"\n}\n</code></pre> <p>The binary proof's output includes:</p> <ul> <li>Initial state: <code>bob.hydentity</code> balance = 100, <code>alice.hydentity</code> balance = 0.</li> <li>Next state: <code>bob.hydentity</code> balance = 80, <code>alice.hydentity</code> balance = 20.</li> <li>Index: 1 (second blob in the transaction).</li> </ul>"},{"location":"quickstart/","title":"\ud83c\udfc1 Quickstart","text":""},{"location":"quickstart/#quickstart","title":"Quickstart","text":"<p>Welcome to the Quickstart guide for Hyl\u00e9.</p> <p>It uses several examples to help you start building as soon as possible.</p> <p>Run your local devnet</p> <p>Where it all begins.</p> <p>Create your first smart contract</p> <p>In just a couple of lines, create and register your first smart contract.</p> <p>Walk through a full example</p> <p>Check out a ticket app based on a token and simple identity contract.</p>"},{"location":"quickstart/devnet/","title":"Run your local devnet","text":""},{"location":"quickstart/devnet/#run-your-local-devnet","title":"Run your local devnet","text":"<p>For a single-node devnet (consensus disabled) with an indexer, clone the hyle repository and run:</p> <pre><code>cargo run -- --pg\n</code></pre> <p>This command starts a temporary PostgreSQL server and erases its data when you stop the node.</p> <p>For alternative setups, optional features, and advanced configurations, check out the devnet reference page.</p>"},{"location":"quickstart/your-first-smart-contract/","title":"Your first smart contract","text":""},{"location":"quickstart/your-first-smart-contract/#your-first-smart-contract","title":"Your first smart contract","text":"<p>Tip</p> <p>Check our example walkthrough for more!</p>"},{"location":"quickstart/your-first-smart-contract/#step-1-clone-a-template","title":"Step 1: Clone a template","text":"<p>We support several proving schemes:</p> Proving scheme Verifier Program ID Language Template Noir noir Verification key. Noir Risc0 risc0 Image ID without a prefix. ex. 0x123 becomes 123. Rust Template SP1 sp1 Verification key. Rust Template <p>Clone the template or, for proving schemes without templates, use the templates as inspiration for writing your contract. You can also check our smart contract concept page for more information!</p>"},{"location":"quickstart/your-first-smart-contract/#step-2-edit-your-contract","title":"Step 2: Edit your contract","text":"<p>Navigate to the <code>contract/</code> folder and edit your contract as necessary.</p>"},{"location":"quickstart/your-first-smart-contract/#step-3-register-your-contract","title":"Step 3: Register your contract","text":"<p>On the devnet, register your contract by running:</p> <pre><code>cargo run -- register-contract\n</code></pre>"},{"location":"quickstart/example/","title":"Example walkthrough","text":""},{"location":"quickstart/example/#example-walkthrough","title":"Example walkthrough","text":"<p>Here's a step-by-step walkthrough of an example.</p> <p>Run your local devnet</p> <p>Where it all begins.</p> <p>Create your first smart contract</p> <p>Understand how smart contracts work on Hyl\u00e9 with our simple-token example.</p> <p>Use an identity contract</p> <p>Every contract can be an identity on Hyl\u00e9. Try it out with our simple-identity example.</p> <p>Call several contracts in one transaction</p> <p>Use cross-contract proof composition to buy a simple-ticket with a simple-token.</p>"},{"location":"quickstart/example/custom-identity-contract/","title":"Using a custom identity contract","text":""},{"location":"quickstart/example/custom-identity-contract/#using-a-custom-identity-contract","title":"Using a custom identity contract","text":""},{"location":"quickstart/example/custom-identity-contract/#when-to-use-identity-contracts-on-hyle","title":"When to use identity contracts on Hyl\u00e9","text":"<p>On Hyl\u00e9, any smart contract can be a proof of identity. This flexibility enables you to register your preferred identity source as a smart contract for account identification. If you don't want to use a custom identity source, Hyl\u00e9 ships a native <code>hydentity</code> contract.</p> <p>This guide walks you through creating and deploying your first simple identity contract using Hyl\u00e9 and RISC Zero. We'll use our simple identity example, which mirrors our simple token transfer example.</p> <p>If you\u2019re new to identity management on Hyl\u00e9, read the identity management concept page.</p>"},{"location":"quickstart/example/custom-identity-contract/#run-the-example","title":"Run the example","text":"<p>Warning</p> <p>Our examples work on Hyl\u00e9 v0.12.1. Later versions may introduce breaking changes which have not yet been reflected in our examples.</p> <p>Info</p> <p>Jump to Code Snippets for an in-depth look at the contract.</p>"},{"location":"quickstart/example/custom-identity-contract/#prerequisites","title":"Prerequisites","text":"<ul> <li>Install Rust (you'll need <code>rustup</code> and Cargo).</li> <li>Install openssl-dev (e.g. <code>apt install openssl-dev</code> or <code>cargo add openssl</code>).</li> <li>For our example, install RISC Zero.</li> <li>Start a single-node devnet. We recommend using dev-mode with <code>-e RISC0_DEV_MODE=1</code> for faster iterations during development.</li> </ul>"},{"location":"quickstart/example/custom-identity-contract/#build-and-register-the-identity-contract","title":"Build and register the identity contract","text":"<p>To build all methods and register the smart contract on the local node from the source, navigate to your cloned Examples folder and run:</p> <pre><code>cargo run -- register-contract\n</code></pre> <p>The expected output is <code>\ud83d\udcdd Registering new contract simple_identity</code>.</p>"},{"location":"quickstart/example/custom-identity-contract/#register-an-account-sign-up","title":"Register an account (sign up)","text":"<p>To register an account with a username (<code>alice</code>) and password (<code>abc123</code>), execute:</p> <pre><code>cargo run -- register-identity alice.simple_identity abc123\n</code></pre> <p>Expected log output:</p> <pre><code>INFO hyle::data_availability::node_state::verifiers: \u2705 Risc0 proof verified.\nINFO hyle::data_availability::node_state::verifiers: \ud83d\udd0e Program outputs: Successfully registered identity for account: alice.simple_identity\n</code></pre>"},{"location":"quickstart/example/custom-identity-contract/#verify-identity-login","title":"Verify identity / Login","text":"<p>To verify <code>alice</code>'s identity:</p> <pre><code>cargo run -- verify-identity alice.simple_identity abc123 0\n</code></pre> <p>This command:</p> <ol> <li>Sends a blob transaction to verify <code>alice</code>'s identity.</li> <li>Generates a ZK proof of that identity. It will only be valid once, thus the inclusion of a nonce.</li> <li>Sends the proof to the devnet.</li> </ol> <p>Upon reception of the proof, the node will:</p> <ol> <li>Verify the proof.</li> <li>Settle the blob transaction.</li> <li>Update the contract's state.</li> </ol> <p>Expected log output:</p> <pre><code>INFO hyle::data_availability::node_state::verifiers: \u2705 Risc0 proof verified.\nINFO hyle::data_availability::node_state::verifiers: \ud83d\udd0e Program outputs: Identity verified for account: alice.simple_identity\n</code></pre>"},{"location":"quickstart/example/custom-identity-contract/#development-mode","title":"Development mode","text":"<p>We recommend activating dev-mode during your early development phase for faster iteration upon code changes with <code>-e RISC0_DEV_MODE=1</code>.</p> <p>You may also want to get insights into the execution statistics of your project: add the environment variable <code>RUST_LOG=\"[executor]=info\"</code> before running your project.</p> <p>The full command to run your project in development mode while getting execution statistics is:</p> <pre><code>RUST_LOG=\"[executor]=info\" RISC0_DEV_MODE=1 cargo run\n</code></pre>"},{"location":"quickstart/example/custom-identity-contract/#code-snippets","title":"Code snippets","text":"<p>Find the full annotated code in our examples repository.</p>"},{"location":"quickstart/example/custom-identity-contract/#registering-the-contract","title":"Registering the contract","text":"<p>This part is the same as for Your first smart contract.</p>"},{"location":"quickstart/example/custom-identity-contract/#register-an-identity","title":"Register an identity","text":""},{"location":"quickstart/example/custom-identity-contract/#build-the-blob-transaction","title":"Build the blob transaction","text":"<p>This is a simplified code snippet:</p> <pre><code>let action = RegisterIdentity {\n    account: identity,\n};\nlet blob = sdk::Blob {\n    contract_name: contract_name,\n    data: action.as_blob_data(), // Note: This function does not exist. Used here for clarity\n};\nlet blob_tx = BlobTransaction {\n    identity: identity,\n    blobs: vec![blob],\n};\n</code></pre> <p>You can compare these to the fields described in the Transactions on Hyl\u00e9 page.</p>"},{"location":"quickstart/example/custom-identity-contract/#prove-the-registration","title":"Prove the registration","text":""},{"location":"quickstart/example/custom-identity-contract/#on-the-backend-host-side","title":"On the backend (host) side","text":"<p>Hyl\u00e9 transactions follow a two-step settlement process based on pipelined proving principles:</p> <ol> <li>Sending the blob transaction: The transaction is sequenced but not yet settled.</li> <li>Proving the transaction: The transaction is settled after a proof is generated.</li> </ol> <p>To generate the proof, we build the contract input, specifying:</p> <ul> <li>initial state</li> <li>identity of the transaction initiator</li> <li>transaction hash (found in the explorer after sequencing)</li> <li>blob information</li> <li>The password as a private input for proof generation in <code>private_blob</code></li> <li><code>blobs</code>: full list of blobs in the transaction (must match the blob transaction)</li> <li><code>index</code>: each blob must be proven separately, so they need an index</li> </ul> <pre><code>// Build the contract input\nlet inputs = ContractInput {\n    initial_state: initial_state.as_digest(),\n    identity: blob_tx.identity,\n    tx_hash: blob_tx_hash,\n    private_blob: sdk::BlobData(password),\n    blobs: blobs,\n    index: sdk::BlobIndex(0),\n};\n</code></pre>"},{"location":"quickstart/example/custom-identity-contract/#on-the-contract-guest-side","title":"On the contract (guest) side","text":"<p>These inputs are then processed by the SDK to initialize the contract :</p> <pre><code>    // Parse contract inputs\n    let (input, action) = sdk::guest::init_raw::&lt;IdentityAction&gt;();\n</code></pre> <ul> <li>The input variable is the ContractInput defined earlier</li> <li>The action contains the <code>let action RegisterIdentity { account: identity };</code> from the blob.</li> </ul> <p>The password is extracted as a private input:</p> <pre><code>    // Extract private information\n    let password = from_utf8(&amp;input.private_blob.0).unwrap();\n</code></pre> <p>The contract processes the identity registration:</p> <pre><code>    // We clone the initial state to be updated\n    let mut next_state: Identity = input.initial_state.clone();\n\n    // Execute the given action\n    let res = sdk::identity_provider::execute_action(&amp;mut next_state, action, password);\n</code></pre> <p>Finally, the contract commits the updated state:</p> <pre><code>    sdk::guest::commit(input, next_state, res);\n</code></pre> <p>The <code>guest::commit</code> function includes the <code>HyleOutput</code>, as explained in Transactions on Hyl\u00e9.</p>"},{"location":"quickstart/example/custom-identity-contract/#verify-an-identity","title":"Verify an identity","text":"<p>The identity verification process is identical to identity registration, with a different action:</p> <pre><code>let action = VerifyIdentity {\n    account: identity,\n    nonce,\n};\n</code></pre> <p>Check the full annotated code in our GitHub example.</p>"},{"location":"quickstart/example/first-token-contract/","title":"Your first token contract","text":""},{"location":"quickstart/example/first-token-contract/#your-first-token-contract","title":"Your first token contract","text":"<p>This guide will walk you through creating and deploying your first token transfer contract using Hyl\u00e9's tools and infrastructure. We'll use our simple-token transfer example as the basis for this tutorial.</p> <p>For an alternative implementation, check out the same example built with SP1.</p> <p>If you\u2019re new to smart contracts on Hyl\u00e9, read the anatomy of a smart contract.</p>"},{"location":"quickstart/example/first-token-contract/#example","title":"Example","text":"<p>Warning</p> <p>Our examples work on Hyl\u00e9 v0.12.1. Later versions may introduce breaking changes that are not yet reflected in our examples.</p>"},{"location":"quickstart/example/first-token-contract/#prerequisites","title":"Prerequisites","text":"<ul> <li>Install Rust (you'll need <code>rustup</code> and Cargo).</li> <li>Install openssl-dev (e.g. <code>apt install openssl-dev</code> or <code>cargo add openssl</code>).</li> <li>For our example, install RISC Zero.</li> <li>Run a single-node devnet. We recommend using dev-mode with <code>-e RISC0_DEV_MODE=1</code> for faster iterations.</li> </ul>"},{"location":"quickstart/example/first-token-contract/#quickstart","title":"Quickstart","text":""},{"location":"quickstart/example/first-token-contract/#build-and-register-the-contract","title":"Build and register the contract","text":"<p>To build all methods and register the smart contract from the source, navigate to your cloned Examples folder and run:</p> <pre><code>cargo run -- register 1000\n</code></pre> <p>The expected output is <code>\ud83d\udcdd Registering new contract simple_token</code>.</p>"},{"location":"quickstart/example/first-token-contract/#transfer-tokens","title":"Transfer tokens","text":"<p>Transfer 2 tokens from the Hyl\u00e9 <code>faucet</code> to <code>Bob</code>:</p> <pre><code>cargo run -- transfer faucet.simple_token bob.simple_token 2\n</code></pre> <p>This command:</p> <ol> <li>Sends a blob transaction to transfer 2 tokens from <code>faucet</code> to <code>bob</code>. To better understand what a blob transaction is, read more about transactions on Hyl\u00e9.</li> <li>Generates a ZK proof for the transfer.</li> <li>Sends the proof to the devnet for verification. (Scroll down to see what that looks like in code.)</li> </ol>"},{"location":"quickstart/example/first-token-contract/#verify-settled-state","title":"Verify settled state","text":"<p>Upon reception of the proof, the node will:</p> <ol> <li>Verify the proof</li> <li>Settle the blob transaction</li> <li>Update the contract's state</li> </ol> <p>Expected log output:</p> <pre><code>INFO hyle::data_availability::node_state::verifiers: \u2705 Risc0 proof verified.\nINFO hyle::data_availability::node_state::verifiers: \ud83d\udd0e Program outputs: Transferred 2 to bob.simple_token\n</code></pre> <p>On the following slot:</p> <pre><code>INFO hyle::data_availability::node_state: Settle tx TxHash(\"[..]\")\n</code></pre>"},{"location":"quickstart/example/first-token-contract/#check-onchain-balance","title":"Check onchain balance","text":"<p>Verify onchain balances:</p> <pre><code>cargo run -- balance faucet.simple_token\ncargo run -- balance bob.simple_token\n</code></pre> <p>Note</p> <p>In this example, we do not verify the identity of the person who initiates the transaction. We use <code>.simple_token</code> as a suffix for the \"from\" and \"to\" transfer fields, but the correct identity scheme should be used in production.</p> <p>See your contract's state digest at: <code>https://hyleou.hyle.eu/contract/$CONTRACT_NAME</code>.</p> <p>See your transaction on Hyl\u00e9's explorer: <code>https://hyleou.hyle.eu/tx/$TX_HASH</code>.</p>"},{"location":"quickstart/example/first-token-contract/#development-mode","title":"Development mode","text":"<p>For faster iteration during development, enable dev-mode: <code>-e RISC0_DEV_MODE=1</code>.</p> <p>To get execution statistics, set: <code>RUST_LOG=\"[executor]=info\"</code> as an environment variable.</p> <p>To run your project in development mode with logs:</p> <pre><code>RUST_LOG=\"[executor]=info\" RISC0_DEV_MODE=1 cargo run\n</code></pre>"},{"location":"quickstart/example/first-token-contract/#annotated-code-snippets","title":"Annotated code snippets","text":"<p>Find the full annotated code in our examples repository.</p> <p>Below are key snippets explaining contract registration, blob transactions, and proofs.</p>"},{"location":"quickstart/example/first-token-contract/#registering-the-contract","title":"Registering the contract","text":"<p>Set up information about your contract. To register the contract, you'll need:</p> <ul> <li><code>owner</code>: we put \"examples\" as the <code>owner</code>, but you can put anything you like. This field is currently not leveraged; it will be in future versions.</li> <li><code>verifier</code>: for this example, the verifier is <code>risc0</code></li> <li><code>program_id</code>: RISC Zero programs are identified by their image ID, without a prefix.</li> <li><code>state_digest</code>: usually a MerkleRootHash of the contract's initial state. For this example, we use a hexadecimal representation of the state encoded in binary format. The state digest cannot be empty, even if your app is stateless.</li> <li><code>contract_name</code> as set up above.</li> </ul> <pre><code>// Build initial state of contract\nlet initial_state = Token::new(supply, format!(\"faucet.{}\", contract_name).into());\nprintln!(\"Initial state: {:?}\", initial_state);\n\n// Send the transaction to register the contract\nlet register_tx = RegisterContractTransaction {\n    owner: \"examples\".to_string(),\n    verifier: \"risc0\".into(),\n    program_id: sdk::ProgramId(sdk::to_u8_array(&amp;GUEST_ID).to_vec()),\n    state_digest: initial_state.as_digest(),\n    contract_name: contract_name.clone().into(),\n};\nlet res = client\n    .send_tx_register_contract(&amp;register_tx)\n    .await\n    .unwrap()\n    .text()\n    .await\n    .unwrap();\n\nprintln!(\"\u2705 Register contract tx sent. Tx hash: {}\", res);\n</code></pre> <p>In the explorer, this will look like this:</p> <pre><code>{\n    \"tx_hash\": \"321b7a4b2228904fc92979117e7c2aa6740648e339c97986141e53d967e08097\",\n    \"owner\": \"examples\",\n    \"verifier\": \"risc0\",\n    \"program_id\":\"e085fa46f2e62d69897fc77f379c0ba1d252d7285f84dbcc017957567d1e812f\",\n    \"state_digest\": \"fd00e876481700000001106661756365742e687964656e74697479fd00e876481700000000\",\n    \"contract_name\": \"simple_token\"\n}\n</code></pre>"},{"location":"quickstart/example/first-token-contract/#create-blob-transaction","title":"Create blob transaction","text":"<pre><code>// The action to execute, that will be proved later\nlet action = sdk::erc20::ERC20Action::Transfer {\n    recipient: to.clone(),\n    amount,\n};\n// Into a BlobTransaction to be sent on chain\nlet blobs = vec![sdk::Blob {\n    contract_name: contract_name.clone().into(),\n    data: sdk::BlobData(\n        bincode::encode_to_vec(action, bincode::config::standard())\n            .expect(\"failed to encode BlobData\"),\n    ),\n}];\nlet blob_tx = BlobTransaction {\n    identity: from.into(),\n    blobs,\n};\n\n// Send the blob transaction\nlet blob_tx_hash = client.send_tx_blob(&amp;blob_tx).await.unwrap();\nprintln!(\"\u2705 Blob tx sent. Tx hash: {}\", blob_tx_hash);\n</code></pre>"},{"location":"quickstart/example/first-token-contract/#prove-the-transaction","title":"Prove the transaction","text":"<p>Hyl\u00e9 transactions are settled in two steps, following pipelined proving principles. After this step, your transaction is sequenced, but not settled.</p> <p>For the transaction to be settled, it needs to be proven. You'll start with building the contract input, specifying:</p> <ul> <li>the initial state as set above</li> <li>the identity of the transaction initiator</li> <li>the transaction hash, which can be found in the explorer after sequencing</li> <li>information about the blobs.</li> <li>private input for proof generation in <code>private_blob</code></li> <li><code>blobs</code>: full list of blobs in the transaction (must match the blob transaction)</li> <li><code>index</code>: each blob of a transaction must be proven separately for now, so you need to specify the index of the blob you're proving.</li> </ul> <pre><code>// Build the contract input\nlet inputs = ContractInput::&lt;Token&gt; {\n    initial_state,\n    identity: from.clone().into(),\n    tx_hash: \"\".into(),\n    private_blob: sdk::BlobData(vec![]),\n    blobs: blobs.clone(),\n    index: sdk::BlobIndex(0),\n};\n\n// Generate the zk proof\nlet receipt = prove(cli.reproducible, inputs).unwrap();\n\nlet proof_tx = ProofTransaction {\n    blob_tx_hash,\n    proof: ProofData::Bytes(borsh::to_vec(&amp;receipt).expect(\"Unable to encode receipt\")),\n    contract_name: contract_name.clone().into(),\n};\n\n// Send the proof transaction\nlet proof_tx_hash = client\n    .send_tx_proof(&amp;proof_tx)\n    .await\n    .unwrap()\n    .text()\n    .await\n    .unwrap();\nprintln!(\"\u2705 Proof tx sent. Tx hash: {}\", proof_tx_hash);\n</code></pre> <p>Check the full annotated code in our GitHub example.</p>"},{"location":"quickstart/example/proof-composition/","title":"Proof composition with Ticket App","text":""},{"location":"quickstart/example/proof-composition/#proof-composition-with-ticket-app","title":"Proof composition with Ticket App","text":"<p>Hyl\u00e9 enables proof composition, allowing different proving systems to work within a single operation. This removes constraints on provers and significantly improves interoperability and efficiency.</p> <p>In this guide, we\u2019ll build a Ticket App that demonstrates proof composition. Users can buy a ticket using simple-token, and Hyl\u00e9 will verify multiple proofs in a single transaction.</p> <p>Find the source code for all contracts here:</p> <ul> <li>ticket-app</li> <li>simple-identity</li> <li>simple-token</li> </ul> <p>Traditional verification systems often require all proofs to be generated using the same proving system. Hyl\u00e9 removes this limitation, allowing:</p> <ul> <li>Interoperability: use different proof systems within a single transaction.</li> <li>Atomicity: either all proofs verify, or none do. This ensures fail-safe execution.</li> <li>Efficiency: parallel processing of proofs without requiring a single proving standard.</li> </ul>"},{"location":"quickstart/example/proof-composition/#how-this-example-works","title":"How this example works","text":"<p>In this example, <code>Alice</code> and <code>Bob</code> both want to buy a ticket from Ticket App for 15 <code>simple-tokens</code>. Bob has enough tokens to complete the transaction, while Alice does not.</p>"},{"location":"quickstart/example/proof-composition/#step-1-create-the-blob-transaction","title":"Step 1: Create the blob transaction","text":"<p>The Ticket App backend creates and sends a blob transaction to Hyl\u00e9, including three blobs:</p> <ul> <li>an identity blob (see our custom identity contract quickstart) confirming that Bob (<code>bob.id</code>) is initiating the transaction;</li> <li>a simple-token blob transferring 15 simple-tokens from <code>bob.id</code>'s balance;</li> <li>a ticket-app blob sending <code>bob.id</code> a ticket if conditions are met.</li> </ul> <p>At this stage, Hyl\u00e9 sequences the transaction, but it\u2019s not yet settled. Read more about pipelined proving.</p>"},{"location":"quickstart/example/proof-composition/#step-2-prove-the-blobs","title":"Step 2: Prove the blobs","text":"<p>The Ticket App backend generates ZK proofs of each blob.</p> <p>The <code>ticket-app</code> contract is executed, checking whether:</p> <ul> <li>A <code>simple-token</code> blob exists;</li> <li>The blob attempts to transfer 15 simple-tokens from <code>bob.id</code> to <code>ticket-app</code>.</li> </ul> <p>At this step, the contract does not verify whether Bob actually has enough tokens: if the token transfer fails in Step 3, the entire transaction fails.</p> <p>Check out the source code.</p>"},{"location":"quickstart/example/proof-composition/#step-3-settlement","title":"Step 3: Settlement","text":"<p>Once TicketApp has sent the proofs for the previously sequenced blobs, Hyl\u00e9 verifies:</p> <ul> <li>identity proof: verifies that <code>bob.id</code> has initiated the transaction.</li> <li>simple-token proof: verifies that <code>bob.id</code> paid the correct amount for his ticket.</li> <li>ticket-app proof: verifies that <code>bob.id</code> has received the ticket.</li> </ul> <p>If all proofs are valid, the simple-token balance and ticket-app ticket balance are updated simultaneously at transaction settlement: <code>bob.id</code> sends 15 simple-tokens and gains one ticket.</p> <p>If any proof fails, the entire transaction fails. Neither state is updated: Bob's token balance does not change and he doesn't get a ticket.</p>"},{"location":"quickstart/example/proof-composition/#run-the-example","title":"Run the example","text":"<p>Warning</p> <p>Our examples work on Hyl\u00e9 v0.12.1. Later versions introduce breaking changes which have not yet been reflected in our examples.</p>"},{"location":"quickstart/example/proof-composition/#prerequisites","title":"Prerequisites","text":"<ul> <li>Install Rust (you'll need <code>rustup</code> and Cargo).</li> <li>For our example, install RISC Zero.</li> <li>Start a single-node devnet.</li> </ul> <p>This quickstart guide will take you through the following steps:</p> <ul> <li>Simple-identity preparation: register an identity contract &amp; two identities.</li> <li>Simple-token preparation: register a token contract and faucet the users with this token.</li> <li>Register the ticket-app contract</li> <li>Buy a ticket on ticket-app</li> </ul>"},{"location":"quickstart/example/proof-composition/#simple-identity-preparation","title":"Simple-identity preparation","text":"<p>Let's start with registering an identity contract and two identities.</p> <p>Go to the <code>./simple-identity</code> folder and run:</p> <pre><code>cargo run -- --contract-name id register-contract\n</code></pre> <p>Now we have an identity contract called <code>id</code>. We can use it to declare our users:</p> <pre><code>cargo run -- --contract-name id register-identity bob.id pass\ncargo run -- --contract-name id register-identity alice.id pass\n</code></pre> <p>Let's verify it quickly with:</p> <pre><code>cargo run -- --contract-name id verify bob.id pass 0\n</code></pre> <p>0 is a nonce: every time we verify successfully bob's identity, it increments. Now if we want to verify it again, we should use 1 as nonce. (We also use \"pass\" as our default password.)</p> <p>We now do the same for alice:</p> <pre><code>cargo run -- --contract-name id verify alice.id pass 0\n</code></pre> <p><code>bob.id</code> is bob's identity on the simple-identity contract. Check out our Identity management and custom identity contract pages to know more.</p>"},{"location":"quickstart/example/proof-composition/#simple-token-preparation","title":"Simple-token preparation","text":""},{"location":"quickstart/example/proof-composition/#register-simple-token","title":"Register simple-token","text":"<p>Go to <code>./simple-token</code> folder and run:</p> <pre><code>cargo run -- --contract-name simple-token register 1000\n</code></pre> <p>On the node's logs, you will see:</p> <p>\ud83d\udcdd Registering new contract simple_token</p> <p>You just registered a token contract named simple-token with an initial supply of 1000.</p>"},{"location":"quickstart/example/proof-composition/#transfer-tokens","title":"Transfer tokens","text":"<p>Now let's transfer some tokens to our user <code>bob</code>.</p> <p>To send 50 tokens to <code>bob</code> and 10 tokens to <code>alice</code>, run:</p> <pre><code>cargo run -- -contract-name simple-token transfer faucet.simple-token bob.id 50\ncargo run -- -contract-name simple-token transfer faucet.simple-token alice.id 10\n</code></pre> <p>The node's log will show:</p> <p>INFO hyle::data_availability::node_state::verifiers: \u2705 Risc0 proof verified.</p> <p>INFO hyle::data_availability::node_state::verifiers: \ud83d\udd0e Program outputs: Transferred 50 to bob.ticket_app INFO hyle::data_availability::node_state::verifiers: \ud83d\udd0e Program outputs: Transferred 10 to alice.ticket_app</p>"},{"location":"quickstart/example/proof-composition/#check-onchain-balance","title":"Check onchain balance","text":"<p>Check onchain balance:</p> <pre><code>cargo run -- --contract-name simple-token balance faucet.simple-token\n\ncargo run -- --contract-name simple-token balance bob.id\ncargo run -- --contract-name simple-token balance alice.id\n</code></pre> <p>You should see that <code>bob</code> has a balance of 50 and <code>alice</code> has a balance of 10.</p>"},{"location":"quickstart/example/proof-composition/#using-ticket-app","title":"Using ticket-app","text":"<p>Now that <code>bob</code> has some tokens, let's buy him a ticket.</p>"},{"location":"quickstart/example/proof-composition/#register-ticket-app","title":"Register ticket-app","text":"<p>Register the ticket app by going to <code>./ticket-app</code> folder and running:</p> <pre><code>cargo run -- --contract-name ticket-app register simple-token 15\n</code></pre> <p>ticket-app sells bob a ticket for 15 simple-token.</p>"},{"location":"quickstart/example/proof-composition/#buy-a-ticket","title":"Buy a ticket","text":"<p>Let's buy a ticket for <code>bob</code>:</p> <pre><code>cargo run -- --contract-name ticket-app --user bob.id buy-ticket\n</code></pre> <p>Let's try with <code>alice</code>:</p> <pre><code>cargo run -- --contract-name ticket-app --user alice.id buy-ticket\n</code></pre> <p>You will get an error while executing the TicketApp program: <code>Execution failed ! Program output: Insufficient balance</code>. This is because Alice has a balance of 10 and the ticket costs 15.</p>"},{"location":"quickstart/example/proof-composition/#check-ticket-and-token-balance","title":"Check ticket and token balance","text":"<p>Check that <code>bob</code> has a ticket:</p> <pre><code>cargo run -- --contract-name ticket-app --user bob.id has-ticket\n</code></pre> <p>You can also check <code>bob</code>'s balance and see he now has 35 tokens.</p> <p>With proof composition, Hyl\u00e9 empowers you to leverage multiple proving systems in a single transaction, making advanced functionality like the Ticket App easier than ever.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#reference","title":"Reference","text":"<p>This section provides key reference materials related to Hyl\u00e9.</p>"},{"location":"reference/devnet/","title":"Devnet configuration","text":""},{"location":"reference/devnet/#devnet-configuration","title":"Devnet configuration","text":""},{"location":"reference/devnet/#recommended-run-from-source","title":"Recommended: Run from source","text":"<p>For a single-node devnet (consensus disabled) with an indexer, clone the hyle repository and run:</p> <pre><code>cargo run -- --pg\n</code></pre> <p>This command starts a temporary PostgreSQL server and erases its data when you stop the node.</p>"},{"location":"reference/devnet/#optional-persistent-storage","title":"Optional: Persistent storage","text":"<p>For persistent storage, start a standalone PostgreSQL instance:</p> <pre><code># Start PostgreSQL with default configuration:\ndocker run -d --rm --name pg_hyle -p 5432:5432 -e POSTGRES_PASSWORD=postgres postgres\n</code></pre> <p>Then, navigate to the Hyl\u00e9 root and run:</p> <pre><code>cargo run\n</code></pre>"},{"location":"reference/devnet/#alternative-start-with-docker","title":"Alternative: Start with Docker","text":"<p>Use Docker to run a local node. Note that the devnet is unstable and may break with future updates.</p>"},{"location":"reference/devnet/#pull-the-docker-image","title":"Pull the Docker image","text":"<pre><code>docker pull ghcr.io/hyle-org/hyle:v0.12.1\n</code></pre>"},{"location":"reference/devnet/#run-the-docker-container","title":"Run the Docker container","text":"<pre><code>docker run -v ./data:/hyle/data -p 4321:4321 ghcr.io/hyle-org/hyle:v0.12.1\n</code></pre> <p>If you run into an error, try adding the <code>--privileged</code> flag:</p> <pre><code>docker run --privileged -v ./data:/hyle/data -p 4321:4321 ghcr.io/hyle-org/hyle:v0.12.1\n</code></pre> <p>To run with an indexer, add the parameter <code>-e HYLE_RUN_INDEXER=true</code> and set up a running PostgreSQL server with Docker:</p> <pre><code>docker run -d --rm --name pg_hyle -p 5432:5432 -e POSTGRES_PASSWORD=postgres postgres\n</code></pre> <p>And the node linked to it:</p> <pre><code>docker run -v ./data:/hyle/data \\\n    -e HYLE_RUN_INDEXER=true \\\n    -e HYLE_DATABASE_URL=postgres://postgres:postgres@pg_hyle:5432/postgres \\\n    --link pg_hyle \\\n    -p 4321:4321 \\\n    ghcr.io/hyle-org/hyle:v0.7.2\n</code></pre> <p>You can now create your first smart contract.</p> <p>Tip</p> <p>To reset your devnet, delete the ./data folder and restart from Step 1. Otherwise, you risk re-registering a contract that still exists.</p>"},{"location":"reference/devnet/#alternative-build-the-docker-image-locally","title":"Alternative: Build the Docker image locally","text":"<p>If you prefer to build the image from source, run:</p> <pre><code>docker build -t Hyle-org/hyle . &amp;&amp; docker run -dit Hyle-org/hyle\n</code></pre>"},{"location":"reference/devnet/#configuration","title":"Configuration","text":"<p>You can configure your setup using environment variables or by editing a configuration file.</p>"},{"location":"reference/devnet/#using-environment-variables","title":"Using environment variables","text":"<p>All variables can be customized on your single-node instance.</p> Variable Default value Description HYLE_ID node Node identifier in the consensus. Usage subject to change in future releases. HYLE_SINGLE_NODE true Whether the network runs as a single node or with a multi-node consensus. HYLE_P2P_LISTEN true Mandatory (true) if multi-node consensus. The node should listen to new peers. HYLE_HOST 127.0.0.1:1231 Host &amp; port to listen for the P2P protocol. HYLE_PEERS [] List of peers to connect to at startup to follow a running consensus. HYLE_STORAGE__INTERVAL 10 unused HYLE_LOG_FORMAT full \u201cfull\u201d or \u201cjson\u201d HYLE_REST 127.0.0.1:4321 Host &amp; port for the REST API endpoint. HYLE_DATA_DIRECTORY data_node Directory name to store node state. HYLE_DATABASE_URL postgres://postgres:postgres @localhost:5432/postgres PostgreSQL server address (necessary if you want to use an indexer). HYLE_CONSENSUS__SLOT_DURATION 1000 Duration between blocks. HYLE_CONSENSUS__GENESIS_STAKERS {} Keys are all nodes \u201cid\u201d, and values are the stake amount for each one of them. Map of stakers for the genesis block. HYLE_P2P__PING_INTERVAL 10 Interval the p2p layer does a ping to check aliveness of other peers. HYLE_RUN_INDEXER true Whether there should be an indexer. HYLE_DA_ADDRESS 127.0.0.1:4141 Host &amp; port of the data availability module, which streams historical &amp; new blocks. It might be used by indexers."},{"location":"reference/devnet/#using-a-configuration-file","title":"Using a configuration file","text":"<p>To load settings from a file, place <code>config.ron</code> in your node's working directory. It will be detected automatically at startup.</p> <p>For Docker users, mount the config file when running the container:</p> <pre><code>docker run -v ./data:/hyle/data -v ./config.run:/hyle/config.ron -e HYLE_RUN_INDEXER=false -p 4321:4321 -p 1234:1234 ghcr.io/hyle-org/hyle:v0.12.1\ncp ./src/utils/conf_defaults.ron config.ron\n</code></pre> <p>For source users, copy the default config template:</p> <pre><code>cp ./src/utils/conf_defaults.ron config.ron\n</code></pre>"},{"location":"reference/node/","title":"Community validators","text":""},{"location":"reference/node/#community-validators","title":"Community validators","text":"<p>Community node support is not yet available, but we plan to introduce it in the future.</p>"},{"location":"reference/supported-proving-schemes/","title":"Supported proving schemes","text":""},{"location":"reference/supported-proving-schemes/#supported-proving-schemes","title":"Supported proving schemes","text":"<p>Clone a template or write your own program to get started with smart contract writing.</p> Proving scheme Verifier Program ID Template Noir noir Verification key. Risc0 risc0 Image ID without a prefix. ex. 0x123 becomes 123. Template SP1 sp1 Verification key. Template"},{"location":"resources/","title":"\ud83d\udcda Resources","text":""},{"location":"resources/#resources","title":"\ud83d\udcda Resources","text":"<ul> <li> <p> Roadmap</p> <p>Our upcoming launches.</p> <p> Roadmap</p> </li> <li> <p> Release notes</p> <p>See all release notes and migration guides in one place.</p> <p> Release notes</p> </li> <li> <p> Contribute</p> <p>Contribute to Hyl\u00e9 through hackathons and grants.</p> <p> Grants</p> </li> <li> <p> Glossary</p> <p>Understand our vocabulary</p> <p> Glossary</p> </li> <li> <p> Find us</p> <p>Find us on social media.</p> <p> Find us</p> </li> </ul>"},{"location":"resources/find-us/","title":"Find us","text":""},{"location":"resources/find-us/#useful-links","title":"Useful links","text":"<ul> <li> Rust node</li> <li> Example contracts</li> <li> Website</li> <li> Hyl\u00e9 blog</li> </ul>"},{"location":"resources/find-us/#contact-us","title":"Contact us","text":"<p>Reach out to the team for more information:</p>  Github  Twitter  Farcaster  LinkedIn  Youtube  Telegram Hyl\u00e9 @hyle_org @hyle-org Hyl\u00e9 @Hyl\u00e9 @hyle_org"},{"location":"resources/glossary/","title":"Glossary","text":""},{"location":"resources/glossary/#glossary","title":"Glossary","text":"Term Definition Related concept page base state The state of a smart contract before an operation occurs. Transactions blob A piece of provable information that is sent to Hyl\u00e9. Smart contracts blob transaction A transaction including a provable blob, used for sequencing. Pipelined proving cross-contract composition The ability to use and verify a contract's proofs in other contracts. Proof composition operation Something that happens on an unchained app. An operation includes two transactions: a blob transaction and a proof transaction. Transactions proof composition The process of combining multiple zero-knowledge proofs into a single proof, enabling efficient verification and interoperability across different proving systems. Proof composition proof transaction A transaction including a proof of a previously-submitted blob, used for verification and settlement. Transactions proof verification The act by which Hyl\u00e9 verifies submitted proofs before settling them onchain. Transactions timeout A time window after which, if no proof transaction has been submitted, an operation fails. Pipelined proving transaction A part of an operation that gets sent to Hyl\u00e9. There are two types of transactions: blob transactions and proof transactions. Transactions unchained app An app that runs offchain and settles onchain, giving it both the Web2 user experience and the security of Web3."},{"location":"resources/grants/","title":"Contribute to Hyl\u00e9","text":""},{"location":"resources/grants/#contribute-to-hyle","title":"Contribute to Hyl\u00e9","text":""},{"location":"resources/grants/#contribution-opportunities","title":"Contribution opportunities","text":"<p>You can contribute to Hyl\u00e9 in several ways. We are active participants in OnlyDust projects and welcome maintainers.</p> <p>You can also check out our Careers page for longer-term opportunities.</p>"},{"location":"resources/grants/#grant-program","title":"Grant program","text":"<p>We have a grant program supporting developers who want to work on trust infrastructure and programmable cryptography on Hyl\u00e9.</p>"},{"location":"resources/grants/#what-are-our-grants-like","title":"What are our grants like?","text":"<ul> <li>You apply with an original idea or an idea from the list on our repo.</li> <li>We fund your project. You get some money upfront, so you can build without financial worries, and the rest upon completion of the project.</li> <li>You meet regularly with our CEO for guidance and to help you refine your ideas.</li> <li>You are in a Telegram group with our other grantees to share ideas and solutions.</li> <li>Our tech team supports you via Telegram and in meetings.</li> <li>Our business team helps you showcase your idea through external speaking opportunities, co-marketing, and other assets.</li> </ul> <p>To read more, see our grant ideas, and apply, please go to our Grants page on the main Hyl\u00e9 repository. If you represent an organization, we'd love to discuss co-grants ideas.</p> <p>For questions that aren't answered on the Grants page, reach out in our Telegram group.</p>"},{"location":"resources/grants/#current-and-past-grants","title":"Current and past grants","text":"<p>Here are two past grants:</p> <ul> <li>Provable play-by-email games library</li> <li>Proof of residency app</li> </ul> <p>Find the full list on our Grants page on the main Hyl\u00e9 repository.</p>"},{"location":"resources/release-notes/","title":"Release notes","text":""},{"location":"resources/release-notes/#release-notes","title":"Release notes","text":"<p>Read our full changelogs on GitHub or the short versions in our Telegram group.</p>"},{"location":"resources/release-notes/#2025-02-24-v0120","title":"2025-02-24 \u2212 v0.12.0","text":"<p>\ud83d\uddde\ufe0f Our news:</p> <ul> <li>All examples have been updated to v0.11.0</li> <li>We\u2019ve added Metamask authentication to our demo AMM, Hyleoof. We\u2019re looking forward to making the demo fully public!</li> </ul> <p>\ud83d\udca5 Breaking changes:</p> <p>We heard your feedback on our frequent breaking changes. Going forward, we\u2019ll be making fewer releases, relying instead on <code>rc</code> versions, so that breaking changes are batched.</p> <ul> <li>Contract input now uses state instead of state digest, which simplifies the API.</li> <li>SP1 verifier is now a separate feature: this drastically shortens build time if you\u2019re not using it.</li> <li>We\u2019ve improved the general structure of smart contracts.</li> </ul> <p>\u2728 New features:</p> <ul> <li>We have a JS SDK now!</li> </ul> <p>\ud83d\ude85 Improvements:</p> <ul> <li>Added caching for computed hash, which doubles performance in heavy load situations</li> <li>Other big performance improvements for in-memory storage</li> </ul> <p>\ud83d\udee0\ufe0f No longer broken:</p> <ul> <li>Added missing data proposal hashes in blocks</li> <li>Fixed blob proof output index logic at settlement stage</li> </ul> <p>\ud83d\udcda Documentation:</p> <ul> <li>Added explanations to our proof composition concept page</li> </ul>"},{"location":"resources/release-notes/#2025-02-14-v0110","title":"2025-02-14 \u2212 v0.11.0","text":"<p>\u2728 New features:</p> <ul> <li>Added Mempool status event <code>data proposal created</code></li> <li>When a parent transaction times out, the timeout window for the child transactions is reset</li> </ul> <p>\ud83d\ude85 Improvements:</p> <ul> <li>Bumped risc0 from 1.2.2 to 1.2.3 and sp1 from 4.0.1 to 4.1.1</li> <li>Improved several logs, making them more specific or adding context to them, especially on error logs</li> <li>Improved storage to make it more compact</li> </ul> <p>\ud83d\udee0\ufe0f No longer broken:</p> <ul> <li>The Mempool status event <code>wait dissemination</code> now works for the first data proposal (genesis)</li> <li>The indexer client now gets blobs\u2019 endpoints</li> <li>Fixed the input encoding for the bonsai runner</li> </ul> <p>\ud83d\udcda Documentation:</p> <ul> <li>Revamped homepage and in-docs navigation</li> <li>Made some improvements for clarity to our pipelined proving concept page</li> <li>Added a page on proof generation and submission</li> </ul>"},{"location":"resources/release-notes/#2025-02-07-v0100","title":"2025-02-07 \u2212 v0.10.0","text":"<p>\ud83d\udca5 Breaking change: we\u2019ve replaced our serialization standard, bincode, with borsh. Encoding BlobData from JS didn\u2019t work properly with bincode: borsh offers better support and opens new possibilities!</p> <p>\u2728 New features:</p> <ul> <li>Introduced an indexer endpoint that adds events to BlobTXs: if your transaction didn\u2019t settle, you can now debug its flow much more easily!</li> <li>Introduced fees in ConsensusProposal. This has no external impact at this time.</li> <li>Added Mempool status event <code>waiting_dissemination</code></li> </ul> <p>\ud83d\udee0\ufe0f No longer broken:</p> <ul> <li>Hyllar Indexer now computes the correct caller in proof composition cases.</li> <li>Fixed a bug where the client couldn\u2019t close the websocket.</li> </ul>"},{"location":"resources/release-notes/#2025-02-03-v090","title":"2025-02-03 \u2212 v0.9.0","text":"<p>\ud83d\udca5 Breaking changes:</p> <ul> <li>Added transactions context (block, timestamp, \u2026) to proofs for more flexibility</li> </ul> <p>\u2728 New features:</p> <ul> <li>You can now start a node with an indexer and postgres database simply with <code>cargo run -- --pg</code></li> <li>Added an endpoint for contract registration</li> </ul> <p>\ud83d\ude85 Improvements:</p> <ul> <li>Updated risc0 to 1.2.2</li> <li>Made logging less spammy and more informative (incl. logging timeouts as info)</li> <li>Improved the transaction builder tool in the SDK</li> </ul> <p>\ud83d\udee0\ufe0f No longer broken:</p> <ul> <li>Contract state indexers are now fully saved upon restart</li> <li>Staking contracts now check that there is a <code>transfer</code> blob</li> <li>The Rust version enforced in cargo is less restrictive</li> </ul> <p>\ud83d\udcda Documentation:</p> <ul> <li>Updated our examples so they work with 0.9.0!</li> <li>Added OpenAPI documentation on contract state indexers</li> <li>Added a swagger for the node and its indexer</li> </ul> <p>Quick note: release notes will be published on Fridays instead of Mondays from now on. See you in just a few days!</p>"},{"location":"resources/release-notes/#2025-01-27-v080","title":"2025-01-27 \u2212 v0.8.0","text":"<p>\ud83d\udca5 Breaking changes:</p> <ul> <li>Hyle-contracts: Merged the contracts \u2018metadata\u2019 feature into \u2018client\u2019</li> <li>There are no more <code>RegisterContract</code> transactions: contracts are now registered with <code>BlobTransactions</code>, like everything else.</li> <li>Contract registration has been reworked using proof outputs; we introduced UUID contract names (see uuid-tld for an example).</li> <li>Removed <code>hyled</code> and <code>hyrun</code>. If you were using them, check out our SDK instead.</li> </ul> <p>\u2728New features:</p> <ul> <li>You can now settle transactions that have a proof of failure before they timeout</li> <li>Made progress on the implementation of our consensus</li> </ul> <p>\ud83d\ude85 Improvements:</p> <ul> <li>We now enforce a recent Rust version to avoid errors.</li> </ul> <p>\ud83d\udee0\ufe0f No longer broken:</p> <ul> <li>Bug fixes include Dockerfile, environment variables, and identities.</li> </ul> <p>\ud83d\udcda Documentation:</p> <ul> <li>Our SDK has a README now!</li> </ul> <p>Read the full changelog on GitHub.</p>"},{"location":"resources/release-notes/#2025-01-21-v071-v072","title":"2025-01-21 \u2212 v0.7.1 &amp; v0.7.2","text":"<p>Small patches for our SDK.</p> <p>Read release notes for v0.7.1 and v0.7.2; see new SDK readme for more info.</p>"},{"location":"resources/release-notes/#2025-01-20-v070","title":"2025-01-20 \u2212 v0.7.0","text":"<p>\ud83d\udca5 Breaking changes:</p> <ul> <li>We completely rewrote the dependencies for the SDK.</li> </ul> <p>\u2728 New features;</p> <ul> <li>Adding support of native verifiers. Verify hash signatures, TEE executions without needing a ZK proof! Currently supported: sha3_256 &amp; BLST signatures.</li> <li>You can now use <code>tx hash</code> inside contracts</li> </ul> <p>\ud83d\ude85 Improvements:</p> <ul> <li>Several performance improvements following our latest loadtest</li> <li>Reduce log verbosity and frequency</li> <li>Dependencies: updated risc0-zkvm to 1.2.1, sp1-sdk to 4.0.0</li> </ul> <p>\ud83d\udee0\ufe0f No longer broken:</p> <ul> <li>Loads of bug fixes \u2212 check the full release to know more.</li> </ul> <p>\ud83d\udcda Documentation:</p> <ul> <li>Transactions on Hyl\u00e9</li> <li>Identity management</li> </ul> <p>Read the full changelog on GitHub and receive future release notes in our Telegram group.</p>"},{"location":"resources/release-notes/#2025-01-13-v060","title":"2025-01-13 \u2212 v0.6.0","text":"<p>\u2728 New features:</p> <ul> <li>Added the SP1 prover to the client SDK.</li> </ul> <p>\ud83d\ude85 Improvements:</p> <ul> <li>Upgraded to SP1 4.0.0-rc8.</li> </ul> <p>\ud83d\udee0\ufe0f No longer broken:</p> <ul> <li>Fixed the default configurations.</li> <li>Fixed loading state when restarting a node.</li> </ul> <p>\ud83d\udcda Documentation:</p> <ul> <li>Rewrote our Quickstart guide.</li> </ul> <p>Read the full changelog on GitHub and receive future release notes in our Telegram group.</p>"},{"location":"resources/roadmap/","title":"Roadmap","text":""},{"location":"resources/roadmap/#testnet","title":"Testnet","text":"<p>We are on our way to launch a private testnet in Q2 2025, which will be followed by a public testnet.</p> <p>Stay tuned for updates or ask specific questions in our Telegram group.</p> <p>While we\u2019re working, you can get hands-on right now:</p> <ul> <li>Explore our public devnet or spin up your own instance to start building today!</li> <li>Read our release notes for the devnet.</li> <li>If you are an individual, join us for ODBoost weeks.</li> </ul>"},{"location":"resources/roadmap/#proving-schemes","title":"Proving schemes","text":"<p>Check the list of the proving schemes we currently support and the ones we'll work on next.</p>"},{"location":"tooling/","title":"\ud83e\uddf0 Tooling","text":""},{"location":"tooling/#tooling","title":"Tooling","text":"<p>Here, you'll find our resources about Hyl\u00e9's tooling.</p> <ul> <li> <p> SDK</p> <p>Use the helper functions in our contract SDK.</p> <p> Read more</p> </li> <li> <p> Explorer</p> <p>Understand and use the Hyl\u00e9 explorer.</p> <p> Read more</p> </li> </ul>"},{"location":"tooling/explorer/","title":"Explorer","text":"<p>Hyl\u00e9ou (a French pun for \"Il est o\u00f9\" or \"Where is it?\") is the blockchain explorer for the Hyl\u00e9 ecosystem.</p> <p>The explorer is live at hyleou.hyle.eu.  </p> <p>The source code is available on GitHub. We welcome PRs and issues!</p>"},{"location":"tooling/explorer/#features","title":"Features","text":"<p>All features are in active development. </p>"},{"location":"tooling/explorer/#live-features","title":"Live features","text":"<p>Currently, you can:</p> <ul> <li>View the latest blocks</li> <li>View the latest transactions.</li> <li>View detailed information about specific blocks and transactions.</li> <li>Fetch a .json state for the <code>hyllar</code> and <code>hydentity</code> contracts.</li> </ul>"},{"location":"tooling/explorer/#upcoming-features","title":"Upcoming features","text":"<p>Planned features include:</p> <ul> <li>Register new contracts.</li> <li>Send transactions by uploading ZK proofs to specific contracts.</li> </ul>"},{"location":"tooling/sdk/","title":"SDK","text":""},{"location":"tooling/sdk/#sdk","title":"SDK","text":"<p>Our contract SDK includes helper functions for building a smart contract on Hyl\u00e9.</p> <p>Read more: SDK README.</p>"}]}