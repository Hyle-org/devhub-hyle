{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Hyl\u00e9 developer docs","text":"<p>This developer portal and the project itself are still in early development. Reach out to us on Telegram if you need anything that isn't here or find outdated information.</p> <p>Hyl\u00e9  is a lean blockchain that helps you build provable applications that are minimally, yet sufficiently, onchain.</p> <p>We focus on native verification of zero-knowledge proofs.</p> <ul> <li>Native zero-knowledge proof verification on our sovereign L1.</li> <li>No onchain execution or virtual machine: only efficient proof verification.</li> <li>Run complex logic in your smart contracts thanks to off-chain execution.</li> <li>Leverage pipelined proving and bring proof generation outside of your app's critical path.</li> <li>Choose your proving scheme and your language: we verify all proofs.</li> <li>Composable cross-contract calls, reaching abstraction levels comparable to shared execution. You'll never need to recursively verify a proof again!</li> </ul>"},{"location":"#how-does-hyle-work","title":"How does Hyl\u00e9 work?","text":"<p>Here\u2019s what happens when you use Hyl\u00e9\u2019s sovereign verification-focused Layer 1:</p> <ol> <li>No need for a verifier contract: just call the native function.</li> <li>Proof generation: off-chain, the prover generates a zero-knowledge proof of a specific computation.</li> <li>Proof submission: the prover sends the proof(s) and the results of the computation to Hyl\u00e9's Layer 1 as part of a transaction. If there are several proofs, that's not a problem: we offer proof composability.</li> <li>Pipelined proving: the state is updated temporarily to remove proving time from your app's critical path. Read more on our blog.</li> <li>Verification: Hyl\u00e9 validators receive the transaction. They use the native verification programs to check the validity of the proof as fast as possible, without being limited by the bulky virtual machine.</li> <li>Consensus and block inclusion: if the proof is valid, the block producer puts the results of the computation on the Hyl\u00e9 blockchain and the state is updated onchain.</li> </ol> <p>And that\u2019s it.</p> <p></p> <p>With this system, execution and storage happen anywhere you like, without cost barriers. You only need a fast and trustworthy verifier: that\u2019s Hyl\u00e9.</p>"},{"location":"#getting-started","title":"Getting started","text":"<ol> <li>Run your own devnet or Connect to the public devnet</li> <li>Learn how to create your first smart contract</li> </ol>"},{"location":"#useful-links","title":"Useful links","text":"<ul> <li>Rust WIP node</li> <li>Hyle.eu</li> <li>Hyl\u00e9 blog</li> </ul>"},{"location":"#contact-us","title":"Contact us","text":"<p>Feel free to reach out to the team for more information:</p> <ul> <li> Github: Hyl\u00e9</li> <li> Twitter: @hyle_org</li> <li> Farcaster: @hyle-org</li> <li> LinkedIn: Hyl\u00e9</li> <li> Youtube: @Hyl\u00e9</li> <li> Telegram: @hyle_org</li> </ul>"},{"location":"developers/","title":"Developer documentation","text":"<p>Welcome to the developer documentation for Hyl\u00e9. In this section you will find all the information you need to start building on Hyl\u00e9, as well as general information about the project.</p> <p>The general technical details are in the General documentation.</p>"},{"location":"developers/examples/","title":"Detailed examples","text":"<p>Here, we show a few detailed examples of Hyl\u00e9 applications.</p> <ul> <li>Vibe Check</li> </ul> <p>Our grantees also have projects to talk about:</p> <ul> <li>Provable play-by-email games engine &amp; zkChess</li> </ul> <p>You should also check out our partners.</p>"},{"location":"developers/examples/collatz-example-in-depth/","title":"Collatz example in depth","text":"<p>Hyl\u00e9 smart contracts can be written in any language that targets one of our supported proving schemes. To provide a simple example, we'll use the RISC Zero Collatz Conjecture program, which can be found here.</p> <p>The Collatz Conjecture is a simple mathematical problem that can be expressed as a program. The conjecture states that, for any positive integer <code>n</code>:</p> <ul> <li>if <code>n</code> is even, divide it by 2</li> <li>if <code>n</code> is odd, multiply it by 3 and add 1</li> <li>repeat this process, and you will eventually reach 1.</li> </ul> <p>The program is implemented in rust, and compiles to the RISC Zero ZkVM.</p>"},{"location":"developers/examples/collatz-example-in-depth/#compiling-the-program","title":"Compiling the program","text":"<p>To compile the program, you will need to have the RISC Zero toolchain installed. Follow the official instructions to get the most up-to-date information.</p> <p>Once that is done, you should be able to run <code>cargo build</code>.</p>"},{"location":"developers/examples/collatz-example-in-depth/#running-the-collatz-conjecture-program","title":"Running the Collatz Conjecture program","text":"<p>Hyl\u00e9 smart contracts can be executed client-side, enabling strong decentralisation and permissionlessness. Executing the smart contract is thus as simple as running the program with the correct inputs.</p> <pre><code># Compute a proof of a transition between the number 12 and 6\ncargo run next 12\n\n# Compute a proof of a transition between the number 17 and 52\ncargo run next 17\n\n# Compute a proof where the state of the contract is assumed to be 1, and the state should be reset to 31\ncargo run reset 31\n</code></pre> <p>Every time, a <code>proof.json</code> file containing the receipt will be generated. You can use this proof, along with the inputs, to trigger state transitions on Hyl\u00e9 (see Your first smart contract for more details).</p>"},{"location":"developers/examples/collatz-example-in-depth/#invalid-transitions","title":"Invalid transitions","text":"<p>The Collatz smart contract demonstrates how the code of the smart contract enforces constraints on the state. For example, you cannot generate valid proofs of transition between numbers that are not part of the Collatz sequence. The contract will also reject attempts to reset to 0, as there would no longer be any next state.</p>"},{"location":"developers/examples/vibe-check/","title":"Vibe Check","text":"<p>The general idea of the Vibe Check app is to give people a SmileToken to reward them for smiling. </p> <p>Watch Sylve's demo at ETHCC[7].</p> <p>Find the code in the dedicated GitHub repository.</p>"},{"location":"developers/examples/vibe-check/#context","title":"Context","text":"<p>The step-by-step process:</p> <ol> <li>I identify myself.<ol> <li>I use WebAuthn, with a Yubikey on a computer, a fingerprint on a phone, or any other accepted device.</li> <li>Vibe Check runs the Noir prover in-browser.</li> <li>The prover generates a Noir proof that the webauthn-signature is correct.</li> </ol> </li> <li>I take a selfie where I\u2019m smiling to generate a proof of my shiny, bubbly personality.<ol> <li>Vibe Check uses a machine-learning model that the Hyl\u00e9 team has transformed into a Cairo program using Giza's transpiler.</li> <li>I send my selfie to this Cairo program, which runs on a virtual machine.</li> <li>The machine-learning model checks that I am smiling.</li> <li>If I am smiling, the Cairo-prover generates a proof.</li> </ol> </li> <li>Vibe Check gives me a SmileToken.<ol> <li>Vibe Check locally updates the state of the SmileToken.</li> <li>Vibe Check generates a Cairo proof that the state transition was done correctly.</li> </ol> </li> <li>Hyl\u00e9 verifies the proofs.<ol> <li>Hyl\u00e9 updates the SmileToken state if everything is correct. If so, I am rewarded with that SmileToken to congratulate me for my good vibes.</li> <li>Since Hyl\u00e9\u2019s state is checkpointed on different networks, I could get that token on any bridged network like Starknet or even Ethereum.</li> </ol> </li> </ol>"},{"location":"developers/examples/vibe-check/#how-it-works","title":"How it works","text":""},{"location":"developers/examples/vibe-check/#understanding-the-components-of-the-demo","title":"Understanding the components of the demo","text":"<p>The Vibe Check demo consists of three components: the app, the proof generators, and the Hyl\u00e9 node.</p> <p>The app helps the user craft a transaction through 2 interactions:</p> <ul> <li>Identification with WebAuthn for a proof of ID</li> <li>Photo of the user smiling for a proof of smile</li> </ul> <p>The app sends these inputs to the proof generators.</p> <p>The proof generators execute programs and generate proofs.</p> <p>They can be run locally in the browser or remotely to maximize performance. Local proof generation is possible by compiling the Cairo VM/Cairo Prover/Noir Prover into WASM, but it is inefficient. Proving is a memory-consuming activity, and browsers usually have a low limit.</p> <p>The proof generators generate three proofs:</p> <ol> <li>Proof of ID: verification of the WebAuthn ECDSA signature in Noir</li> <li>Proof of smile: running the machine-learning model in Cairo</li> <li>Token (ERC-20) transfer: initiated in Cairo if the first two proofs are valid.</li> </ol> <p>The app sends the three proofs through one single transaction to the Hyl\u00e9 node.</p> <p>The Hyl\u00e9 node:</p> <ol> <li>Unpacks the three proofs.</li> <li>Verifies each proof with the correct verifier: Noir for WebAuthn and Cairo for the two others.</li> <li>Ensures consistency by checking the public data contained in the proofs to ensure they all relate to the same transaction.</li> </ol> <p></p>"},{"location":"developers/examples/vibe-check/#multiple-proving-schemes","title":"Multiple proving schemes","text":"<p>A proving scheme is a protocol or framework for generating proofs and verifying them.</p> <p>In Vibe Check, we use Noir and Cairo.</p> <p>We use Noir to generate ECDSA proofs. Its Typescript SDK makes it easy to integrate into an app.</p> <p>We use Cairo for two proofs:</p> <ul> <li>That there is a smile on the screenshot</li> <li>The coin transfer, with an ERC-20 specification.</li> </ul> <p>We used the LambdaClass CairoVM. Because of the current dependency mismatches between the prover and the runner, the Cairo prover and the Cairo runner had to be compiled separately.</p>"},{"location":"developers/examples/vibe-check/#using-giza-for-zkml","title":"Using Giza for zkML","text":"<p>ZkML is one of ZK's many use cases. It helps you assert that a prediction's result was obtained with the right model, trained on the right dataset, and fed with the right input.</p> <p>Giza focuses on helping developers create a provable machine-learning model.</p> <p>Here is the flow we followed:</p> <ol> <li>We used a simple classifier from the XGBoost library in Python, which Giza fully supports. </li> <li>We serialized our model in json thanks to the Giza SDK.</li> <li>We used the Giza API to turn our model into a Cairo program.</li> <li>We compiled the Cairo ML into Sierra using <code>scarb</code></li> <li>We executed our model in the Cairo VM we were using.</li> </ol> <p>Deep learning models, especially CNNs, would typically be more appropriate for image recognition, but some primitives used by those are not yet supported. Larger models are also extremely hard to run in a Cairo VM because of their high memory requirements.</p>"},{"location":"developers/examples/vibe-check/#the-actual-code","title":"The actual code","text":"<p>Find the code in the dedicated GitHub repository!</p>"},{"location":"developers/explorer/","title":"Hyl\u00e9ou - Blockchain Explorer for Hyl\u00e9","text":"<p>Hyl\u00e9ou (a French pun for \"Il est o\u00f9\" or \"Where is it?\") is the blockchain explorer for the Hyl\u00e9 ecosystem.</p> <p>The explorer is live at hyleou.hyle.eu.  </p> <p>The source code is available on GitHub. We welcome PRs and issues!</p>"},{"location":"developers/explorer/#features","title":"Features","text":"<p>All features are in active development. </p>"},{"location":"developers/explorer/#live-features","title":"Live features","text":"<p>Currently, you can:</p> <ul> <li>View the latest blocks</li> <li>View the latest transactions.</li> </ul>"},{"location":"developers/explorer/#upcoming-features","title":"Upcoming features","text":"<p>Planned features include:</p> <ul> <li>View detailed information about specific blocks and transactions.</li> <li>Register new contracts.</li> <li>Send transactions by uploading ZK proofs to specific contracts (multicall not yet supported).</li> </ul>"},{"location":"developers/general-doc/","title":"General documentation","text":"<p>Welcome to the developer documentation for Hyl\u00e9.</p> <p>You can also refer to our Getting Started step-by-step guide.</p>"},{"location":"developers/general-doc/anatomy-smart-contracts/","title":"What does a smart contract look like?","text":"<p>Hyl\u00e9 is a fully programmable blockchain. We only store the minimal amount of data required to validate smart contract proofs, so our smart contracts have very little information.</p> <p>Hyl\u00e9 smart contracts include:</p> <ul> <li>a name</li> <li>a program identifier</li> <li>a state commitment.</li> </ul>"},{"location":"developers/general-doc/anatomy-smart-contracts/#name","title":"Name","text":"<p>The name of your contract.</p>"},{"location":"developers/general-doc/anatomy-smart-contracts/#program-identifier","title":"Program Identifier","text":"<p>Smart contracts in Hyl\u00e9 are identified by a zero-knowledge proof scheme and a matching identifier. This tuple is required to verify proofs.</p> <ul> <li>Cairo: Cairo smart contracts will be identified by their Class Hash in the future.</li> <li>Noir: Noir smart contracts are identified by they verifying key.</li> <li>Risc Zero: Risc Zero smart contracts are identified by their <code>image ID</code>. Two identical programs will have identical image IDs.</li> <li>Groth16: Groth16 programs require a trusted ceremony. As such, their identifier is the verifying key corresponding to the matching private key, which will be unique for each program &amp; ceremony.</li> </ul>"},{"location":"developers/general-doc/anatomy-smart-contracts/#state-commitment","title":"State Commitment","text":"<p>The state commitment is intended to be the minimal amount of data required to attest to the full state of the smart contract.  </p> <p>Some example of such structures include:</p> <ul> <li>The full state, for a sufficiently small program (e.g. a fibonacci counter, or a smart-contract with a nonce)</li> <li>A merkle root of the state, for larger programs</li> <li>A hash of the full state could also be used</li> </ul>"},{"location":"developers/general-doc/data-availability/","title":"Data Availability","text":"<p>Hyl\u00e9 provides self-sufficient permissionless data availability, but not necessarily data retrievability.</p>"},{"location":"developers/general-doc/data-availability/#how-hyle-avoids-the-data-availability-problem","title":"How Hyl\u00e9 avoids the data availability problem","text":"<p>Hyl\u00e9 is a layer one blockchain, and will be decentralised in the future. As such, all validators and full nodes must have access to all data required to accept new blocks. There is therefore no data availability problem for Hyl\u00e9 full nodes.</p> <p>They must however access the full proofs inside each block. Thankfully, because our proofs are proofs of state commitment transitions, they are rather lightweight by themselves.</p>"},{"location":"developers/general-doc/data-availability/#permissionless-da-for-smart-contracts","title":"Permissionless DA for smart contracts","text":"<p>Because the protocol only requires proofs of the transitions between state commitments, the full state-diff may be hidden. This is by design and enables privacy. </p> <p>For smart contracts that intend to be permissionless, this can lead to DOS. In this case, the program must force the proof to contain the full state-diff.</p> <p>If the proof contains the full state-diff, valid transactions sent to Hyl\u00e9 contain it too and external indexers are able to reconstruct the full state.</p> <p>This solves the data availability problem, assuming that transaction data is available long enough for any honest indexer to reconstruct the full state. </p> <p>Our plan is to provide between 7 and 28 days of guaranteed DA, like Ethereum blobs.</p>"},{"location":"developers/general-doc/data-availability/#data-retrievability","title":"Data retrievability","text":"<p>Historical data is not provided by the protocol, as it is unnecessary to create new blocks. </p> <p>Starting a new node from scratch or reading past transactions for events may still be useful at times. To that end, Hyl\u00e9 nodes can be archive nodes which store the full state of the blockchain, including transactions, from the genesis block.</p> <p>Our current plan is that Hyl\u00e9 will provide a full archive node.</p>"},{"location":"developers/general-doc/data-availability/#proving-past-blocks","title":"Proving past blocks","text":"<p>Ethereum provides no native way to easily verify whether a given block belongs to the chain. This prevents leveraging historical data in smart contracts.</p> <p>Hyl\u00e9 blocks will, in the long term, contain the root of a merkle-mountain-range of all past blocks, allowing the generation of inclusion proofs of past blocks.</p>"},{"location":"developers/general-doc/smart-contract-abi/","title":"Smart Contract ABI","text":"<p>Hyl\u00e9 focuses on verifying zk-proofs. Because of this, writing smart contracts on Hyl\u00e9 has some specificities, with other elements being the same as with most other blockchains.</p> <p>Depending on the type of zk-proof circuits you use, there are some superficial differences, but the overall idea is that all inputs are known at proof generation time. This includes unusual elements such as the origin of the transaction (<code>tx.origin</code> in Ethereum) and the block number.</p> <p>The Hyl\u00e9 protocol enforces several invariants on transactions to maximize security. For this reason, we must specify some of the data within a zero-knowledge proof.</p> <p>This page uses the Rust structures to demonstrate, but you can use the following repos for other languages:</p> <ul> <li>Rust example: https://github.com/Hyle-org/collatz-conjecture</li> <li>Gnark / Groth16 example (outdated): https://github.com/Hyle-org/groth16-example</li> </ul>"},{"location":"developers/general-doc/smart-contract-abi/#overview","title":"Overview","text":"<p>Here is the rust struct specifying the output of a Hyl\u00e9 smart contract:</p> <pre><code>pub struct HyleOutput&lt;T&gt; {\n    pub version: u32,\n    pub initial_state: Vec&lt;u8&gt;,\n    pub next_state: Vec&lt;u8&gt;,\n    pub identity: String,\n    pub tx_hash: Vec&lt;u8&gt;,\n    pub payload_hash: Vec&lt;u8&gt;,\n    pub success: bool,\n    pub program_outputs: T\n}\n</code></pre> <p>The <code>version</code> field should currently be set to 1.</p>"},{"location":"developers/general-doc/smart-contract-abi/#initial-state-and-next-state","title":"Initial State and Next State","text":"<p>Blockchains transactions are fundamentally state transitions. These fields handle the state transitions securely in the protocol.</p> <p>The <code>initial_state</code> field should match the state digest of the contract before the transaction. This could consist of several things, such as:</p> <ul> <li>the hash of the previous state</li> <li>the Merkle root of the previous state tree</li> <li>the state itself if it's small enough</li> </ul> <p>The protocol enforces that this <code>initial_state</code> matches the onchain <code>state_digest</code> it knows. Otherwise, the state transition is invalid.</p> <p>The <code>next_state</code> field represents the new onchain <code>state_digest</code> after the transaction.</p> <p>Smart contracts can adapt the actual structure of this field. In the future, fees will depend on the size of the <code>state_digest</code> (among other criteria), so we encourage you to keep it small.</p>"},{"location":"developers/general-doc/smart-contract-abi/#identity","title":"Identity","text":"<p>The <code>identity</code> field is the identifier of the person who initiated the transaction.</p> <p>Unlike other blockchains, Hyl\u00e9 does not have a native signature type. Instead, Hyl\u00e9 uses the <code>identity</code> field of the first proof to identify the TX sender. To ensure security, the field is composite and ends with the name of the contract that the proof was generated for.</p> <p>Hyl\u00e9 could for example support Ethereum EOAs, if a smart contract is registered onchain to verify them. The <code>identity</code> would then look something like <code>0x1234...5678.eth_eoa</code>, where <code>eth_eoa</code> is the name of the contract, and the first part matches a regular Ethereum address.</p> <p>This gives us massive flexibility in the future to support any kind of identity verification, including WebAuthn, social media accounts, etc.</p> <p>For now, any subsequent proof in a TX must declare the same <code>identity</code> or an empty one, or the transaction will be rejected.</p>"},{"location":"developers/general-doc/smart-contract-abi/#tx-hash","title":"TX Hash","text":"<p>The <code>tx_hash</code> field is intended to hash transaction data, preventing replay attacks and providing a means for contracts to access this information.</p> <p>The field is currently completely unspecified and isn't validated by the protocol.</p>"},{"location":"developers/general-doc/smart-contract-abi/#payload-hash","title":"Payload Hash","text":"<p>This should match the hash of the payload that was sent to the network initially. Currently we use pedersen hashing for Cairo, no hashing for Risc0. Others are unimplemented. This is very WIP (as of August 2024) and will change soon.</p>"},{"location":"developers/general-doc/smart-contract-abi/#success","title":"Success","text":"<p>This is a boolean - whether the proof is for a succesful proof or a failure case. It can be useful to prove that a transaction is invalid. See our example in Vibe Check.</p>"},{"location":"developers/general-doc/smart-contract-abi/#other-program-specific-outputs","title":"Other program-specific outputs","text":"<p>Smart contracts can provide other outputs as part of the proof they generate.</p> <p>This can be used for a variety of purposes, but mostly serves to provide Data Availability. See Data Availability for more information.</p>"},{"location":"developers/general-doc/smart-contract-abi/#events","title":"Events","text":"<p>Hyl\u00e9 does not currently ship native events. We are looking into implementing them in the near future.</p>"},{"location":"developers/general-doc/supported-proving-schemes/","title":"Supported Proving Schemes","text":"<p>Hyl\u00e9 currently supports the following zero-knowledge proving schemes:</p> <ul> <li>Risc0</li> <li>Groth16 (over BN254; others can be implemented manually)</li> <li>Cairo via Stark Platinum (partial support)</li> <li>Noir via Barretenberg</li> </ul>"},{"location":"developers/general-doc/supported-proving-schemes/#planned-future-support","title":"Planned Future Support","text":"<p>We plan to eventually support all major proving schemes.</p> <p>The next proving schemes we're aiming to support are:</p> <ul> <li>Full support of Cairo including via Stwo</li> <li>SP1 </li> <li>PlonK</li> </ul>"},{"location":"developers/using-the-cli/","title":"Getting Started","text":"<p>Welcome to the Getting Started guide for Hyl\u00e9. This page will help you configure your environment and start using Hyl\u00e9.</p> <p>Use the sidebar to navigate through the guide, or click on the links below to jump to a specific section:</p> <ol> <li>Run your own devnet or Connect to the public devnet</li> <li>Interact with a node</li> <li>Create your first smart contract<ol> <li>Get inspiration from our in-depth Collatz example</li> <li>Understand Hyl\u00e9's smart contract ABI</li> </ol> </li> </ol>"},{"location":"developers/using-the-cli/connect-to-devnet/","title":"Connect to the public devnet","text":"<p>Hyl\u00e9 provides a public devnet where you can test your applications. Please message us to gain access!</p> <p>In the meantime, you can run your own devnet.</p>"},{"location":"developers/using-the-cli/connect-to-devnet/#urls","title":"URLs","text":"<ul> <li>Explorer: https://hyleou.hyle.eu/</li> </ul>"},{"location":"developers/using-the-cli/install-cli/","title":"Install cli","text":""},{"location":"developers/using-the-cli/install-cli/#interact-with-node","title":"Interact with node","text":"<p>To interact with the node, you can use the cli <code>hyled</code>:</p> <pre><code>cargo run --bin hyled -- --help\n</code></pre> <p>You can install it for easy access: </p> <pre><code>cargo install --path . --bin hyled\nhyled --help\n</code></pre>"},{"location":"developers/using-the-cli/run-devnet/","title":"Run your own devnet","text":""},{"location":"developers/using-the-cli/run-devnet/#getting-started-with-cargo","title":"Getting Started with Cargo","text":"<p>To start a single-node devnet (with consensus disabled), which is useful to build &amp; debug smart contracts, run:</p> <pre><code>cargo build\nHYLE_RUN_INDEXER=false cargo run --bin node\n</code></pre> <p>If you want to run with an indexer, you will need a running PostgreSQL server. You can set it up with Docker:</p> <pre><code># For default conf:\ndocker run -d --rm --name pg_hyle -p 5432:5432 -e POSTGRES_PASSWORD=postgres postgres\n</code></pre>"},{"location":"developers/using-the-cli/run-devnet/#configuration","title":"Configuration","text":"<p>You can configure your setup using environment variables or by editing a configuration file.</p>"},{"location":"developers/using-the-cli/run-devnet/#using-a-configuration-file","title":"Using a configuration file","text":"<p>To use a configuration file, copy the default settings where you run the node. If a file named config.ron is present, it will be automatically loaded by the node at startup.</p> <pre><code># Copy default config where you run the node. If file named \"config.ron\" is present, it will be loaded by node at startup.\ncp ./src/utils/conf_defaults.ron config.ron\n</code></pre>"},{"location":"developers/using-the-cli/run-devnet/#using-a-configuration-file_1","title":"Using a configuration file","text":"<p>Here's an example of how you can configure your setup using environment variables:</p> <pre><code>HYLE_RUN_INDEXER=false \nHYLE_CONSENSUS__SLOT_DURATION=100\n</code></pre>"},{"location":"developers/using-the-cli/run-devnet/#getting-started-with-docker","title":"Getting Started with Docker","text":""},{"location":"developers/using-the-cli/run-devnet/#build-the-docker-image-locally","title":"Build the Docker image locally","text":"<p>To build the Docker image locally, use:</p> <pre><code>  docker build . -t hyle\n</code></pre>"},{"location":"developers/using-the-cli/run-devnet/#run-locally-with-docker","title":"Run locally with Docker","text":"<p>To run the Hyl\u00e9 node with Docker, use the following command:</p> <pre><code>  docker run -v ./db:/hyle/data -e HYLE_RUN_INDEXER=false -p 4321:4321 -p 1234:1234 hyle\n</code></pre> <p>If you encounter permission errors when accessing the /hyle/data volume, try adding the \"--privileged\" cli flag to the Docker command.</p>"},{"location":"developers/using-the-cli/your-first-smart-contract/","title":"Your first smart contract","text":"<p>The Hyl\u00e9 API is currently a basic proof of concept. Everything here will change and improve.</p>"},{"location":"developers/using-the-cli/your-first-smart-contract/#coding-your-smart-contract","title":"Coding your smart contract","text":"<p>You can use any zkVM or proving scheme supported by Hyl\u00e9.</p> <p>For this example, we'll assume you're using the RISC Zero Collatz Conjecture program. See the Collatz example in depth page for more details.</p>"},{"location":"developers/using-the-cli/your-first-smart-contract/#installing-the-hyle-cli-tool","title":"Installing the Hyl\u00e9 CLI tool","text":"<p>In this example, we'll show you how to use the CLI to register and interact with your smart contract. It's likely easier and faster to use our explorer, Hyl\u00e9ou.</p> <p>To begin, follow the CLI installation instructions.</p>"},{"location":"developers/using-the-cli/your-first-smart-contract/#registering-your-smart-contract","title":"Registering your smart contract","text":"<p>Hyl\u00e9 smart contracts are made of:</p> <ul> <li>a name, which must be unique</li> <li>a tuple of (verifier, program_id) which identifies the smart contract. The <code>verifier</code> is the proof system (e.g. \"risczero\" or \"gnark-groth16-te-BN254\"), and the <code>program_id</code> is the unique identifier of the program in that proof system, either the image ID in risczero of the verifying key in groth16 circuits.</li> <li>a state digest, holding the current state commitment of the contract. This can be any type of state commitment you want, and can currently be any size you want (this will have fee implications in the future).</li> </ul> <p>Read more about anatomy of smart contracts on Hyl\u00e9</p> <p>To register a contract on-chain, run the following command:</p> <pre><code># Owner is currently unused, but could be used in the future to manage contract permissions\nhyled tx zktx register [owner] [verifier] [program_id] [contract_name] [state_digest]\n</code></pre> <p>In the case of the Collatz Conjecture program, as RISC Zero programs are identified by their image ID, without a prefix, we use the number <code>0xb48e70c79688b41fc8f0daf8370d1ddb3f44ada934c10c6e0b0f5915102a363b</code>. This will change every time the contract logic is modified. The initial state is set to \"1\", so that it can be reset to any number. This is encoded in base 64 as <code>AAAAAQ==</code> (because of the rust library used to decode the state).</p> <p>NB: this might fail on the public devnet, as the contract name might already exist - try a different name in that case.</p> <pre><code># Using \"default\" as an owner for now, but you cna put anything you like\nhyled tx zktx register default risczero b48e70c79688b41fc8f0daf8370d1ddb3f44ada934c10c6e0b0f5915102a363b collatz AAAAAQ==\n</code></pre> <p>You can check on Hyl\u00e9's explorer to see your transaction: <code>https://hyleou.hyle.eu/transaction/$TX_HASH</code></p> <p>Your contract state is visible at: <code>https://hyleou.hyle.eu/contract/$CONTRACT_NAME</code></p>"},{"location":"developers/using-the-cli/your-first-smart-contract/#interacting-with-hyle","title":"Interacting with Hyl\u00e9","text":""},{"location":"developers/using-the-cli/your-first-smart-contract/#publishing-payloads","title":"Publishing payloads","text":"<p>Hyl\u00e9 transactions are settled in two steps. First - you send the payloads of your transaction to the network. These are application-specific data and will depend on how the contract is implemented.  In the case of the Collatz Conjecture program, this is a number encoded as a big-endian 32-bit integer.  Hence, the payloads correspond to the input of our program.</p> <pre><code>payload='\\x00\\x00\\x00\\x05'\n# Generate the proof in 'collatz-contract'\ncargo run reset $payload\nhyled tx zktx publish \"\" collatz $(echo $payload | base64) # the \"\" is a placeholder for identity - Collatz doesn't handle identity so this is empty.\n</code></pre> <p>You should then be able to check your transaction on Hyl\u00e9ou. At this point, your transaction has been sequenced, but not settled.</p>"},{"location":"developers/using-the-cli/your-first-smart-contract/#posting-proofs-of-your-payload-to-settle-it","title":"Posting proofs of your payload to settle it.","text":"<p>Hyl\u00e9 requires some specific variables in the output of the proof to process the transaction. Check the smart contract ABI for more details.</p> <p>Once your program conforms to the ABI, you can simply generate proofs and send them to Hyl\u00e9. Each payload of a transaction must be proven separately (for now), so you need to specify the index of the payload you're proving.</p> <pre><code>hyled tx zktx prove [tx_hash] [payload_index] [contract_name] [proof]\n</code></pre> <p>In the case of the Collatz Conjecture program, we can now prove our state transition from 1 to 5.</p> <pre><code># Make sure the name matches the contract you registered\nhyled tx zktx prove [tx_hash] 0 collatz [path_to_proof]\n</code></pre> <p>At this point, your transaction is settled and the state of the contract has been updated. You can then check that the contract was updated onchain by running the command below or checking in the explorer directly.</p> <pre><code>hyled query zktx contract collatz\n</code></pre>"},{"location":"resources/","title":"Resources","text":"<ul> <li>Find us</li> </ul>"},{"location":"resources/find-us/","title":"Useful links","text":"<ul> <li>Rust WIP node</li> <li>Hyle.eu</li> <li>Hyl\u00e9 blog</li> </ul>"},{"location":"resources/find-us/#contact-us","title":"Contact us","text":"<p>Feel free to reach out to the team for more information:</p> <ul> <li> Github: Hyl\u00e9</li> <li> Twitter: @hyle_org</li> <li> Farcaster: @hyle-org</li> <li> LinkedIn: Hyl\u00e9</li> <li> Youtube: @Hyl\u00e9</li> <li> Telegram: @hyle_org</li> </ul>"},{"location":"resources/grants/","title":"Grants","text":"<p>We have a grant program supporting developers who want to work on trust infrastructure and programmable cryptography on Hyl\u00e9.</p>"},{"location":"resources/grants/#what-are-our-grants-like","title":"What are our grants like?","text":"<ul> <li>You apply with an original idea or an idea from the list below. </li> <li>We fund your project. You get some money upfront, so you can build without financial worries, and the rest upon completion of the project.</li> <li>You meet regularly with our CEO for guidance and to help you refine your ideas.</li> <li>You are in a Telegram group with our other grantees to share ideas and solutions.</li> <li>Our tech team supports you via Telegram and in meetings.</li> <li>Our business team helps you showcase your idea through external speaking opportunities, comarketing, and other assets.</li> </ul> <p>To read more, see our grant ideas, and apply, please go to our Grants page on the main Hyl\u00e9 repository.</p> <p>For questions that aren't answered on the Grants page, reach out in our Telegram group.</p>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#roadmap","title":"Roadmap","text":"<p>We do not have a public roadmap at this time. Stay tuned for updates or ask specific questions in our Telegram group.</p>"},{"location":"roadmap/#currently-supported-proving-schemes","title":"Currently Supported Proving Schemes","text":"<p>Check the detailed list of the proving schemes we currently support and the ones we'll work on next.</p>"},{"location":"roadmap/#testnet","title":"Testnet","text":"<p>We will release our testnet in early 2025.</p> <p>While we\u2019re working towards launching the testnet, you can get hands-on right now: - Explore our public devnet, which is live and ready for use. - Or, spin up your own instance to start building today!</p>"},{"location":"use-cases/","title":"Use cases","text":"<p>The Use cases section of the Hyl\u00e9 documentation shows how to use Hyl\u00e9 in different scenarios.</p> <ul> <li>Hyl\u00e9 for ZKApps </li> <li>Hyl\u00e9 for identity providers &amp; wallets</li> <li>Hyl\u00e9 for RAAS &amp; ZK Coprocessors (coming soon)</li> <li>...</li> </ul> <p>As well as external use cases: - Hyl\u00e9 for play-by-email provable games - Hyl\u00e9 for account abstraction - Hyl\u00e9 for age verification - Hyl\u00e9 for the European Union?</p> <p>If you have other ideas for use cases, you might be interested in our grants program!</p>"},{"location":"use-cases/for-identity-providers/","title":"Hyl\u00e9 for Identity Providers","text":"<p>Hyl\u00e9 does not specify what an \"account\" is, or even what identity particularly means. This gives it unprecedented flexibility in handling identity, including:</p> <ul> <li>EOAs like Ethereum native wallets</li> <li>Smart accounts of any kind</li> <li>Regular web2 identity</li> <li>Passports &amp; other national identity documents.</li> </ul> <p>!!! warning     You are entering TODO area, none of this is currently implemented.</p> <p>Hyl\u00e9 handles identity relying on the caller contract in a multicall.</p> <p>When a user crafts a transaction, their first call should be a proof-of-identity, for example a call to the native <code>/eth</code> smart contract, which validates Ethereum-like EOA signatures.</p> <p>Any subsequent call will see that the user is indeed the owner of an <code>/eth</code> address, e.g. <code>0xfoobar/eth</code> and will be able to use that address name trustlessly.</p>"},{"location":"use-cases/for-identity-providers/#registering-your-own-stateless-identity-provider","title":"Registering your own stateless identity provider","text":"<p>A stateless identity provider such as the Ethereum EOA smart contract has two components:</p> <ul> <li>A smart contract registered on Hyl\u00e9, authenticating proofs</li> <li>A client-side library that can craft proofs</li> </ul> <p>See the Ethereum EOA smart contract for an example of such a provider.</p>"},{"location":"use-cases/for-identity-providers/#adding-support-for-your-smart-wallet","title":"Adding support for your smart wallet","text":""},{"location":"use-cases/for-identity-providers/#registering-a-stateful-private-identity-provider","title":"Registering a stateful, private identity provider","text":"<p>This can be used by games, SSO providers, or any other use-case that needs to handle user identity in a more traditional way.</p>"},{"location":"use-cases/for-zk-apps/","title":"Hyl\u00e9 for ZKApps","text":"<p>Hyl\u00e9 is a full featured settlement layer, providing fast finality and cheap TX cost. This makes it a great fit for use-cases that would require appchains or L3s in other ecosystems.</p>"},{"location":"use-cases/for-zk-apps/#registering-your-smart-contract","title":"Registering your smart contract","text":"<p>See Your First Smart Contract for details.</p>"},{"location":"use-cases/for-zk-apps/#bring-your-own-accounts","title":"Bring your own accounts","text":"<p>See Hyl\u00e9 for Identity Providers</p>"}]}