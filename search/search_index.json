{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#home","title":"Home","text":"<p>Hyl\u00e9 is a lean blockchain that lets you easily take your provable application onchain.</p> <p>Note</p> <p>This developer portal and the project itself are still evolving. Join us on Telegram if you need assistance or wish to provide feedback. Issues and PRs on this documentation's GitHub repository are also very welcome!</p>"},{"location":"#why-choose-hyle","title":"Why choose Hyl\u00e9","text":"<ul> <li>Native zero-knowledge proof verification on our sovereign L1: we're fast and lean.</li> <li>No onchain execution or virtual machine needed: only efficient proof verification.</li> <li>Run complex logic offchain and only submit proofs onchain for maximum scalability.</li> <li>Proof composability: seamlessly combine multiple proofs into single, verifiable transactions.</li> <li>Pipelined proving: send provable blobs, don't worry about proving times.</li> <li>Choose your proving scheme and your language: we verify all proofs.</li> </ul>"},{"location":"#how-hyle-works","title":"How Hyl\u00e9 works","text":"<p>Here\u2019s what happens when you use Hyl\u00e9\u2019s sovereign verification-focused Layer 1:</p> <p></p> <ol> <li>Sequencing: Send a provable blob to Hyl\u00e9: say what information you expect to prove later. We'll sequence the transaction immediately. Read more about pipelined proving.</li> <li>Proof submission: when the proofs for your transaction are ready, send them to Hyl\u00e9.</li> <li>Verification: Hyl\u00e9 validators receive the transaction. They verify the proofs natively, without the limitations of a bulky virtual machine.</li> <li>Consensus: if the proofs are valid, Hyl\u00e9 settles your transaction's state onchain. You're good to go!</li> </ol> <p>With this system, execution and storage happen anywhere you like. You only need a fast and trustworthy verifier: that\u2019s Hyl\u00e9.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Get started now</li> <li>Learn more about Hyl\u00e9</li> <li>Check out examples</li> </ul>"},{"location":"#links","title":"Links","text":"<ul> <li>Rust node</li> <li>Hyle.eu</li> <li>Hyl\u00e9 blog</li> </ul> <p>Reach out to the team for more information:</p>  Github  Twitter  Farcaster  LinkedIn  Youtube  Telegram Hyl\u00e9 @hyle_org @hyle-org Hyl\u00e9 @Hyl\u00e9 @hyle_org"},{"location":"developers/","title":"\ud83d\udc69\u200d\ud83d\udcbb Developer documentation","text":""},{"location":"developers/#developer-documentation","title":"\ud83d\udc69\u200d\ud83d\udcbb Developer documentation","text":"<p>Welcome to the developer documentation for Hyl\u00e9!</p> <ul> <li>Quickstart</li> <li>General documentation about Hyl\u00e9</li> <li>Explorer</li> <li>Annotated examples</li> </ul>"},{"location":"developers/explorer/","title":"Explorer","text":"<p>Hyl\u00e9ou (a French pun for \"Il est o\u00f9\" or \"Where is it?\") is the blockchain explorer for the Hyl\u00e9 ecosystem.</p> <p>The explorer is live at hyleou.hyle.eu.  </p> <p>The source code is available on GitHub. We welcome PRs and issues!</p>"},{"location":"developers/explorer/#features","title":"Features","text":"<p>All features are in active development. </p>"},{"location":"developers/explorer/#live-features","title":"Live features","text":"<p>Currently, you can:</p> <ul> <li>View the latest blocks</li> <li>View the latest transactions.</li> <li>View detailed information about specific blocks and transactions.</li> </ul>"},{"location":"developers/explorer/#upcoming-features","title":"Upcoming features","text":"<p>Planned features include:</p> <ul> <li>Register new contracts.</li> <li>Send transactions by uploading ZK proofs to specific contracts (multicall not yet supported).</li> </ul>"},{"location":"developers/examples/","title":"Examples","text":""},{"location":"developers/examples/#examples","title":"Examples","text":"<p>Detailed examples of Hyl\u00e9-based applications.</p>"},{"location":"developers/examples/#sample-contracts-in-hyle","title":"Sample contracts in Hyl\u00e9","text":"<p>We have three Hyl\u00e9-made Risc0 smart contracts :</p> <ul> <li><code>hydentity</code>: Basic identity provider</li> <li><code>hyllar</code>: Simple ERC20-like contract</li> <li><code>amm</code>: Simple AMM contract</li> <li><code>risc0 recursion</code></li> <li>WIP: <code>staking</code></li> </ul> <p>There is also a CLI called <code>hyrun</code> to execute those contracts, generate proofs, etc.</p>"},{"location":"developers/examples/#code-examples","title":"Code examples","text":"<ul> <li>Collatz example on Hyl\u00e9, using SP1, Noir, or Groth16</li> </ul>"},{"location":"developers/examples/#demos-and-provable-apps","title":"Demos and provable apps","text":"<p>Demos:</p> <ul> <li>Vibe Check: a zkML app.</li> </ul> <p>Our grantees have worked on Hyl\u00e9-based projects. Check them out for inspiration on building provable apps!</p>"},{"location":"developers/examples/amm/","title":"AMM","text":""},{"location":"developers/examples/amm/#amm","title":"AMM","text":"<p>The Hyl\u00e9 AMM is a decentralized Automated Market Maker (AMM) built on the Hyl\u00e9 protocol. It showcases how Hyl\u00e9 can be used for efficient, scalable, and secure decentralized trading.</p>"},{"location":"developers/examples/amm/#overview","title":"Overview","text":"<p>The AMM simplifies decentralized trading through a constant function market maker model. Developers can leverage its architecture to integrate trading functionalities within their dApps.</p> <p>Key highlights include:</p> <ul> <li>Scalability: Supports high throughput and low-latency transactions, even under heavy network usage.</li> <li>Composability: you can use it to interact with your own provable applications.</li> </ul>"},{"location":"developers/examples/amm/#links","title":"Links","text":"<ul> <li>Front-end and back-end</li> <li>Contracts</li> </ul>"},{"location":"developers/examples/collatz-example-in-depth/","title":"Collatz example","text":""},{"location":"developers/examples/collatz-example-in-depth/#collatz-example","title":"Collatz example","text":"<p>Hyl\u00e9 smart contracts can be written in any language that targets one of our supported proving schemes.</p> <p>On this page, we'll use the RISC Zero Collatz Conjecture program, which can be found in our examples repository.</p>"},{"location":"developers/examples/collatz-example-in-depth/#what-is-the-collatz-conjecture","title":"What is the Collatz conjecture?","text":"<p>The Collatz conjecture is a simple mathematical problem that can be expressed as a program.  </p> <p>The conjecture states that, for any positive integer <code>n</code>:</p> <ul> <li>if <code>n</code> is even, divide it by 2</li> <li>if <code>n</code> is odd, multiply it by 3 and add 1</li> <li>repeat this process, and you will eventually reach 1.</li> </ul> <p>The program is implemented in Rust, and compiles to the RISC Zero zkVM.</p>"},{"location":"developers/examples/collatz-example-in-depth/#compiling-the-program","title":"Compiling the program","text":"<p>To compile the program, you will need to have the RISC Zero toolchain installed. Follow the official instructions to get the most up-to-date information.</p> <p>To use RISC Zero, you'll need to compile with</p> <pre><code>cargo build --features risc0\n</code></pre> <p>The matching binary is <code>risc0-runner</code>.</p> <p>Run <code>cargo risczero build</code> to build smart contract.</p>"},{"location":"developers/examples/collatz-example-in-depth/#running-the-collatz-conjecture-program","title":"Running the Collatz Conjecture program","text":"<p>Hyl\u00e9 smart contracts can be executed client-side, enabling strong decentralization and permissionlessness.</p> <p>To execute the smart contract, run the program with correct inputs.</p>"},{"location":"developers/examples/collatz-example-in-depth/#generate-a-proof","title":"Generate a proof","text":""},{"location":"developers/examples/collatz-example-in-depth/#prove-the-transition-from-x-to-the-next-number","title":"Prove the transition from X to the next number","text":"<pre><code># Generate a proof of the transition from X to the next number in the Collatz conjecture\ncargo run next X\n# Or do it reproducibly\ncargo run -- -r next X\n</code></pre> <p>Here are some concrete examples:</p> <pre><code># Compute a proof of a transition between the number 12 and 6\ncargo run next 12\n\n# Compute a proof of a transition between the number 17 and 52\ncargo run next 17\n</code></pre>"},{"location":"developers/examples/collatz-example-in-depth/#reset-to-x","title":"Reset to X","text":"<pre><code># Reset to X, assuming the current number is a 1\ncargo run reset X\n# Or do it reproducibly\ncargo run -- -r reset X\n</code></pre> <p>Here is one concrete example:</p> <pre><code># Reset the state from 1 to 31\ncargo run reset 31\n</code></pre>"},{"location":"developers/examples/collatz-example-in-depth/#invalid-transitions","title":"Invalid transitions","text":"<p>The Collatz smart contract demonstrates how the code of the smart contract enforces constraints on the state:</p> <ul> <li>You can't generate valid proofs of transition between numbers that are not part of the Collatz sequence.</li> <li>The contract will reject attempts to reset to 0, as there would no longer be any next state.</li> </ul>"},{"location":"developers/examples/collatz-example-in-depth/#use-the-proof","title":"Use the proof","text":"<p>Every time, a <code>proof.json</code> file containing the receipt will be generated. You can use this proof, along with the inputs, to trigger state transitions on Hyl\u00e9. Read more: Your first smart contract.</p>"},{"location":"developers/examples/collatz-example-in-depth/#verify-the-proof","title":"Verify the proof","text":"<p>Coming next.</p>"},{"location":"developers/examples/vibe-check/","title":"Vibe Check","text":""},{"location":"developers/examples/vibe-check/#vibe-check","title":"Vibe Check","text":"<p>The general idea of the Vibe Check app is to give people a SmileToken to reward them for smiling.</p> <p>Watch Sylve's demo at ETHCC[7].</p> <p>Find the code in the dedicated GitHub repository.</p>"},{"location":"developers/examples/vibe-check/#context","title":"Context","text":"<p>The step-by-step process:</p> <ol> <li>I identify myself.<ol> <li>I use WebAuthn, with a Yubikey on a computer, a fingerprint on a phone, or any other accepted device.</li> <li>Vibe Check runs the Noir prover in-browser.</li> <li>The prover generates a Noir proof that the Webauthn-signature is correct.</li> </ol> </li> <li>I take a selfie where I\u2019m smiling to generate a proof of my shiny, bubbly personality.<ol> <li>Vibe Check uses a machine-learning model.</li> <li>I send my selfie to this Cairo program.</li> <li>The machine-learning model checks that I am smiling.</li> <li>If I am smiling, the Cairo-prover generates a proof.</li> </ol> </li> <li>Vibe Check gives me a SmileToken.<ol> <li>Vibe Check locally updates the state of the SmileToken.</li> <li>Vibe Check generates a Cairo proof that the state transition was done correctly.</li> </ol> </li> <li>Hyl\u00e9 verifies the proofs.<ol> <li>Hyl\u00e9 updates the SmileToken state if everything is correct. If so, I am rewarded with that SmileToken to congratulate me for my good vibes.</li> </ol> </li> </ol>"},{"location":"developers/examples/vibe-check/#how-it-works","title":"How it works","text":""},{"location":"developers/examples/vibe-check/#understanding-the-components-of-the-demo","title":"Understanding the components of the demo","text":"<p>The Vibe Check demo consists of three components: the app, the proof, and the Hyl\u00e9 node.</p>"},{"location":"developers/examples/vibe-check/#the-app","title":"The app","text":"<p>The app helps the user craft a transaction through 2 interactions:</p> <ul> <li>Identification with WebAuthn for a proof of ID</li> <li>Photo of the user smiling for a proof of smile</li> </ul> <p>The app prepares for proof generation; it also sends a blob of this transaction to Hyl\u00e9, so Hyl\u00e9 can sequence it and knows to expect upcoming proofs.</p>"},{"location":"developers/examples/vibe-check/#the-prover","title":"The prover","text":"<p>Proofs can be generated locally in the browser or remotely to maximize performance. Local proof generation is possible by compiling the Cairo VM/Cairo Prover/Noir Prover into WASM, but it is inefficient. Proving is a memory-consuming activity, and browsers usually have a low limit.</p> <p>The proof generators generate three proofs:</p> <ol> <li>Proof of ID: verification of the WebAuthn ECDSA signature in Noir</li> <li>Proof of smile: running the machine-learning model in Cairo</li> <li>Token (ERC-20) transfer: initiated in Cairo if the first two proofs are valid.</li> </ol> <p>The app sends the three proofs to the Hyl\u00e9 node.</p> <p>The Hyl\u00e9 node:</p> <ol> <li>Unpacks the three proofs.</li> <li>Verifies each proof with the correct verifier: Noir for WebAuthn and Cairo for the two others.</li> <li>Ensures consistency by checking the public data contained in the proofs to ensure they all relate to the same transaction.</li> </ol> <p></p>"},{"location":"developers/examples/vibe-check/#multiple-proving-schemes","title":"Multiple proving schemes","text":"<p>In Vibe Check, we use Noir and Cairo and we leverage proof composability</p>"},{"location":"developers/examples/vibe-check/#the-actual-code","title":"The actual code","text":"<p>Find the code in the dedicated GitHub repository!</p>"},{"location":"developers/general-doc/","title":"General documentation","text":"<p>Welcome to the developer documentation for Hyl\u00e9.</p> <p>You can also refer to our Getting Started step-by-step guide.</p>"},{"location":"developers/general-doc/hyle-vs-vintage-blockchains/","title":"Hyl\u00e9 vs. vintage blockchains","text":""},{"location":"developers/general-doc/hyle-vs-vintage-blockchains/#hyle-vs-vintage-blockchains","title":"Hyl\u00e9 vs. vintage blockchains","text":"<p>If you're used to traditional blockchains such as Ethereum or Solana, keep these Hyl\u00e9 characteristics in mind.</p>"},{"location":"developers/general-doc/hyle-vs-vintage-blockchains/#no-evm-or-execution-layer","title":"No EVM or execution layer","text":"<p>Hyl\u00e9 does not include a Virtual Machine.</p> <p>There is no dedicated execution engine or specific programming language (like Solidity) you should use.</p> <p>Our approach is simple: onchain, we verify zero-knowledge proofs natively. Offchain, you do everything else, the way you prefer.</p>"},{"location":"developers/general-doc/hyle-vs-vintage-blockchains/#no-onchain-state","title":"No onchain state","text":"<p>The network maintains proofs of state transitions rather than the entire onchain state.</p> <p>Transactions on Hyl\u00e9 verify and settle transitions without storing full intermediary states onchain.</p> <p>This architecture reduces storage overhead and promotes scalability while maintaining trustlessness.</p>"},{"location":"developers/general-doc/hyle-vs-vintage-blockchains/#privacy-is-built-in","title":"Privacy is built-in","text":"<p>Unlike Ethereum, where privacy solutions must be implemented on top of the platform, Hyl\u00e9 integrates privacy features natively.</p> <p>The proof is public, but your inputs don't need to be, as execution happens offchain.</p>"},{"location":"developers/general-doc/identity/","title":"Identity management","text":""},{"location":"developers/general-doc/identity/#identity-management","title":"Identity management","text":""},{"location":"developers/general-doc/identity/#where-is-identity-relevant-on-hyle","title":"Where is identity relevant on Hyl\u00e9?","text":"<p>One blob transaction on Hyl\u00e9 includes:</p> <ul> <li>Blobs, as many as wanted;</li> <li>One blob which corresponds to the identity of the person who initiated the transaction.</li> </ul> <p>Note that:</p> <ul> <li>Every blob transaction requires a single identity.</li> <li>All provable blobs within a transaction must share the same identity.</li> </ul> <p>Any contract can be an identity. Hyl\u00e9 ships a native <code>hydentity</code> contract, but you can use any source as an identity proving scheme.</p>"},{"location":"developers/general-doc/identity/#whats-special-about-identity-on-hyle","title":"What's special about identity on Hyl\u00e9","text":"<p>Any smart contract can be an identity provider, and there is true interoperability: a transaction can send Hyl\u00e9 tokens from your Metamask wallet to an email and password account seamlessly.</p>"},{"location":"developers/general-doc/identity/#implementation","title":"Implementation","text":"<p>Note</p> <p>Please contact us directly to know more about identity management on Hyl\u00e9. We are aiming to publish implementation instructions in January 2025.</p>"},{"location":"developers/general-doc/pipelined-proving/","title":"Pipelined proving","text":""},{"location":"developers/general-doc/pipelined-proving/#pipelined-proving","title":"Pipelined proving","text":""},{"location":"developers/general-doc/pipelined-proving/#the-problem-base-state-conflicts","title":"The problem: base state conflicts","text":"<p>Hyl\u00e9 ensures both privacy and scalability by verifying only the state transitions of smart contracts.</p> <p>However, provable applications usually run into an issue. Proof generation can be slow, especially on less powerful devices, and an app with a lot of usage will see conflicting operations, ie. operations that start with the same base state because the previous state change hasn't been settled yet.</p> <p>This is linked to several challenges:</p> <ul> <li>Proof generation latency</li> <li>Timekeeping: proofs require accurate time information, but users can't predict when their transaction will be sequenced.</li> <li>Parallelization: proofs must include valid state transitions, but multiple transactions can accidentally reference the same base state.</li> </ul> <p>We solve these issues by splitting sequencing from settlement; an operation includes two transactions.</p>"},{"location":"developers/general-doc/pipelined-proving/#blob-transaction-vs-proof-transaction","title":"Blob-transaction vs. Proof-transaction","text":"<p>Hyl\u00e9 splits operations into two transactions:</p> <ol> <li>Blob-transaction: outlines a state change for sequencing.</li> <li>Proof-transaction: provides a proof for the claimed state change for settlement.</li> </ol> <p>From Hyl\u00e9\u2019s perspective, the blob-transaction's content is not an issue: it simply represents incoming information that your contract will process.</p> <ol> <li>Sequencing happens when the blob transaction is received and included in a block. This step establishes a global order and timestamps for transactions.</li> <li>Settlement happens when the corresponding proof transaction is verified and added to a block.</li> </ol> <p>During settlement, unproven blob transactions linked to the contract are executed in their sequencing order.</p> <p></p>"},{"location":"developers/general-doc/pipelined-proving/#unprovable-transactions","title":"Unprovable transactions","text":"<p>Even with pipelined proving, the delay in proof generation and submission can delay transaction finality and create uncertainty when determining the initial state of subsequent transactions.</p> <p>To remove this bottleneck, Hyl\u00e9 enforces timeouts for blob transactions.</p> <p>Each blob transaction is assigned a specific time limit for the associated proof to be submitted and verified. If the proof is not successfully provided within this window, the transaction is rejected: it is ignored for state updates but remains recorded in the block.</p> <p>The inclusion of the unproven transaction in the block ensures transparency, as the transaction data remains accessible.</p> <p>Subsequent transactions can proceed without waiting indefinitely.</p>"},{"location":"developers/general-doc/proof-composability/","title":"Proof composition and cross-contract calls","text":""},{"location":"developers/general-doc/proof-composability/#proof-composition-and-cross-contract-calls","title":"Proof composition and cross-contract calls","text":"<p>To understand the concept of proof composability on Hyl\u00e9, we recommend you read this blog post. This page focuses on demonstrating how to use proof composition in your code.</p>"},{"location":"developers/general-doc/proof-composability/#what-is-proof-composition","title":"What is proof composition?","text":"<p>Proof composition happens when two contracts depend on each other. Proof composability is the fact that Hyl\u00e9 allows you to manage this situation while keeping their proofs independent.</p> <p>Most zero-knowledge systems deal with cross-contract calls by enforcing recursive proof verification:</p> <ul> <li>Program A verifies proof of correct execution of Program B;</li> <li>Program B verifies proof of correct execution of Program A.</li> </ul> <p>Hyl\u00e9 allows you to assume, in Program A, that Program B has been successfully executed, by verifying that claim. If you batch both blobs in the same operation, we verify both natively outside of the contract; the whole operation fails if one proof fails to verify.</p> <p>Read more on our blog.</p>"},{"location":"developers/general-doc/proof-composability/#writing-a-cross-contract-call","title":"Writing a cross-contract call","text":"<p>Your program does not need to verify the execution of another program directly.</p> <p>Instead, it uses a representation of the called contracts, which looks like this: <code>MoneyApp::transfer(10, A, B) == true</code> or <code>TicketApp::get(A) == ticket</code>.</p> <p>This representation consists of:</p> <ul> <li>the app</li> <li>the function</li> <li>the function's parameters</li> <li>a claim on the results.</li> </ul> <p>Follow these steps:</p> <ol> <li>Inject claims: add all the claims as inputs to the blob.</li> <li>Index claims: provide an index to tell the contract where to locate its input.</li> <li>Assert claims: use the claim list to validate the required conditions for the blob.</li> </ol>"},{"location":"developers/general-doc/proof-composability/#how-hyle-settles-multiple-proofs","title":"How Hyl\u00e9 settles multiple proofs","text":"<p>When you submit multiple proofs to Hyl\u00e9:</p> <ul> <li>Proof generation can be parallelized: proving times do not compound since proofs do not depend on each other.</li> <li>Proof verification is asynchronous thanks to pipelined proving. As soon as one proof is ready, it can be verified on Hyl\u00e9, even if the other proofs aren't ready yet.</li> <li>Once all proofs related to the transaction are verified, the transaction is settled on Hyl\u00e9. If one proof verification fails, then the entire transaction fails.</li> </ul> <p>Read more on our blog.</p>"},{"location":"developers/general-doc/run-a-node/","title":"Run a node","text":""},{"location":"developers/general-doc/run-a-node/#run-a-node","title":"Run a node","text":"<p>We currently don't have a deployment file available.</p> <p>Follow these instructions to run a node, keeping in mind that this is unstable and can break with upcoming updates.</p> <p>Download the Docker image:</p> <pre><code>docker pull europe-west3-docker.pkg.dev/hyle-413414/hyle-docker/hyle:main\n</code></pre> <p>Then run the image:</p> <pre><code>docker run --name [container_name] -d [options] europe-west3-docker.pkg.dev/hyle-413414/hyle-docker/hyle:main\n</code></pre> <p>And rebuild the node from the source:</p> <pre><code>docker build -t Hyle-org/hyle . &amp;&amp; docker run -dit Hyle-org/hyle\n</code></pre>"},{"location":"developers/general-doc/smart-contracts/","title":"Smart contracts","text":""},{"location":"developers/general-doc/smart-contracts/#smart-contracts","title":"Smart contracts","text":"<p>Hyl\u00e9 is a fully programmable blockchain that optimizes data storage by keeping only the essential information needed to validate smart contract proofs. This design ensures that Hyl\u00e9 smart contracts are lightweight and efficient.</p> <p>Where traditional blockchains keep all smart contract information onchain, Hyl\u00e9 splits offchain data (your contract's execution) and onchain data, which is retrieved through our ABI.</p>"},{"location":"developers/general-doc/smart-contracts/#onchain-data-about-smart-contracts","title":"Onchain data about smart contracts","text":"<p>Hyl\u00e9 smart contracts' onchain data consists of:</p> <ul> <li>Name: the unique identifier for your contract</li> <li>Verifier: the proof system (e.g. \"risc0\" or \"gnark-groth16-te-BN254\")</li> <li>Program ID: the unique identifier for your program in that proof system</li> <li>State digest: current state commitment of the contract</li> </ul>"},{"location":"developers/general-doc/smart-contracts/#explanation-of-the-contract-fields","title":"Explanation of the contract fields","text":""},{"location":"developers/general-doc/smart-contracts/#name","title":"Name","text":"<p>The name of your contract must be unique.</p>"},{"location":"developers/general-doc/smart-contracts/#verifier-and-program-identifier","title":"Verifier and program identifier","text":"<p>Smart contracts on Hyl\u00e9 rely on a pairing of a zero-knowledge proof scheme (verifier) and a program identifier. Together, these components validate contract proofs.</p> Proving scheme Verifier Program ID Noir noir Verification key. Risc Zero risc0 Image ID without a prefix. ex. 0x123 becomes 123. SP1 sp1 Verification key."},{"location":"developers/general-doc/smart-contracts/#state-digest","title":"State digest","text":"<p>The state digest is a minimal yet comprehensive representation of the contract's current state. It serves as the basis for verifying the integrity of the contract's data.</p> <p>Some examples of valid state commitments:</p> <ul> <li>The full state, for a sufficiently small program (e.g. the Collatz example, or a smart-contract with a nonce)</li> <li>A merkle root of the state, for larger programs</li> <li>A hash of the full state</li> </ul>"},{"location":"developers/general-doc/smart-contracts/#smart-contract-abi","title":"Smart contract ABI","text":"<p>All inputs in Hyl\u00e9 smart contracts must be known at proof generation time. This includes elements that would be known at execution time on other blockchains, such as the origin of the transaction (tx.origin) and the block number.</p> <p>Here is the Rust structure specifying the output of a Hyl\u00e9 smart contract:</p> <pre><code>pub struct HyleOutput {\n    pub version: u32,\n    pub initial_state: StateDigest,\n    pub next_state: StateDigest,\n    pub identity: Identity,\n    pub tx_hash: TxHash,\n    pub index: BlobIndex,\n    pub blobs: Vec&lt;u8&gt;,\n    pub success: bool,\n    pub program_outputs: Vec&lt;u8&gt;,\n}\n</code></pre>"},{"location":"developers/general-doc/smart-contracts/#explanation-of-the-abi-fields","title":"Explanation of the ABI fields","text":""},{"location":"developers/general-doc/smart-contracts/#version","title":"Version","text":"<p>For now, <code>version</code> should always be set to 1.</p>"},{"location":"developers/general-doc/smart-contracts/#initial-state-and-next-state","title":"Initial state and next state","text":"<p>Blockchains transactions are fundamentally state transitions. These fields handle state changes securely.</p> <ul> <li><code>initial_state</code>: Matches the onchain <code>state_digest</code> before the transaction. The <code>initial_state</code> must match the onchain <code>state_digest</code>. Otherwise, the state transition is invalid.</li> <li><code>next_state</code>: Represents the new onchain <code>state_digest</code> after the transaction.</li> </ul> <p>Smart contracts can adapt the actual structure of this field. In the future, fees will depend in part on the size of the <code>state_digest</code>, so we encourage you to keep it small.</p>"},{"location":"developers/general-doc/smart-contracts/#identity","title":"Identity","text":"<p>The <code>identity</code> field identifies the person who initiates a transaction.</p> <p>Hyl\u00e9 does not have a native signature type. Instead, it uses the <code>identity</code> field of the first proof in the transaction to identify the sender. This allows you to use any kind of identity verification.</p> <p>The identity is in two parts:</p> <ol> <li>An address;</li> <li>The name of the contract that the proof was generate for.</li> </ol> <p>For example, if a smart contract was registered onchain to verify Ethereum EOAs, the <code>identity</code> for them would look like <code>0x1234...5678.eth_eoa</code> where <code>eth_eoa</code> is the name of the contract and the first part matches a regular Ethereum address.</p> <p>Note: All proofs in a transaction must declare the same identity as the first transaction or an empty identity.</p>"},{"location":"developers/general-doc/smart-contracts/#tx-hash","title":"TX Hash","text":"<p>The <code>tx_hash</code> field hashes transaction data, preventing replay attacks and providing a means for contracts to access this information.</p> <p>The field is not validated by the protocol.</p>"},{"location":"developers/general-doc/smart-contracts/#blob-index-and-blobs","title":"Blob index and blobs","text":"<p>Since a blob transaction can include several blobs, the design includes:</p> <ul> <li><code>pub index: BlobIndex</code>: uniquely identifies a specific blob within a transaction.</li> <li><code>pub blobs: Vec&lt;u8&gt;</code>: all blobs included in the transaction.</li> </ul>"},{"location":"developers/general-doc/smart-contracts/#success","title":"Success","text":"<p>This boolean field indicates whether the proof is for a successful transaction or a failure. It can be useful to prove that a transaction is invalid.</p> <p>Use case example: Vibe Check.</p>"},{"location":"developers/general-doc/smart-contracts/#other-program-specific-outputs","title":"Other program-specific outputs","text":"<p>Smart contracts can provide additional outputs as part of the proof they generate.</p> <p>These outputs mostly serve to provide data availability.</p>"},{"location":"developers/general-doc/smart-contracts/#events","title":"Events","text":"<p>Hyl\u00e9 does not include events. The protocol replaces traditional event systems with blobs, which act as containers for offchain data.</p>"},{"location":"developers/general-doc/supported-proving-schemes/","title":"Proving schemes","text":""},{"location":"developers/general-doc/supported-proving-schemes/#proving-schemes","title":"Proving schemes","text":"<p>Proving schemes are the cryptographic protocols that make zero-knowledge proofs usable.</p> <p>We support as many as we can, giving you the flexibility to choose the most suitable protocol for your specific use case.</p>"},{"location":"developers/general-doc/supported-proving-schemes/#supported-proving-schemes","title":"Supported proving schemes","text":"<p>As of December 2024, Hyl\u00e9 currently supports the following zero-knowledge proving schemes:</p> <ul> <li>Noir</li> <li>Risc0</li> <li>SP1</li> </ul>"},{"location":"developers/general-doc/supported-proving-schemes/#planned-future-support","title":"Planned future support","text":"<p>We plan to eventually support all major proving schemes.</p> <p>The next proving schemes we're aiming to support are:</p> <ul> <li>Cairo via Stwo</li> <li>Groth16</li> </ul>"},{"location":"developers/quickstart/","title":"Quickstart","text":"<p>Welcome to the Quickstart guide for Hyl\u00e9.</p> <p>This page will help you configure your environment and start using Hyl\u00e9.</p> <p>Use the sidebar to navigate through the guide, or click on the links below to jump to a specific section:</p> <ol> <li>Run your local devnet</li> <li>Use our tools</li> <li>Create your first smart contract</li> <li> <ol> <li>Use your favorite identity contract</li> </ol> </li> </ol>"},{"location":"developers/quickstart/amm/","title":"Proof composition: identities and token transfers","text":""},{"location":"developers/quickstart/amm/#proof-composition-identities-and-token-transfers","title":"Proof composition: identities and token transfers","text":"<p>to be written.</p>"},{"location":"developers/quickstart/custom-identity-contract/","title":"Using a custom identity contract","text":""},{"location":"developers/quickstart/custom-identity-contract/#using-a-custom-identity-contract","title":"Using a custom identity contract","text":""},{"location":"developers/quickstart/custom-identity-contract/#when-to-use-identity-contracts-on-hyle","title":"When to use identity contracts on Hyl\u00e9","text":"<p>On Hyl\u00e9, any smart contract can serve as proof of identity. This flexibility allows you to register your preferred identity source as a smart contract for account identification. Hyl\u00e9 also ships a native <code>hydentity</code> contract for simplicity.</p> <p>This guide walks you through creating and deploying your first simple identity contract using Hyl\u00e9 and RISC Zero. We'll use our simple identity example, which mirrors our simple token transfer example.</p> <p>For a deeper understanding of smart contracts, explore our identity management documentation.</p>"},{"location":"developers/quickstart/custom-identity-contract/#quickstart","title":"Quickstart","text":""},{"location":"developers/quickstart/custom-identity-contract/#prerequisites","title":"Prerequisites","text":"<ul> <li>Install Rust (you'll need <code>rustup</code> and Cargo).</li> <li>For our example, install RISC Zero.</li> <li>Start a single-node devnet. We recommend using dev-mode with <code>-e RISC0_DEV_MODE=1</code> for faster iterations during development.</li> </ul>"},{"location":"developers/quickstart/custom-identity-contract/#build-and-register-the-identity-contract","title":"Build and register the identity contract","text":"<p>To build all methods and register the smart contract on the local node from the source, from the cloned Examples folder, run:</p> <pre><code>cargo run -- register-contract\n</code></pre> <p>The expected output is <code>\ud83d\udcdd Registering new contract simple_identity</code>.</p>"},{"location":"developers/quickstart/custom-identity-contract/#register-an-account-sign-up","title":"Register an account / Sign up","text":"<p>To register an account with a username (<code>alice</code>) and password (<code>abc123</code>), execute:</p> <pre><code>cargo run -- register-identity alice.simple_identity abc123\n</code></pre> <p>The node's logs will display:</p> <pre><code>INFO hyle::data_availability::node_state::verifiers: \u2705 Risc0 proof verified.\nINFO hyle::data_availability::node_state::verifiers: \ud83d\udd0e Program outputs: Successfully registered identity for account: alice.simple_identity\n</code></pre>"},{"location":"developers/quickstart/custom-identity-contract/#verify-identity-login","title":"Verify identity / Login","text":"<p>To verify <code>alice</code>'s identity:</p> <pre><code>cargo run -- verify-identity pseudo.simple_identity password --nonce 0\n</code></pre> <p>This command will:</p> <ol> <li>Send a blob transaction to verify <code>alice</code>'s identity.</li> <li>Generate a ZK proof of that identity. It will only be valid once, thus the inclusion of a nonce.</li> <li>Send the proof to the devnet.</li> </ol> <p>Upon reception of the proof, the node will:</p> <ol> <li>Verify the proof.</li> <li>Settle the blob transaction.</li> <li>Update the contract's state.</li> </ol> <p>The node's logs will display:</p> <pre><code>INFO hyle::data_availability::node_state::verifiers: \u2705 Risc0 proof verified.\nINFO hyle::data_availability::node_state::verifiers: \ud83d\udd0e Program outputs: Identity verified for account: alice.simple_identity\n</code></pre> <p>See your contract's state digest at: <code>https://hyleou.hyle.eu/contract/$CONTRACT_NAME</code>.</p> <p>See your transaction on Hyl\u00e9's explorer: <code>https://hyleou.hyle.eu/tx/$TX_HASH</code>.</p>"},{"location":"developers/quickstart/custom-identity-contract/#detailed-information","title":"Detailed information","text":""},{"location":"developers/quickstart/custom-identity-contract/#development-mode","title":"Development mode","text":"<p>We recommend activating dev-mode during your early development phase for faster iteration upon code changes with <code>-e RISC0_DEV_MODE=1</code>.</p> <p>You may also want to get insights into the execution statistics of your project: add the environment variable <code>RUST_LOG=\"[executor]=info\"</code> before running your project.</p> <p>The full command to run your project in development mode while getting execution statistics is:</p> <pre><code>RUST_LOG=\"[executor]=info\" RISC0_DEV_MODE=1 cargo run\n</code></pre>"},{"location":"developers/quickstart/custom-identity-contract/#code-snippets","title":"Code snippets","text":"<p>Find the full annotated code in our examples repository.</p>"},{"location":"developers/quickstart/custom-identity-contract/#setup-commands-and-cli","title":"Setup commands and CLI","text":"<p>Set up commands and CLI. You need a unique <code>contract_name</code>: here, we use <code>\"simple_identity\"</code>.</p> <pre><code>struct Cli {\n    #[command(subcommand)]\n    command: Commands,\n\n    #[clap(long, short)]\n    reproducible: bool,\n\n    #[arg(long, default_value = \"http://localhost:4321\")]\n    pub host: String,\n\n    #[arg(long, default_value = \"simple_identity\")]\n    pub contract_name: String,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    RegisterContract {},\n    RegisterIdentity {\n        identity: String,\n        password: String,\n    },\n    VerifyIdentity {\n        identity: String,\n        password: String,\n        nonce: u32,\n    },\n}\n</code></pre>"},{"location":"developers/quickstart/custom-identity-contract/#registering-the-contract","title":"Registering the contract","text":"<p>Set up information about your contract. To register the contract, you'll need:</p> <ul> <li><code>owner</code>: we put \"examples\" as the <code>owner</code>, but you can put anything you like. This field is currently not leveraged; it will be in future versions.</li> <li><code>verifier</code>: for this example, the verifier is <code>risc0</code></li> <li><code>program_id</code>: RISC Zero programs are identified by their image ID, without a prefix.</li> <li><code>state_digest</code>: usually a MerkleRootHash of the contract's initial state. For this example, we use a hexadecimal representation of the state encoded in binary format. The state digest cannot be empty, even if your app is stateless.</li> <li><code>contract_name</code> as set up above.</li> </ul> <pre><code>// Build initial state of contract\nlet initial_state = Identity::new();\nprintln!(\"Initial state: {:?}\", initial_state);\n\n// Send the transaction to register the contract\nlet register_tx = RegisterContractTransaction {\n    owner: \"examples\".to_string(),\n    verifier: \"risc0\".into(),\n    program_id: sdk::ProgramId(sdk::to_u8_array(&amp;GUEST_ID).to_vec()),\n    state_digest: initial_state.as_digest(),\n    contract_name: contract_name.clone().into(),\n};\nlet res = client\n    .send_tx_register_contract(&amp;register_tx)\n    .await\n    .unwrap()\n    .text()\n    .await\n    .unwrap();\n\nprintln!(\"\u2705 Register contract tx sent. Tx hash: {}\", res);\n</code></pre> <p>In the explorer, it will look like this:</p> <pre><code>{\n    \"tx_hash\": \"321b7a4b2228904fc92979117e7c2aa6740648e339c97986141e53d967e08097\",\n    \"owner\": \"examples\",\n    \"verifier\": \"risc0\",\n    \"program_id\":\"e085fa46f2e62d69897fc77f379c0ba1d252d7285f84dbcc017957567d1e812f\",\n    \"state_digest\": \"fd00e876481700000001106661756365742e687964656e74697479fd00e876481700000000\",\n    \"contract_name\": \"simple_identity\"\n}\n</code></pre>"},{"location":"developers/quickstart/custom-identity-contract/#register-an-identity","title":"Register an identity","text":"<pre><code>// Fetch the initial state from the node\nlet initial_state: Identity = client\n    .await\n    .unwrap()\n    .state\n    .into();\n</code></pre>"},{"location":"developers/quickstart/custom-identity-contract/#build-the-blob-transaction","title":"Build the blob transaction","text":"<pre><code>let action = sdk::identity_provider::IdentityAction::RegisterIdentity {\n    account: identity.clone(),\n};\nlet blobs = vec![sdk::Blob {\n    contract_name: contract_name.clone().into(),\n    data: sdk::BlobData(\n        bincode::encode_to_vec(action, bincode::config::standard())\n            .expect(\"failed to encode BlobData\"),\n    ),\n}];\nlet blob_tx = BlobTransaction {\n    identity: identity.into(),\n    blobs: blobs.clone(),\n};\n\n// Send the blob transaction\nlet blob_tx_hash = client.send_tx_blob(&amp;blob_tx).await.unwrap();\nprintln!(\"\u2705 Blob tx sent. Tx hash: {}\", blob_tx_hash);\n</code></pre>"},{"location":"developers/quickstart/custom-identity-contract/#prove-the-registration","title":"Prove the registration","text":"<p>Hyl\u00e9 transactions are settled in two steps, following pipelined proving principles. After this step, your transaction is sequenced, but not settled.</p> <p>For the transaction to be settled, it needs to be proven. You'll start with building the contract input, specifying:</p> <ul> <li>the initial state as set above</li> <li>the identity of the transaction initiator</li> <li>the transaction hash, which can be found in the explorer after sequencing (currently, this can be ignored; it will be necessary after an upcoming update)</li> <li>information about the blobs.</li> <li>private input for proof generation in <code>private_blob</code></li> <li><code>blobs</code>: full list of blobs in the transaction (must match the blob transaction)</li> <li><code>index</code>: each blob of a transaction must be proven separately for now, so you need to specify the index of the blob you're proving.</li> </ul> <pre><code>// Build the contract input\nlet inputs = ContractInput {\n    initial_state: initial_state.as_digest(),\n    identity: blob_tx.identity,\n    tx_hash: \"\".into(),\n    private_blob: sdk::BlobData(password.into_bytes().to_vec()),\n    blobs: blobs.clone(),\n    index: sdk::BlobIndex(0),\n};\n\n// Generate the zk proof\n\n(\u2026)\n\n// Send the proof transaction\nlet proof_tx_hash = client\n    .send_tx_proof(&amp;proof_tx)\n    .await\n    .unwrap()\n    .text()\n    .await\n    .unwrap();\nprintln!(\"\u2705 Proof tx sent. Tx hash: {}\", proof_tx_hash);\n</code></pre>"},{"location":"developers/quickstart/custom-identity-contract/#verify-an-identity","title":"Verify an identity","text":"<p>The process is the same as for registering a new identity.</p> <pre><code>// Fetch the initial state from the node\nlet initial_state: Identity = client\n    .get_contract(&amp;contract_name.clone().into())\n    .await\n    .unwrap()\n    .state\n    .into();\n// ----\n// Build the blob transaction\n// ----\n\nlet action = sdk::identity_provider::IdentityAction::VerifyIdentity {\n    account: identity.clone(),\n    nonce,\n};\nlet blobs = vec![sdk::Blob {\n    contract_name: contract_name.clone().into(),\n    data: sdk::BlobData(\n        bincode::encode_to_vec(action, bincode::config::standard())\n            .expect(\"failed to encode BlobData\"),\n    ),\n}];\nlet blob_tx = BlobTransaction {\n    identity: identity.into(),\n    blobs: blobs.clone(),\n};\n</code></pre> <p>Check the full annotated code in our GitHub example.</p>"},{"location":"developers/quickstart/devnet/","title":"Run your local devnet","text":""},{"location":"developers/quickstart/devnet/#run-your-local-devnet","title":"Run your local devnet","text":"<p>Follow the instructions below to start building on Hyl\u00e9 by running a local devnet. (Instructions for a testnet will be added when we launch it.)</p>"},{"location":"developers/quickstart/devnet/#recommended-getting-started-with-docker","title":"Recommended: Getting started with Docker","text":"<p>Follow these instructions to run a node, keeping in mind that this is unstable and can break with upcoming updates.</p> <p>Download the Docker image:</p> <pre><code>docker pull ghcr.io/hyle-org/hyle:latest\n</code></pre> <p>Run the image:</p> <pre><code>docker run -v ./db:/hyle/data -e HYLE_RUN_INDEXER=false -e HYLE_REST=0.0.0.0:4321 -p 4321:4321 -p 1234:1234 ghcr.io/hyle-org/hyle:latest\n</code></pre> <p>If you run into an error, you may want to add the <code>--privileged</code> flag:</p> <pre><code>docker run --privileged -v ./db:/hyle/data -e HYLE_RUN_INDEXER=false -e HYLE_REST=0.0.0.0:4321 -p 4321:4321 -p 1234:1234 ghcr.io/hyle-org/hyle:latest\n</code></pre> <p>If you want to run with an indexer with <code>HYLE_RUN_INDEXER=true</code>, you will need a running PostgreSQL server. You can set it up with Docker:</p> <pre><code># For default conf:\ndocker run -d --rm --name pg_hyle -p 5432:5432 -e POSTGRES_PASSWORD=postgres postgres\n</code></pre> <p>You can customize the db URL with <code>HYLE_DATABASE_URL</code>, with the default value being: <code>postgres://postgres:postgres@localhost:5432/postgres</code> (see below for environment variables).</p>"},{"location":"developers/quickstart/devnet/#build-the-docker-image-locally","title":"Build the Docker image locally","text":"<p>If you want to, you can rebuild the image locally from source:</p> <pre><code>docker build -t Hyle-org/hyle . &amp;&amp; docker run -dit Hyle-org/hyle\n</code></pre> <p>You can now create your first smart contract.</p>"},{"location":"developers/quickstart/devnet/#alternative-getting-started-from-source","title":"Alternative: Getting started from source","text":"<p>To start a single-node devnet (with consensus disabled), which is useful to build &amp; debug smart contracts, run:</p> <pre><code>cargo build\nHYLE_RUN_INDEXER=false cargo run --bin node\n</code></pre>"},{"location":"developers/quickstart/devnet/#configuration","title":"Configuration","text":"<p>You can configure your setup using environment variables or by editing a configuration file.</p>"},{"location":"developers/quickstart/devnet/#using-environment-variables","title":"Using environment variables","text":"<p>All variables can be customized on your single-node instance.</p> Variable Default value Description HYLE_ID \"node\" Node identifier in the consensus. Usage subject to change in future releases. HYLE_SINGLE_NODE true Whether the network runs as a single node or with a multi-node consensus. HYLE_P2P_LISTEN true The node should listen to new peers. Mandatory (true) if multi-node consensus. HYLE_HOST \"127.0.0.1:1231\" Host &amp; port to listen for the P2P protocol. HYLE_PEERS [] List of peers to connect to at startup to follow a running consensus. HYLE_STORAGE__INTERVAL 10 unused HYLE_LOG_FORMAT \"full\" \u201cjson\u201d or \u201cfull\u201d HYLE_REST \"127.0.0.1:4321\" Host &amp; port for the REST API endpoint. data_directory \"data_node\" Directory name to store node state. database_url \"postgres://postgres:postgres@localhost:5432/postgres\" PostgreSQL server address (necessary if you want to use an indexer). consensus__slot_duration 1000 Duration between blocks. consensus__genesis_stakers {} Map of stakers for the genesis block. Keys are all nodes \u201cid\u201d, and values are the stake amount for each one of them. p2p__ping_interval 10 Interval the p2p layer does a ping to check aliveness of other peers. run_indexer true Whether there should be an indexer. da_address \"127.0.0.1:4141\" Host &amp; port of the data availability module, which streams historical &amp; new blocks. It might be used by indexers."},{"location":"developers/quickstart/devnet/#using-a-configuration-file","title":"Using a configuration file","text":"<p>To use a configuration file, copy the default settings where you run the node. If a file named config.ron is present, it will be automatically loaded by the node at startup.</p> <p>If you're using Docker:</p> <pre><code>docker run -v ./db:/hyle/data -v ./config.run:/hyle/config.ron -e HYLE_RUN_INDEXER=false -p 4321:4321 -p 1234:1234 ghcr.io/hyle-org/hyle:latest\n</code></pre> <p>Then, whether you're using Docker or building from source:</p> <pre><code># Copy default config where you run the node. If file named \"config.ron\" is present, it will be loaded by node at startup.\ncp ./src/utils/conf_defaults.ron config.ron\n</code></pre> <p>You can now create your first smart contract.</p>"},{"location":"developers/quickstart/erc20-and-identity/","title":"Erc20 and identity","text":"<p>to be written.</p>"},{"location":"developers/quickstart/user-tooling/","title":"User tooling","text":""},{"location":"developers/quickstart/user-tooling/#user-tooling","title":"User tooling","text":""},{"location":"developers/quickstart/user-tooling/#clone-the-hyle-repository","title":"Clone the Hyl\u00e9 repository","text":"<p>Clone the Hyl\u00e9 repository.</p> <pre><code>git clone https://github.com/Hyle-org/hyle.git\n</code></pre>"},{"location":"developers/quickstart/user-tooling/#recommended-install-the-cli","title":"Recommended: Install the CLI","text":"<p>You can install the CLI for easier access.</p> <pre><code>cargo install --path . --bin hyled\nhyled --help\n</code></pre>"},{"location":"developers/quickstart/user-tooling/#alternative-use-the-cli-without-installing","title":"Alternative: Use the CLI without installing","text":"<p>To interact with the node, use the cli <code>hyled</code>:</p> <pre><code>cargo run --bin hyled -- --help\n</code></pre>"},{"location":"developers/quickstart/user-tooling/#explorer","title":"Explorer","text":"<p>Explorer / Indexer: Hyl\u00e9ou. Read more about the explorer.</p>"},{"location":"developers/quickstart/your-first-smart-contract/","title":"Your first smart contract","text":""},{"location":"developers/quickstart/your-first-smart-contract/#your-first-smart-contract","title":"Your first smart contract","text":"<p>This guide will walk you through creating and deploying your first token transfer contract using Hyl\u00e9's tools and infrastructure. We'll use our sample token transfer example as the basis for this tutorial.</p> <p>For an in-depth understanding of smart contracts, check out our anatomy of a smart contract.</p>"},{"location":"developers/quickstart/your-first-smart-contract/#example","title":"Example","text":""},{"location":"developers/quickstart/your-first-smart-contract/#prerequisites","title":"Prerequisites","text":"<ul> <li>Install Rust (you'll need <code>rustup</code> and Cargo).</li> <li>For our example, install RISC Zero.</li> <li>Start a single-node devnet. We recommend using dev-mode with <code>-e RISC0_DEV_MODE=1</code> for faster iterations during development.</li> </ul>"},{"location":"developers/quickstart/your-first-smart-contract/#quickstart","title":"Quickstart","text":""},{"location":"developers/quickstart/your-first-smart-contract/#build-and-register-the-contract","title":"Build and register the contract","text":"<p>To build all methods and register the smart contract on the local node from the source, from the cloned Examples folder, run:</p> <pre><code>cargo run -- register 1000\n</code></pre> <p>The expected output is <code>\ud83d\udcdd Registering new contract simple_token</code>.</p>"},{"location":"developers/quickstart/your-first-smart-contract/#transfer-tokens","title":"Transfer tokens","text":"<p>To transfer 2 tokens from <code>faucet</code> to <code>Bob</code>:</p> <pre><code>cargo run -- transfer faucet.simple_token bob.simple_token 2\n</code></pre> <p>This command will:</p> <ol> <li>Send a blob transaction to transfer 2 tokens from <code>faucet</code> to <code>bob</code>.</li> <li>Generate a ZK proof of that transfer.</li> <li>Send the proof to the devnet.</li> </ol>"},{"location":"developers/quickstart/your-first-smart-contract/#verify-settled-state","title":"Verify settled state","text":"<p>Upon reception of the proof, the node will:</p> <ol> <li>Verify the proof</li> <li>Settle the blob transaction</li> <li>Update the contract's state</li> </ol> <p>The node's logs will display:</p> <pre><code>INFO hyle::data_availability::node_state::verifiers: \u2705 Risc0 proof verified.\nINFO hyle::data_availability::node_state::verifiers: \ud83d\udd0e Program outputs: Transferred 2 to bob.simple_token\n</code></pre> <p>And on the following slot:</p> <pre><code>INFO hyle::data_availability::node_state: Settle tx TxHash(\"[..]\")\n</code></pre>"},{"location":"developers/quickstart/your-first-smart-contract/#check-onchain-balance","title":"Check onchain balance","text":"<p>Verify onchain balances:</p> <pre><code>cargo run -- balance faucet.simple_token\ncargo run -- balance bob.simple_token\n</code></pre> <p>Note</p> <p>In this example, we do not verify the identity of the person who initiates the transaction. We use <code>.simple_token</code> as a suffix for the \"from\" and \"to\" transfer fields: usually, we'd use the identity scheme as the suffix. More information about identity management will be added to the documentation in January 2025.</p> <p>See your contract's state digest at: <code>https://hyleou.hyle.eu/contract/$CONTRACT_NAME</code>.</p> <p>See your transaction on Hyl\u00e9's explorer: <code>https://hyleou.hyle.eu/tx/$TX_HASH</code>.</p>"},{"location":"developers/quickstart/your-first-smart-contract/#detailed-information","title":"Detailed information","text":""},{"location":"developers/quickstart/your-first-smart-contract/#development-mode","title":"Development mode","text":"<p>We recommend activating dev-mode during your early development phase for faster iteration upon code changes with <code>-e RISC0_DEV_MODE=1</code>.</p> <p>You may also want to get insights into the execution statistics of your project: add the environment variable <code>RUST_LOG=\"[executor]=info\"</code> before running your project.</p> <p>The full command to run your project in development mode while getting execution statistics is:</p> <pre><code>RUST_LOG=\"[executor]=info\" RISC0_DEV_MODE=1 cargo run\n</code></pre>"},{"location":"developers/quickstart/your-first-smart-contract/#code-snippets","title":"Code snippets","text":"<p>Find the full annotated code in our examples repository.</p>"},{"location":"developers/quickstart/your-first-smart-contract/#setup-commands-and-cli","title":"Setup commands and CLI","text":"<p>Set up commands and CLI. You need a unique <code>contract_name</code>: here, we use <code>\"simple_token\"</code>.</p> <pre><code>struct Cli {\n    #[command(subcommand)]\n    command: Commands,\n\n    #[clap(long, short)]\n    reproducible: bool,\n\n    #[arg(long, default_value = \"http://localhost:4321\")]\n    pub host: String,\n\n    #[arg(long, default_value = \"simple_token\")]\n    pub contract_name: String,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    Register {\n        supply: u128,\n    },\n    Transfer {\n        from: String,\n        to: String,\n        amount: u128,\n    },\n    Balance {\n        of: String,\n    },\n}\n</code></pre>"},{"location":"developers/quickstart/your-first-smart-contract/#registering-the-contract","title":"Registering the contract","text":"<p>Set up information about your contract. To register the contract, you'll need:</p> <ul> <li><code>owner</code>: we put \"examples\" as the <code>owner</code>, but you can put anything you like. This field is currently not leveraged; it will be in future versions.</li> <li><code>verifier</code>: for this example, the verifier is <code>risc0</code></li> <li><code>program_id</code>: RISC Zero programs are identified by their image ID, without a prefix.</li> <li><code>state_digest</code>: usually a MerkleRootHash of the contract's initial state. For this example, we use a hexadecimal representation of the state encoded in binary format. The state digest cannot be empty, even if your app is stateless.</li> <li><code>contract_name</code> as set up above.</li> </ul> <pre><code>Commands::Register { supply } =&gt; {\n        // Build initial state of contract\n        let initial_state = Token::new(supply, format!(\"faucet.{}\", contract_name).into());\n        println!(\"Initial state: {:?}\", initial_state);\n\n        // Send the transaction to register the contract\n        let register_tx = RegisterContractTransaction {\n            owner: \"examples\".to_string(),\n            verifier: \"risc0\".into(),\n            program_id: sdk::ProgramId(sdk::to_u8_array(&amp;GUEST_ID).to_vec()),\n            state_digest: initial_state.as_digest(),\n            contract_name: contract_name.clone().into(),\n        };\n        let res = client\n            .send_tx_register_contract(&amp;register_tx)\n            .await\n            .unwrap()\n            .text()\n            .await\n            .unwrap();\n\n        println!(\"\u2705 Register contract tx sent. Tx hash: {}\", res);\n    }\n</code></pre> <p>In the explorer, this will look like this:</p> <pre><code>{\n    \"tx_hash\": \"321b7a4b2228904fc92979117e7c2aa6740648e339c97986141e53d967e08097\",\n    \"owner\": \"examples\",\n    \"verifier\": \"risc0\",\n    \"program_id\":\"e085fa46f2e62d69897fc77f379c0ba1d252d7285f84dbcc017957567d1e812f\",\n    \"state_digest\": \"fd00e876481700000001106661756365742e687964656e74697479fd00e876481700000000\",\n    \"contract_name\": \"simple_token\"\n}\n</code></pre>"},{"location":"developers/quickstart/your-first-smart-contract/#create-blob-transaction","title":"Create blob transaction","text":"<pre><code>    let blob_tx = BlobTransaction {\n        identity: from.into(),\n        blobs,\n    };\n\n    // Send the blob transaction\n    let blob_tx_hash = client.send_tx_blob(&amp;blob_tx).await.unwrap();\n    println!(\"\u2705 Blob tx sent. Tx hash: {}\", blob_tx_hash);\n</code></pre>"},{"location":"developers/quickstart/your-first-smart-contract/#prove-the-transaction","title":"Prove the transaction","text":"<p>Hyl\u00e9 transactions are settled in two steps, following pipelined proving principles. After this step, your transaction is sequenced, but not settled.</p> <p>For the transaction to be settled, it needs to be proven. You'll start with building the contract input, specifying:</p> <ul> <li>the initial state as set above</li> <li>the identity of the transaction initiator</li> <li>the transaction hash, which can be found in the explorer after sequencing (currently, this can be ignored; it will be necessary after an upcoming update)</li> <li>information about the blobs.</li> <li>private input for proof generation in <code>private_blob</code></li> <li><code>blobs</code>: full list of blobs in the transaction (must match the blob transaction)</li> <li><code>index</code>: each blob of a transaction must be proven separately for now, so you need to specify the index of the blob you're proving.</li> </ul> <pre><code>    // Build the contract input\n    let inputs = ContractInput::&lt;Token&gt; {\n        initial_state,\n        identity: from.clone().into(),\n        tx_hash: \"\".into(),\n        private_blob: sdk::BlobData(vec![]),\n        blobs: blobs.clone(),\n        index: sdk::BlobIndex(0),\n    };\n\n    // Generate the zk proof\n    let receipt = prove(cli.reproducible, inputs).unwrap();\n\n    let proof_tx = ProofTransaction {\n        blob_tx_hash,\n        proof: ProofData::Bytes(borsh::to_vec(&amp;receipt).expect(\"Unable to encode receipt\")),\n        contract_name: contract_name.clone().into(),\n    };\n\n    // Send the proof transaction\n    let proof_tx_hash = client\n        .send_tx_proof(&amp;proof_tx)\n        .await\n        .unwrap()\n        .text()\n        .await\n        .unwrap();\n    println!(\"\u2705 Proof tx sent. Tx hash: {}\", proof_tx_hash);\n</code></pre> <p>Check the full annotated code in our GitHub example.</p>"},{"location":"resources/","title":"\ud83d\udcda Resources","text":"<ul> <li>Introduction to zero-knowledge proofs</li> <li>Roadmap</li> <li>Find us</li> <li>Grants</li> </ul>"},{"location":"resources/find-us/","title":"Find us","text":""},{"location":"resources/find-us/#useful-links","title":"Useful links","text":"<ul> <li>Rust node</li> <li>Hyle.eu</li> <li>Hyl\u00e9 blog</li> </ul>"},{"location":"resources/find-us/#contact-us","title":"Contact us","text":"<p>Reach out to the team for more information:</p>  Github  Twitter  Farcaster  LinkedIn  Youtube  Telegram Hyl\u00e9 @hyle_org @hyle-org Hyl\u00e9 @Hyl\u00e9 @hyle_org"},{"location":"resources/grants/","title":"Grants","text":"<p>We have a grant program supporting developers who want to work on trust infrastructure and programmable cryptography on Hyl\u00e9.</p>"},{"location":"resources/grants/#what-are-our-grants-like","title":"What are our grants like?","text":"<ul> <li>You apply with an original idea or an idea from the list on our repo.</li> <li>We fund your project. You get some money upfront, so you can build without financial worries, and the rest upon completion of the project.</li> <li>You meet regularly with our CEO for guidance and to help you refine your ideas.</li> <li>You are in a Telegram group with our other grantees to share ideas and solutions.</li> <li>Our tech team supports you via Telegram and in meetings.</li> <li>Our business team helps you showcase your idea through external speaking opportunities, co-marketing, and other assets.</li> </ul> <p>To read more, see our grant ideas, and apply, please go to our Grants page on the main Hyl\u00e9 repository.</p> <p>For questions that aren't answered on the Grants page, reach out in our Telegram group.</p>"},{"location":"resources/grants/#current-and-past-grants","title":"Current and past grants","text":"<p>Here are two past grants:</p> <ul> <li>Provable play-by-email games library</li> <li>Proof of residency app</li> </ul> <p>Find the full list on our Grants page on the main Hyl\u00e9 repository.</p>"},{"location":"resources/intro-to-zkp/","title":"Understanding zero-knowledge proofs","text":"<p>Here are some resources on zero-knowledge proofs and how to generate them.</p>"},{"location":"resources/intro-to-zkp/#when-to-use-zero-knowledge-proofs","title":"When to use zero-knowledge proofs","text":"<p>There are three moments when ZK is the right tool for you:</p> <ul> <li>Computing power imbalance (which includes improved scalability): I can verify a result without running the resource-heavy computation.</li> <li>Adversarial environment: I can verify a result without knowing trade secrets that attained this result.</li> <li>Anonymity: I share only the information I want to share.</li> </ul>"},{"location":"resources/intro-to-zkp/#how-to-use-zero-knowledge-proofs","title":"How to use zero-knowledge proofs","text":"<p>There are many ZK languages. Hyl\u00e9 aims to verify as many as possible.</p> <p>DSLs are specific languages that usually compile down to a specific circuit. They're good, but they're complex and may have a high learning curve.</p> <p>zkVMs prove the correct execution of arbitrary code. They allow you to build ZK applications in a certain language without having to build a circuit around it. There are two main types of zkVMs: Cairo and RISC-V. You can benchmark your Rust code and find the best zkVM for your needs with the any-zkvm template.</p> <p>We currently support RISC\u2013V-based zkVMs Risc0 and SP1 and will support more types, including Cairo-based zkVMs and DSLs, in the future.</p>"},{"location":"resources/intro-to-zkp/#read-more","title":"Read more","text":"<ul> <li>Zero-knowledge proofs explained at 5 levels of difficulty (22')</li> <li>awesome-zk link repository on GitHub</li> <li>Hyl\u00e9's very simple introduction to zero-knowledge proofs</li> <li>Lauri Peltonen's blog series on ZK</li> </ul>"},{"location":"resources/roadmap/","title":"Roadmap","text":"<p>We do not have a public roadmap at this time. Stay tuned for updates or ask specific questions in our Telegram group.</p>"},{"location":"resources/roadmap/#testnet","title":"Testnet","text":"<p>We will release our testnet in early 2025.</p> <p>While we\u2019re working towards launching the testnet, you can get hands-on right now:</p> <ul> <li>Explore our public devnet or spin up your own instance to start building today!</li> </ul>"},{"location":"resources/roadmap/#proving-schemes","title":"Proving schemes","text":"<p>Check the list of the proving schemes we currently support and the ones we'll work on next.</p>"},{"location":"use-cases/","title":"\ud83d\udca1 Use cases","text":""},{"location":"use-cases/#use-cases","title":"\ud83d\udca1 Use cases","text":"<p>The Use cases section of the Hyl\u00e9 documentation shows how to use Hyl\u00e9 in different scenarios.</p> <p>Use cases include:</p> <ul> <li>Hyl\u00e9 for play-by-email provable games</li> <li>Hyl\u00e9 for account abstraction</li> <li>Hyl\u00e9 for age verification</li> <li>Hyl\u00e9 for proof of residency</li> <li>Hyl\u00e9 for the European Union?</li> </ul> <p>If you are interested in other use cases and would like to explore them with us, you might be interested in our grants program!</p>"},{"location":"use-cases/for-identity-providers/","title":"Hyl\u00e9 for Identity Providers","text":""},{"location":"use-cases/for-identity-providers/#hyle-for-identity-providers","title":"Hyl\u00e9 for Identity Providers","text":"<p>Hyl\u00e9 does not specify what an \"account\" is, or even what identity particularly means. This gives it unprecedented flexibility in handling identity, including:</p> <ul> <li>EOAs like Ethereum native wallets</li> <li>Smart accounts of any kind</li> <li>Regular web2 identity</li> <li>Passports &amp; other national identity documents.</li> </ul> <p>Warning</p> <p>You are entering TODO area, none of this is currently implemented.</p> <p>Hyl\u00e9 handles identity relying on the caller contract in a multicall.</p> <p>When a user crafts a transaction, their first call should be a proof-of-identity, for example a call to the native <code>/eth</code> smart contract, which validates Ethereum-like EOA signatures.</p> <p>Any subsequent call will see that the user is indeed the owner of an <code>/eth</code> address, e.g. <code>0xfoobar/eth</code> and will be able to use that address name trustlessly.</p>"},{"location":"use-cases/for-identity-providers/#registering-your-own-stateless-identity-provider","title":"Registering your own stateless identity provider","text":"<p>A stateless identity provider such as the Ethereum EOA smart contract has two components:</p> <ul> <li>A smart contract registered on Hyl\u00e9, authenticating proofs</li> <li>A client-side library that can craft proofs</li> </ul> <p>See the Ethereum EOA smart contract for an example of such a provider.</p>"},{"location":"use-cases/for-identity-providers/#adding-support-for-your-smart-wallet","title":"Adding support for your smart wallet","text":""},{"location":"use-cases/for-identity-providers/#registering-a-stateful-private-identity-provider","title":"Registering a stateful, private identity provider","text":"<p>This can be used by games, SSO providers, or any other use-case that needs to handle user identity in a more traditional way.</p>"},{"location":"use-cases/for-zk-apps/","title":"Hyl\u00e9 for ZKApps","text":""},{"location":"use-cases/for-zk-apps/#hyle-for-zkapps","title":"Hyl\u00e9 for ZKApps","text":"<p>Hyl\u00e9 is a full featured settlement layer, providing fast finality and cheap TX cost. This makes it a great fit for use-cases that would require appchains or L3s in other ecosystems.</p>"},{"location":"use-cases/for-zk-apps/#registering-your-smart-contract","title":"Registering your smart contract","text":"<p>See Your First Smart Contract for details.</p>"},{"location":"use-cases/for-zk-apps/#bring-your-own-accounts","title":"Bring your own accounts","text":"<p>See Hyl\u00e9 for Identity Providers</p>"}]}