{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#home","title":"Home","text":"<p>Hyl\u00e9 is a lean blockchain that helps you build provable applications that are minimally, yet sufficiently, onchain.</p> <p>Note</p> <p>This developer portal and the project itself are still evolving. Join us on Telegram if you need assistance or wish to provide feedback. Issues and PRs on this documentation's GitHub repository are also very welcome!</p>"},{"location":"#why-hyle","title":"Why Hyl\u00e9?","text":"<ul> <li>Native zero-knowledge proof verification on our sovereign L1: we're fast and lean.</li> <li>No onchain execution or virtual machine: only efficient proof verification.</li> <li>Run complex logic offchain and only submit proofs onchain for maximum scalability.</li> <li>Proof composability: seamlessly combine multiple proofs into single, verifiable transactions.</li> <li>Pipelined proving: send provable blobs, don't worry about proving times.</li> <li>Choose your proving scheme and your language: we verify all proofs.</li> </ul>"},{"location":"#how-hyle-works","title":"How Hyl\u00e9 works","text":"<p>Here\u2019s what happens when you use Hyl\u00e9\u2019s sovereign verification-focused Layer 1:</p> <ol> <li>Sequencing: Send a provable blob to Hyl\u00e9: say what information you expect to prove later. We'll sequence the transaction immediately. Read more about pipelined proving.</li> <li>Proof generation: generate a zero-knowledge proof of a specific computation, or several if they depend on each other. Read more about proof composability.</li> <li>Proof submission: when the proofs for your transaction are ready, send them to Hyl\u00e9.</li> <li>Verification: Hyl\u00e9 validators receive the transaction. They verify the proofs natively, without the limitations of a bulky virtual machine.</li> <li>Consensus: if the proofs are valid, Hyl\u00e9 settles your transaction's state onchain. You're good to go!</li> </ol> <p></p> <p>With this system, execution and storage happen anywhere you like, without cost barriers. You only need a fast and trustworthy verifier: that\u2019s Hyl\u00e9.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Get started now</li> <li>Learn more about Hyl\u00e9</li> <li>Check out examples</li> </ul>"},{"location":"#links","title":"Links","text":"<ul> <li>Rust node</li> <li>Hyle.eu</li> <li>Hyl\u00e9 blog</li> </ul> <p>Reach out to the team for more information:</p>  Github  Twitter  Farcaster  LinkedIn  Youtube  Telegram Hyl\u00e9 @hyle_org @hyle-org Hyl\u00e9 @Hyl\u00e9 @hyle_org"},{"location":"developers/","title":"\ud83d\udc69\u200d\ud83d\udcbb Developer documentation","text":""},{"location":"developers/#developer-documentation","title":"\ud83d\udc69\u200d\ud83d\udcbb Developer documentation","text":"<p>Welcome to the developer documentation for Hyl\u00e9!</p> <ul> <li>Quickstart</li> <li>General documentation about Hyl\u00e9</li> <li>Explorer</li> <li>Annotated examples</li> </ul>"},{"location":"developers/explorer/","title":"Explorer","text":"<p>Hyl\u00e9ou (a French pun for \"Il est o\u00f9\" or \"Where is it?\") is the blockchain explorer for the Hyl\u00e9 ecosystem.</p> <p>The explorer is live at hyleou.hyle.eu.  </p> <p>The source code is available on GitHub. We welcome PRs and issues!</p>"},{"location":"developers/explorer/#features","title":"Features","text":"<p>All features are in active development. </p>"},{"location":"developers/explorer/#live-features","title":"Live features","text":"<p>Currently, you can:</p> <ul> <li>View the latest blocks</li> <li>View the latest transactions.</li> <li>View detailed information about specific blocks and transactions.</li> </ul>"},{"location":"developers/explorer/#upcoming-features","title":"Upcoming features","text":"<p>Planned features include:</p> <ul> <li>Register new contracts.</li> <li>Send transactions by uploading ZK proofs to specific contracts (multicall not yet supported).</li> </ul>"},{"location":"developers/examples/","title":"Examples","text":""},{"location":"developers/examples/#examples","title":"Examples","text":"<p>Detailed examples of Hyl\u00e9-based applications.</p>"},{"location":"developers/examples/#sample-contracts-in-hyle","title":"Sample contracts in Hyl\u00e9","text":"<p>We have three Hyl\u00e9-made Risc0 smart contracts :</p> <ul> <li><code>hydentity</code>: Basic identity provider</li> <li><code>hyllar</code>: Simple ERC20-like contract</li> <li><code>amm</code>: Simple AMM contract</li> <li><code>risc0 recursion</code></li> <li>WIP: <code>staking</code></li> </ul> <p>There is also a CLI called <code>hyrun</code> to execute those contracts, generate proofs, etc.</p>"},{"location":"developers/examples/#code-examples","title":"Code examples","text":"<ul> <li>Collatz example on Hyl\u00e9, using SP1, Noir, or Groth16</li> </ul>"},{"location":"developers/examples/#demos-and-provable-apps","title":"Demos and provable apps","text":"<p>Demos:</p> <ul> <li>Vibe Check: a zkML app.</li> </ul> <p>Our grantees have worked on Hyl\u00e9-based projects. Check them out for inspiration on building provable apps!</p>"},{"location":"developers/examples/amm/","title":"AMM","text":""},{"location":"developers/examples/amm/#amm","title":"AMM","text":"<p>The Hyl\u00e9 AMM is a decentralized Automated Market Maker (AMM) built on the Hyl\u00e9 protocol. It showcases how Hyl\u00e9 can be used for efficient, scalable, and secure decentralized trading.</p>"},{"location":"developers/examples/amm/#overview","title":"Overview","text":"<p>The AMM simplifies decentralized trading through a constant function market maker model. Developers can leverage its architecture to integrate trading functionalities within their dApps.</p> <p>Key highlights include:</p> <ul> <li>Scalability: Supports high throughput and low-latency transactions, even under heavy network usage.</li> <li>Composability: you can use it to interact with your own provable applications.</li> </ul>"},{"location":"developers/examples/amm/#links","title":"Links","text":"<ul> <li>Front-end and back-end</li> <li>Contracts</li> </ul>"},{"location":"developers/examples/collatz-example-in-depth/","title":"Collatz example","text":""},{"location":"developers/examples/collatz-example-in-depth/#collatz-example","title":"Collatz example","text":"<p>Hyl\u00e9 smart contracts can be written in any language that targets one of our supported proving schemes.</p> <p>On this page, we'll use the RISC Zero Collatz Conjecture program, which can be found in our examples repository.</p>"},{"location":"developers/examples/collatz-example-in-depth/#what-is-the-collatz-conjecture","title":"What is the Collatz conjecture?","text":"<p>The Collatz conjecture is a simple mathematical problem that can be expressed as a program.  </p> <p>The conjecture states that, for any positive integer <code>n</code>:</p> <ul> <li>if <code>n</code> is even, divide it by 2</li> <li>if <code>n</code> is odd, multiply it by 3 and add 1</li> <li>repeat this process, and you will eventually reach 1.</li> </ul> <p>The program is implemented in Rust, and compiles to the RISC Zero zkVM.</p>"},{"location":"developers/examples/collatz-example-in-depth/#compiling-the-program","title":"Compiling the program","text":"<p>To compile the program, you will need to have the RISC Zero toolchain installed. Follow the official instructions to get the most up-to-date information.</p> <p>To use RISC Zero, you'll need to compile with</p> <pre><code>cargo build --features risc0\n</code></pre> <p>The matching binary is <code>risc0-runner</code>.</p> <p>Run <code>cargo risczero build</code> to build smart contract.</p>"},{"location":"developers/examples/collatz-example-in-depth/#running-the-collatz-conjecture-program","title":"Running the Collatz Conjecture program","text":"<p>Hyl\u00e9 smart contracts can be executed client-side, enabling strong decentralization and permissionlessness.</p> <p>To execute the smart contract, run the program with correct inputs.</p>"},{"location":"developers/examples/collatz-example-in-depth/#generate-a-proof","title":"Generate a proof","text":""},{"location":"developers/examples/collatz-example-in-depth/#prove-the-transition-from-x-to-the-next-number","title":"Prove the transition from X to the next number","text":"<pre><code># Generate a proof of the transition from X to the next number in the Collatz conjecture\ncargo run next X\n# Or do it reproducibly\ncargo run -- -r next X\n</code></pre> <p>Here are some concrete examples:</p> <pre><code># Compute a proof of a transition between the number 12 and 6\ncargo run next 12\n\n# Compute a proof of a transition between the number 17 and 52\ncargo run next 17\n</code></pre>"},{"location":"developers/examples/collatz-example-in-depth/#reset-to-x","title":"Reset to X","text":"<pre><code># Reset to X, assuming the current number is a 1\ncargo run reset X\n# Or do it reproducibly\ncargo run -- -r reset X\n</code></pre> <p>Here is one concrete example:</p> <pre><code># Reset the state from 1 to 31\ncargo run reset 31\n</code></pre>"},{"location":"developers/examples/collatz-example-in-depth/#invalid-transitions","title":"Invalid transitions","text":"<p>The Collatz smart contract demonstrates how the code of the smart contract enforces constraints on the state:</p> <ul> <li>You can't generate valid proofs of transition between numbers that are not part of the Collatz sequence.</li> <li>The contract will reject attempts to reset to 0, as there would no longer be any next state.</li> </ul>"},{"location":"developers/examples/collatz-example-in-depth/#use-the-proof","title":"Use the proof","text":"<p>Every time, a <code>proof.json</code> file containing the receipt will be generated. You can use this proof, along with the inputs, to trigger state transitions on Hyl\u00e9. Read more: Your first smart contract.</p>"},{"location":"developers/examples/collatz-example-in-depth/#verify-the-proof","title":"Verify the proof","text":"<p>Coming next.</p>"},{"location":"developers/examples/vibe-check/","title":"Vibe Check","text":""},{"location":"developers/examples/vibe-check/#vibe-check","title":"Vibe Check","text":"<p>The general idea of the Vibe Check app is to give people a SmileToken to reward them for smiling.</p> <p>Watch Sylve's demo at ETHCC[7].</p> <p>Find the code in the dedicated GitHub repository.</p>"},{"location":"developers/examples/vibe-check/#context","title":"Context","text":"<p>The step-by-step process:</p> <ol> <li>I identify myself.<ol> <li>I use WebAuthn, with a Yubikey on a computer, a fingerprint on a phone, or any other accepted device.</li> <li>Vibe Check runs the Noir prover in-browser.</li> <li>The prover generates a Noir proof that the Webauthn-signature is correct.</li> </ol> </li> <li>I take a selfie where I\u2019m smiling to generate a proof of my shiny, bubbly personality.<ol> <li>Vibe Check uses a machine-learning model.</li> <li>I send my selfie to this Cairo program.</li> <li>The machine-learning model checks that I am smiling.</li> <li>If I am smiling, the Cairo-prover generates a proof.</li> </ol> </li> <li>Vibe Check gives me a SmileToken.<ol> <li>Vibe Check locally updates the state of the SmileToken.</li> <li>Vibe Check generates a Cairo proof that the state transition was done correctly.</li> </ol> </li> <li>Hyl\u00e9 verifies the proofs.<ol> <li>Hyl\u00e9 updates the SmileToken state if everything is correct. If so, I am rewarded with that SmileToken to congratulate me for my good vibes.</li> </ol> </li> </ol>"},{"location":"developers/examples/vibe-check/#how-it-works","title":"How it works","text":""},{"location":"developers/examples/vibe-check/#understanding-the-components-of-the-demo","title":"Understanding the components of the demo","text":"<p>The Vibe Check demo consists of three components: the app, the proof, and the Hyl\u00e9 node.</p>"},{"location":"developers/examples/vibe-check/#the-app","title":"The app","text":"<p>The app helps the user craft a transaction through 2 interactions:</p> <ul> <li>Identification with WebAuthn for a proof of ID</li> <li>Photo of the user smiling for a proof of smile</li> </ul> <p>The app prepares for proof generation; it also sends a blob of this transaction to Hyl\u00e9, so Hyl\u00e9 can sequence it and knows to expect upcoming proofs.</p>"},{"location":"developers/examples/vibe-check/#the-prover","title":"The prover","text":"<p>Proofs can be generated locally in the browser or remotely to maximize performance. Local proof generation is possible by compiling the Cairo VM/Cairo Prover/Noir Prover into WASM, but it is inefficient. Proving is a memory-consuming activity, and browsers usually have a low limit.</p> <p>The proof generators generate three proofs:</p> <ol> <li>Proof of ID: verification of the WebAuthn ECDSA signature in Noir</li> <li>Proof of smile: running the machine-learning model in Cairo</li> <li>Token (ERC-20) transfer: initiated in Cairo if the first two proofs are valid.</li> </ol> <p>The app sends the three proofs to the Hyl\u00e9 node.</p> <p>The Hyl\u00e9 node:</p> <ol> <li>Unpacks the three proofs.</li> <li>Verifies each proof with the correct verifier: Noir for WebAuthn and Cairo for the two others.</li> <li>Ensures consistency by checking the public data contained in the proofs to ensure they all relate to the same transaction.</li> </ol> <p></p>"},{"location":"developers/examples/vibe-check/#multiple-proving-schemes","title":"Multiple proving schemes","text":"<p>In Vibe Check, we use Noir and Cairo and we leverage proof composability</p>"},{"location":"developers/examples/vibe-check/#the-actual-code","title":"The actual code","text":"<p>Find the code in the dedicated GitHub repository!</p>"},{"location":"developers/general-doc/","title":"General documentation","text":"<p>Welcome to the developer documentation for Hyl\u00e9.</p> <p>You can also refer to our Getting Started step-by-step guide.</p>"},{"location":"developers/general-doc/anatomy-smart-contracts/","title":"Smart contracts on Hyl\u00e9","text":""},{"location":"developers/general-doc/anatomy-smart-contracts/#smart-contracts-on-hyle","title":"Smart contracts on Hyl\u00e9","text":"<p>Hyl\u00e9 is a fully programmable blockchain that optimizes data storage by keeping only the essential information needed to validate smart contract proofs. This design ensures that Hyl\u00e9 smart contracts are lightweight and efficient.</p> <p>Hyl\u00e9 smart contracts include:</p> <ul> <li>Name: the unique identifier for your contract</li> <li>Verifier: the proof system (e.g. \"risc0\" or \"gnark-groth16-te-BN254\")</li> <li>Program ID: the unique identifier for your program in that proof system</li> <li>State digest: current state commitment of the contract</li> </ul> <p>Depending on the type of zk-proof circuits you use, there are some superficial differences, but the overall idea is that all inputs are known at proof generation time.</p> <p>This page uses the Rust structures to demonstrate, but you can use the following repos for other languages:</p> <ul> <li>Rust example: https://github.com/Hyle-org/collatz-conjecture</li> <li>Gnark / Groth16 example (outdated): https://github.com/Hyle-org/groth16-example</li> </ul>"},{"location":"developers/general-doc/anatomy-smart-contracts/#name","title":"Name","text":"<p>The name of your contract must be unique.</p>"},{"location":"developers/general-doc/anatomy-smart-contracts/#verifier-and-program-identifier","title":"Verifier and program identifier","text":"<p>Smart contracts on Hyl\u00e9 rely on a pairing of a zero-knowledge proof scheme (verifier) and a program identifier. Together, these components validate contract proofs.</p> Proving scheme Verifier Program ID Risc Zero risc0 Image ID without a prefix. ex. 0x123 becomes 123. SP1 sp1"},{"location":"developers/general-doc/anatomy-smart-contracts/#state-digest","title":"State digest","text":"<p>The state digest is a minimal yet comprehensive representation of the contract's current state. It serves as the basis for verifying the integrity of the contract's data.</p> <p>Some examples of valid state commitments:</p> <ul> <li>The full state, for a sufficiently small program (e.g. the Collatz example, or a smart-contract with a nonce)</li> <li>A merkle root of the state, for larger programs</li> <li>A hash of the full state</li> </ul>"},{"location":"developers/general-doc/hyle-vs-vintage-blockchains/","title":"Hyl\u00e9 vs. vintage blockchains","text":""},{"location":"developers/general-doc/hyle-vs-vintage-blockchains/#hyle-vs-vintage-blockchains","title":"Hyl\u00e9 vs. vintage blockchains","text":"<p>If you're used to traditional blockchains such as Ethereum or Solana, keep these Hyl\u00e9 characteristics in mind.</p>"},{"location":"developers/general-doc/hyle-vs-vintage-blockchains/#no-evm-or-execution-layer","title":"No EVM or execution layer","text":"<p>Hyl\u00e9 does not include a Virtual Machine.</p> <p>There is no dedicated execution engine or specific programming language (like Solidity) you should use.</p> <p>Our approach is simple: onchain, we verify zero-knowledge proofs natively. Offchain, you do everything else, the way you prefer.</p>"},{"location":"developers/general-doc/hyle-vs-vintage-blockchains/#no-onchain-state","title":"No onchain state","text":"<p>The network maintains proofs of state transitions rather than the entire onchain state.</p> <p>Transactions on Hyl\u00e9 verify and settle transitions without storing full intermediary states onchain.</p> <p>This architecture reduces storage overhead and promotes scalability while maintaining trustlessness.</p>"},{"location":"developers/general-doc/hyle-vs-vintage-blockchains/#privacy-is-built-in","title":"Privacy is built-in","text":"<p>Unlike Ethereum, where privacy solutions must be implemented on top of the platform, Hyl\u00e9 integrates privacy features natively.</p> <p>The proof is public, but your inputs don't need to be, as execution happens offchain.</p>"},{"location":"developers/general-doc/pipelined-proving/","title":"Pipelined proving","text":""},{"location":"developers/general-doc/pipelined-proving/#pipelined-proving","title":"Pipelined proving","text":""},{"location":"developers/general-doc/pipelined-proving/#the-problem-base-state-conflicts","title":"The problem: base state conflicts","text":"<p>Hyl\u00e9 ensures both privacy and scalability by verifying only the state transitions of smart contracts.</p> <p>However, provable applications usually run into an issue. Proof generation can be slow, especially on less powerful devices, and an app with a lot of usage will see conflicting operations, ie. operations that start with the same base state because the previous state change hasn't been settled yet.</p> <p>This is linked to several challenges:</p> <ul> <li>Proof generation latency</li> <li>Timekeeping: proofs require accurate time information, but users can't predict when their transaction will be sequenced.</li> <li>Parallelization: proofs must include valid state transitions, but multiple transactions can accidentally reference the same base state.</li> </ul> <p>We solve these issues by splitting sequencing from settlement; an operation includes two transactions.</p>"},{"location":"developers/general-doc/pipelined-proving/#blob-transaction-vs-proof-transaction","title":"Blob-transaction vs. Proof-transaction","text":"<p>Hyl\u00e9 splits operations into two transactions:</p> <ol> <li>Blob-transaction: outlines a state change for sequencing.</li> <li>Proof-transaction: provides a proof for the claimed state change for settlement.</li> </ol> <p>From Hyl\u00e9\u2019s perspective, the blob-transaction's content is not an issue: it simply represents incoming information that your contract will process.</p> <ol> <li>Sequencing happens when the blob transaction is received and included in a block. This step establishes a global order and timestamps for transactions.</li> <li>Settlement happens when the corresponding proof transaction is verified and added to the block.</li> </ol> <p>During settlement, proved blob transactions linked to the contract are executed in their sequencing order.</p> <p></p>"},{"location":"developers/general-doc/pipelined-proving/#unprovable-transactions","title":"Unprovable transactions","text":"<p>Hyl\u00e9 introduces timeouts for blob transactions to ensure timely proof submissions.</p> <p>Transactions without proofs within a specific duration, as well as transactions with invalid proofs, are rejected.</p>"},{"location":"developers/general-doc/proof-composability/","title":"Proof composition and cross-contract calls","text":""},{"location":"developers/general-doc/proof-composability/#proof-composition-and-cross-contract-calls","title":"Proof composition and cross-contract calls","text":"<p>To understand the concept of proof composability on Hyl\u00e9, we recommend you read this blog post. This page focuses on demonstrating how to use proof composition in your code.</p>"},{"location":"developers/general-doc/proof-composability/#what-is-proof-composition","title":"What is proof composition?","text":"<p>Proof composition happens when two contracts depend on each other. Proof composability is the fact that Hyl\u00e9 allows you to manage this situation while keeping their proofs independent.</p> <p>Most zero-knowledge systems deal with cross-contract calls by enforcing recursive proof verification:</p> <ul> <li>Program A verifies proof of correct execution of Program B;</li> <li>Program B verifies proof of correct execution of Program A.</li> </ul> <p>Hyl\u00e9 allows you to assume, in Program A, that Program B has been successfully executed, by verifying that claim. If you batch both blobs in the same operation, we verify both natively outside of the contract; the whole operation fails if one proof fails to verify.</p> <p>Read more on our blog.</p>"},{"location":"developers/general-doc/proof-composability/#writing-a-cross-contract-call","title":"Writing a cross-contract call","text":"<p>Your program does not need to verify the execution of another program directly.</p> <p>Instead, it uses a representation of the called contracts, which looks like this: <code>MoneyApp::transfer(10, A, B) == true</code> or <code>TicketApp::get(A) == ticket</code>.</p> <p>This representation consists of:</p> <ul> <li>the app</li> <li>the function</li> <li>the function's parameters</li> <li>a claim on the results.</li> </ul> <p>Follow these steps:</p> <ol> <li>Inject claims: add all the claims as inputs to the blob.</li> <li>Index claims: provide an index to tell the contract where to locate its input.</li> <li>Assert claims: use the claim list to validate the required conditions for the blob.</li> </ol>"},{"location":"developers/general-doc/proof-composability/#how-hyle-settles-multiple-proofs","title":"How Hyl\u00e9 settles multiple proofs","text":"<p>When you submit multiple proofs to Hyl\u00e9:</p> <ul> <li>Proof generation can be parallelized: proving times do not compound since proofs do not depend on each other.</li> <li>Proof verification is asynchronous thanks to pipelined proving. As soon as one proof is ready, it can be verified on Hyl\u00e9, even if the other proofs aren't ready yet.</li> <li>Once all proofs related to the transaction are verified, the transaction is settled on Hyl\u00e9. If one proof verification fails, then the entire transaction fails.</li> </ul> <p>Read more on our blog.</p>"},{"location":"developers/general-doc/smart-contract-abi/","title":"Smart Contract ABI","text":""},{"location":"developers/general-doc/smart-contract-abi/#smart-contract-abi","title":"Smart Contract ABI","text":"<p>Hyl\u00e9 focuses on verifying zk-proofs. Because of this, writing smart contracts on Hyl\u00e9 has some specificities, with other elements being the same as with most other blockchains.</p> <p>Depending on the type of zk-proof circuits you use, there are some superficial differences, but the overall idea is that all inputs are known at proof generation time. This includes unusual elements such as the origin of the transaction (<code>tx.origin</code> in Ethereum) and the block number.</p> <p>The Hyl\u00e9 protocol enforces several invariants on transactions to maximize security. For this reason, we must specify some of the data within a zero-knowledge proof.</p> <p>This page uses the Rust structures to demonstrate, but you can use the following repos for other languages:</p> <ul> <li>Rust example: https://github.com/Hyle-org/collatz-conjecture</li> <li>Gnark / Groth16 example (outdated): https://github.com/Hyle-org/groth16-example</li> </ul>"},{"location":"developers/general-doc/smart-contract-abi/#overview","title":"Overview","text":"<p>Here is the rust struct specifying the output of a Hyl\u00e9 smart contract:</p> <pre><code>pub struct HyleOutput&lt;T&gt; {\n    pub version: u32,\n    pub initial_state: Vec&lt;u8&gt;,\n    pub next_state: Vec&lt;u8&gt;,\n    pub identity: String,\n    pub tx_hash: Vec&lt;u8&gt;,\n    pub payload_hash: Vec&lt;u8&gt;,\n    pub success: bool,\n    pub program_outputs: T\n}\n</code></pre> <p>The <code>version</code> field should currently be set to 1.</p>"},{"location":"developers/general-doc/smart-contract-abi/#initial-state-and-next-state","title":"Initial State and Next State","text":"<p>Blockchains transactions are fundamentally state transitions. These fields handle the state transitions securely in the protocol.</p> <p>The <code>initial_state</code> field should match the state digest of the contract before the transaction. This could consist of several things, such as:</p> <ul> <li>the hash of the previous state</li> <li>the Merkle root of the previous state tree</li> <li>the state itself if it's small enough</li> </ul> <p>The protocol enforces that this <code>initial_state</code> matches the onchain <code>state_digest</code> it knows. Otherwise, the state transition is invalid.</p> <p>The <code>next_state</code> field represents the new onchain <code>state_digest</code> after the transaction.</p> <p>Smart contracts can adapt the actual structure of this field. In the future, fees will depend on the size of the <code>state_digest</code> (among other criteria), so we encourage you to keep it small.</p>"},{"location":"developers/general-doc/smart-contract-abi/#identity","title":"Identity","text":"<p>The <code>identity</code> field is the identifier of the person who initiated the transaction.</p> <p>Unlike other blockchains, Hyl\u00e9 does not have a native signature type. Instead, Hyl\u00e9 uses the <code>identity</code> field of the first proof to identify the TX sender. To ensure security, the field is composite and ends with the name of the contract that the proof was generated for.</p> <p>Hyl\u00e9 could for example support Ethereum EOAs, if a smart contract is registered onchain to verify them. The <code>identity</code> would then look something like <code>0x1234...5678.eth_eoa</code>, where <code>eth_eoa</code> is the name of the contract, and the first part matches a regular Ethereum address.</p> <p>This gives us massive flexibility in the future to support any kind of identity verification, including WebAuthn, social media accounts, etc.</p> <p>For now, any subsequent proof in a TX must declare the same <code>identity</code> or an empty one, or the transaction will be rejected.</p>"},{"location":"developers/general-doc/smart-contract-abi/#tx-hash","title":"TX Hash","text":"<p>The <code>tx_hash</code> field is intended to hash transaction data, preventing replay attacks and providing a means for contracts to access this information.</p> <p>The field is currently completely unspecified and isn't validated by the protocol.</p>"},{"location":"developers/general-doc/smart-contract-abi/#payload-hash","title":"Payload Hash","text":"<p>This should match the hash of the payload that was sent to the network initially. Currently we use pedersen hashing for Cairo, no hashing for Risc0. Others are unimplemented. This is very WIP (as of August 2024) and will change soon.</p>"},{"location":"developers/general-doc/smart-contract-abi/#success","title":"Success","text":"<p>This is a boolean - whether the proof is for a succesful proof or a failure case. It can be useful to prove that a transaction is invalid. See our example in Vibe Check.</p>"},{"location":"developers/general-doc/smart-contract-abi/#other-program-specific-outputs","title":"Other program-specific outputs","text":"<p>Smart contracts can provide other outputs as part of the proof they generate.</p> <p>This can be used for a variety of purposes, but mostly serves to provide Data Availability.</p>"},{"location":"developers/general-doc/smart-contract-abi/#events","title":"Events","text":"<p>Hyl\u00e9 does not currently ship native events. We are looking into implementing them in the near future.</p>"},{"location":"developers/general-doc/supported-proving-schemes/","title":"Proving schemes","text":""},{"location":"developers/general-doc/supported-proving-schemes/#proving-schemes","title":"Proving schemes","text":"<p>Proving schemes are the cryptographic protocols that make zero-knowledge proofs usable.</p> <p>We support as many as we can, giving you the flexibility to choose the most suitable protocol for your specific use case.</p>"},{"location":"developers/general-doc/supported-proving-schemes/#supported-proving-schemes","title":"Supported proving schemes","text":"<p>As of December 2024, Hyl\u00e9 currently supports the following zero-knowledge proving schemes:</p> <ul> <li>Noir</li> <li>Risc0</li> <li>SP1</li> </ul>"},{"location":"developers/general-doc/supported-proving-schemes/#planned-future-support","title":"Planned future support","text":"<p>We plan to eventually support all major proving schemes.</p> <p>The next proving schemes we're aiming to support are:</p> <ul> <li>Cairo via Stwo</li> <li>Groth16</li> </ul>"},{"location":"developers/getting-started/","title":"Getting started","text":"<p>Welcome to the Getting Started guide for Hyl\u00e9.</p> <p>This page will help you configure your environment and start using Hyl\u00e9.</p> <p>Use the sidebar to navigate through the guide, or click on the links below to jump to a specific section:</p> <ol> <li>Run your local devnet</li> <li>Use our tools</li> <li>Create your first smart contract</li> <li>Get inspiration from our in-depth Collatz example</li> <li>Understand Hyl\u00e9's smart contract ABI</li> <li>Check if everything works on the Hyl\u00e9ou explorer</li> </ol>"},{"location":"developers/getting-started/devnet/","title":"Devnet","text":""},{"location":"developers/getting-started/devnet/#devnet","title":"Devnet","text":"<p>You can start building on Hyl\u00e9 by running a local devnet by following the instructions below.</p>"},{"location":"developers/getting-started/devnet/#run-your-own-single-node-devnet","title":"Run your own single-node devnet","text":""},{"location":"developers/getting-started/devnet/#getting-started-with-docker","title":"Getting Started with Docker","text":"<p>We currently don't have a deployment file available.</p> <p>Follow these instructions to run a node, keeping in mind that this is unstable and can break with upcoming updates.</p> <p>Download the Docker image:</p> <pre><code>docker pull europe-west3-docker.pkg.dev/hyle-413414/hyle-docker/hyle:main\n</code></pre> <p>Run the image:</p> <pre><code>docker run -v ./db:/hyle/data -e HYLE_RUN_INDEXER=false -p 4321:4321 -p 1234:1234 europe-west3-docker.pkg.dev/hyle-413414/hyle-docker/hyle:main\n</code></pre>"},{"location":"developers/getting-started/devnet/#build-the-docker-image-locally","title":"Build the Docker image locally","text":"<p>If you want to, you can rebuild the image locally from source:</p> <pre><code>docker build -t Hyle-org/hyle . &amp;&amp; docker run -dit Hyle-org/hyle\n</code></pre>"},{"location":"developers/getting-started/devnet/#getting-started-with-cargo","title":"Getting Started with Cargo","text":"<p>To start a single-node devnet (with consensus disabled), which is useful to build &amp; debug smart contracts, run:</p> <pre><code>cargo build\nHYLE_RUN_INDEXER=false cargo run --bin node\n</code></pre> <p>If you want to run with an indexer, you will need a running PostgreSQL server. You can set it up with Docker:</p> <pre><code># For default conf:\ndocker run -d --rm --name pg_hyle -p 5432:5432 -e POSTGRES_PASSWORD=postgres postgres\n</code></pre>"},{"location":"developers/getting-started/devnet/#configuration","title":"Configuration","text":"<p>You can configure your setup using environment variables or by editing a configuration file.</p>"},{"location":"developers/getting-started/devnet/#using-a-configuration-file","title":"Using a configuration file","text":"<p>To use a configuration file, copy the default settings where you run the node. If a file named config.ron is present, it will be automatically loaded by the node at startup.</p> <pre><code># Copy default config where you run the node. If file named \"config.ron\" is present, it will be loaded by node at startup.\ncp ./src/utils/conf_defaults.ron config.ron\n</code></pre> <p>Here's an example of how you can configure your setup using environment variables:</p> <pre><code>HYLE_RUN_INDEXER=false \nHYLE_CONSENSUS__SLOT_DURATION=100\n</code></pre>"},{"location":"developers/getting-started/devnet/#environment-variables","title":"Environment variables","text":"<p>This is the default configuration for a node. All variables can be customized on your single-node instance.</p> <pre><code>Config(\n  id: \"node\",\n  single_node: true,\n  p2p_listen: true,\n  host: \"127.0.0.1:1231\",\n  peers: [],\n  storage: Storage(\n    interval: 10\n  ),\n  log_format: \"full\",\n  rest: \"127.0.0.1:4321\",\n  data_directory: \"data_node\",\n  database_url: \"postgres://postgres:postgres@localhost:5432/postgres\",\n  consensus: Consensus (\n    slot_duration: 1000,\n    // Has to be empty as config is additive\n    genesis_stakers: {}\n  ),\n  p2p: (\n    ping_interval: 10\n  ),\n  run_indexer: true,\n  da_address: \"127.0.0.1:4141\"\n)\n</code></pre>"},{"location":"developers/getting-started/user-tooling/","title":"User tooling","text":""},{"location":"developers/getting-started/user-tooling/#user-tooling","title":"User tooling","text":""},{"location":"developers/getting-started/user-tooling/#clone-the-hyle-repository","title":"Clone the Hyl\u00e9 repository","text":"<p>Clone the Hyl\u00e9 repository.</p> <pre><code>git clone https://github.com/Hyle-org/hyle.git\n</code></pre>"},{"location":"developers/getting-started/user-tooling/#use-the-cli","title":"Use the CLI","text":"<p>To interact with the node, use the cli <code>hyled</code>:</p> <pre><code>cargo run --bin hyled -- --help\n</code></pre>"},{"location":"developers/getting-started/user-tooling/#optional-install-the-cli","title":"(Optional) Install the CLI","text":"<p>You can install the CLI for easier access.</p> <pre><code>cargo install --path . --bin hyled\nhyled --help\n</code></pre>"},{"location":"developers/getting-started/user-tooling/#explorer","title":"Explorer","text":"<p>Explorer / Indexer: Hyl\u00e9ou. Read more about the explorer.</p>"},{"location":"developers/getting-started/your-first-smart-contract/","title":"Your first smart contract","text":""},{"location":"developers/getting-started/your-first-smart-contract/#your-first-smart-contract","title":"Your first smart contract","text":"<p>You can use any zkVM or proving scheme supported by Hyl\u00e9.</p> <p>We'll use the Collatz example as an example throughout this tutorial. See the Collatz page page for more information.</p> <p>Read more in our anatomy of a smart contract.</p>"},{"location":"developers/getting-started/your-first-smart-contract/#prerequisites","title":"Prerequisites","text":"<ul> <li>A working knowledge of zkVM basics.</li> <li>Install Rust (you'll need <code>rustup</code> and Cargo).</li> <li>Follow the CLI installation instructions. We are currently building utilities that will make it easier and faster to use our explorer, Hyl\u00e9ou.</li> </ul>"},{"location":"developers/getting-started/your-first-smart-contract/#registering-your-smart-contract","title":"Registering your smart contract","text":""},{"location":"developers/getting-started/your-first-smart-contract/#content-of-a-smart-contract","title":"Content of a smart contract","text":"<p>Hyl\u00e9 smart contracts include:</p> <ul> <li>Name: the unique identifier for your contract</li> <li>Verifier: the proof system (e.g. \"risc0\" or \"gnark-groth16-te-BN254\")</li> <li>Program ID: the unique identifier for your program in that proof system</li> <li>State digest: current state commitment of the contract</li> </ul> <p>Read more about the anatomy of smart contracts on Hyl\u00e9.</p>"},{"location":"developers/getting-started/your-first-smart-contract/#register-your-contract","title":"Register your contract","text":"<p>To register a contract on Hyl\u00e9, run the following command:</p> <pre><code># Owner is currently unused, but could be used in the future to manage contract permissions\nhyled contract [owner] [verifier] [program_id] [contract_name] [state_digest]\n</code></pre> <p>Replace <code>[owner], [verifier], [program_id], [contract_name]</code>, and <code>[state_digest]</code> with your specific details.</p>"},{"location":"developers/getting-started/your-first-smart-contract/#for-collatz","title":"For Collatz","text":"<p>In the case of the Collatz Conjecture example, as RISC Zero programs are identified by their image ID, without a prefix, we use the number <code>0xb48e70c79688b41fc8f0daf8370d1ddb3f44ada934c10c6e0b0f5915102a363b</code>. This will change every time the contract logic is modified.  </p> <p>The initial state is set to \"1\", so that it can be reset to any number. This is encoded in base 64 as <code>AAAAAQ==</code> because of the Rust library used to decode the state.</p> <p>Note that you need a unique <code>contract_name</code>. If you try to test this example on the public devnet, we recommend putting a name that's not \u00ab collatz \u00bb.</p> <p>For our example, the bash command looks like this:</p> <pre><code>hyled contract default risc0 b48e70c79688b41fc8f0daf8370d1ddb3f44ada934c10c6e0b0f5915102a363b collatz AAAAAQ==\n</code></pre> <p>(We put \u00ab default \u00bb as the <code>owner</code>, but you can put anything you like. This field is currently not leveraged; it will be in future versions.)</p>"},{"location":"developers/getting-started/your-first-smart-contract/#checking-your-contract","title":"Checking your contract","text":"<p>In the explorer, this will look like this:</p> <pre><code>{\n    \"tx_hash\": \"ebecbf7458370d656772369df4a76c343b050e3fdbe4c1ceb7d54175ce290b60\",\n    \"owner\": \"default\",\n    \"verifier\": \"risc0\",\n    \"program_id\": [\n        b48e70c79688b41fc8f0daf8370d1ddb3f44ada934c10c6e0b0f5915102a363b\n    ],\n    \"state_digest\": [\n        AAAAAQ==\n    ],\n    \"contract_name\": \"collatz\"\n}\n</code></pre>"},{"location":"developers/getting-started/your-first-smart-contract/#interacting-with-hyle","title":"Interacting with Hyl\u00e9","text":"<p>Hyl\u00e9 transactions are settled in two steps, following pipelined proving principles.</p> <ol> <li>Publishing payloads: send the input of your program to the network.</li> <li>Posting proof of your payload: generate and submit proofs validating your payload so Hyl\u00e9 will settle your transaction.</li> </ol>"},{"location":"developers/getting-started/your-first-smart-contract/#publishing-payloads","title":"Publishing payloads","text":"<p>The content of the payload is app-specific: it's the input of your program.</p> <p>For the Collatz conjecture, this is a number encoded as a big-endian 32-bit integer.</p> <pre><code>payload='\\x00\\x00\\x00\\x05'\n# Generate the proof in 'collatz-contract'\ncargo run reset $payload\nhyled blobs \"\" collatz $(echo $payload | base64)\n# the \"\" is a placeholder for identity: it's empty, as Collatz doesn't handle identity\n</code></pre> <p>You can see your transaction on Hyl\u00e9's explorer: <code>https://hyleou.hyle.eu/transaction/$TX_HASH</code></p> <p>At this point, your transaction has been sequenced, but not settled.</p>"},{"location":"developers/getting-started/your-first-smart-contract/#posting-proofs-of-your-payload-to-settle-it","title":"Posting proofs of your payload to settle it","text":"<p>Hyl\u00e9 requires specific variables in the output of the proof to process the transaction. Check the smart contract ABI for more details.</p> <p>Once your program conforms to the ABI, you can generate proofs and send them to Hyl\u00e9.</p> <p>Each payload of a transaction must be proven separately for now, so you need to specify the index of the payload you're proving.</p> <pre><code>hyled proof [tx_hash] [contract_name] [proof]\n</code></pre> <p>In the case of the Collatz Conjecture program, we can now prove our state transition from 1 to 5.</p> <pre><code># Make sure the name matches the contract you registered\nhyled proof [tx_hash] collatz [path_to_proof]\n</code></pre> <p>Hyl\u00e9 will now verify your proof. After verification, your transaction is settled, updating the state of the contract.</p>"},{"location":"developers/getting-started/your-first-smart-contract/#verifying-your-contracts-state","title":"Verifying your contract's state","text":"<p>Your contract's state digest is visible at: <code>https://hyleou.hyle.eu/contract/$CONTRACT_NAME</code></p> <p>You can choose to run the command below instead:</p> <pre><code>hyled state collatz\n</code></pre>"},{"location":"resources/","title":"\ud83d\udcda Resources","text":"<ul> <li>Introduction to zero-knowledge proofs</li> <li>Roadmap</li> <li>Find us</li> <li>Grants</li> </ul>"},{"location":"resources/find-us/","title":"Find us","text":""},{"location":"resources/find-us/#useful-links","title":"Useful links","text":"<ul> <li>Rust node</li> <li>Hyle.eu</li> <li>Hyl\u00e9 blog</li> </ul>"},{"location":"resources/find-us/#contact-us","title":"Contact us","text":"<p>Reach out to the team for more information:</p>  Github  Twitter  Farcaster  LinkedIn  Youtube  Telegram Hyl\u00e9 @hyle_org @hyle-org Hyl\u00e9 @Hyl\u00e9 @hyle_org"},{"location":"resources/grants/","title":"Grants","text":"<p>We have a grant program supporting developers who want to work on trust infrastructure and programmable cryptography on Hyl\u00e9.</p>"},{"location":"resources/grants/#what-are-our-grants-like","title":"What are our grants like?","text":"<ul> <li>You apply with an original idea or an idea from the list on our repo.</li> <li>We fund your project. You get some money upfront, so you can build without financial worries, and the rest upon completion of the project.</li> <li>You meet regularly with our CEO for guidance and to help you refine your ideas.</li> <li>You are in a Telegram group with our other grantees to share ideas and solutions.</li> <li>Our tech team supports you via Telegram and in meetings.</li> <li>Our business team helps you showcase your idea through external speaking opportunities, co-marketing, and other assets.</li> </ul> <p>To read more, see our grant ideas, and apply, please go to our Grants page on the main Hyl\u00e9 repository.</p> <p>For questions that aren't answered on the Grants page, reach out in our Telegram group.</p>"},{"location":"resources/grants/#current-and-past-grants","title":"Current and past grants","text":"<p>Here are two past grants:</p> <ul> <li>Provable play-by-email games library</li> <li>Proof of residency app</li> </ul> <p>Find the full list on our Grants page on the main Hyl\u00e9 repository.</p>"},{"location":"resources/intro-to-zkp/","title":"Understanding zero-knowledge proofs","text":"<p>Here are some resources on zero-knowledge proofs and how to generate them.</p>"},{"location":"resources/intro-to-zkp/#when-to-use-zero-knowledge-proofs","title":"When to use zero-knowledge proofs","text":"<p>There are three moments when ZK is the right tool for you:</p> <ul> <li>Computing power imbalance (which includes improved scalability): I can verify a result without running the resource-heavy computation.</li> <li>Adversarial environment: I can verify a result without knowing trade secrets that attained this result.</li> <li>Anonymity: I share only the information I want to share.</li> </ul>"},{"location":"resources/intro-to-zkp/#how-to-use-zero-knowledge-proofs","title":"How to use zero-knowledge proofs","text":"<p>There are many ZK languages. Hyl\u00e9 aims to verify as many as possible.</p> <p>DSLs are specific languages that usually compile down to a specific circuit. They're good, but they're complex and may have a high learning curve.</p> <p>zkVMs prove the correct execution of arbitrary code. They allow you to build ZK applications in a certain language without having to build a circuit around it. There are two main types of zkVMs: Cairo and RISC-V. You can benchmark your Rust code and find the best zkVM for your needs with the any-zkvm template.</p> <p>We currently support RISC\u2013V-based zkVMs Risc0 and SP1 and will support more types, including Cairo-based zkVMs and DSLs, in the future.</p>"},{"location":"resources/intro-to-zkp/#read-more","title":"Read more","text":"<ul> <li>awesome-zk link repository on GitHub</li> <li>Hyl\u00e9's very simple introduction to zero-knowledge proofs</li> <li>Lauri Peltonen's blog series on ZK</li> </ul>"},{"location":"resources/roadmap/","title":"Roadmap","text":"<p>We do not have a public roadmap at this time. Stay tuned for updates or ask specific questions in our Telegram group.</p>"},{"location":"resources/roadmap/#testnet","title":"Testnet","text":"<p>We will release our testnet in early 2025.</p> <p>While we\u2019re working towards launching the testnet, you can get hands-on right now:</p> <ul> <li>Explore our public devnet or spin up your own instance to start building today!</li> </ul>"},{"location":"resources/roadmap/#proving-schemes","title":"Proving schemes","text":"<p>Check the list of the proving schemes we currently support and the ones we'll work on next.</p>"},{"location":"use-cases/","title":"\ud83d\udca1 Use cases","text":""},{"location":"use-cases/#use-cases","title":"\ud83d\udca1 Use cases","text":"<p>The Use cases section of the Hyl\u00e9 documentation shows how to use Hyl\u00e9 in different scenarios.</p> <p>Use cases include:</p> <ul> <li>Hyl\u00e9 for play-by-email provable games</li> <li>Hyl\u00e9 for account abstraction</li> <li>Hyl\u00e9 for age verification</li> <li>Hyl\u00e9 for proof of residency</li> <li>Hyl\u00e9 for the European Union?</li> </ul> <p>If you are interested in other use cases and would like to explore them with us, you might be interested in our grants program!</p>"},{"location":"use-cases/for-identity-providers/","title":"Hyl\u00e9 for Identity Providers","text":""},{"location":"use-cases/for-identity-providers/#hyle-for-identity-providers","title":"Hyl\u00e9 for Identity Providers","text":"<p>Hyl\u00e9 does not specify what an \"account\" is, or even what identity particularly means. This gives it unprecedented flexibility in handling identity, including:</p> <ul> <li>EOAs like Ethereum native wallets</li> <li>Smart accounts of any kind</li> <li>Regular web2 identity</li> <li>Passports &amp; other national identity documents.</li> </ul> <p>Warning</p> <p>You are entering TODO area, none of this is currently implemented.</p> <p>Hyl\u00e9 handles identity relying on the caller contract in a multicall.</p> <p>When a user crafts a transaction, their first call should be a proof-of-identity, for example a call to the native <code>/eth</code> smart contract, which validates Ethereum-like EOA signatures.</p> <p>Any subsequent call will see that the user is indeed the owner of an <code>/eth</code> address, e.g. <code>0xfoobar/eth</code> and will be able to use that address name trustlessly.</p>"},{"location":"use-cases/for-identity-providers/#registering-your-own-stateless-identity-provider","title":"Registering your own stateless identity provider","text":"<p>A stateless identity provider such as the Ethereum EOA smart contract has two components:</p> <ul> <li>A smart contract registered on Hyl\u00e9, authenticating proofs</li> <li>A client-side library that can craft proofs</li> </ul> <p>See the Ethereum EOA smart contract for an example of such a provider.</p>"},{"location":"use-cases/for-identity-providers/#adding-support-for-your-smart-wallet","title":"Adding support for your smart wallet","text":""},{"location":"use-cases/for-identity-providers/#registering-a-stateful-private-identity-provider","title":"Registering a stateful, private identity provider","text":"<p>This can be used by games, SSO providers, or any other use-case that needs to handle user identity in a more traditional way.</p>"},{"location":"use-cases/for-zk-apps/","title":"Hyl\u00e9 for ZKApps","text":""},{"location":"use-cases/for-zk-apps/#hyle-for-zkapps","title":"Hyl\u00e9 for ZKApps","text":"<p>Hyl\u00e9 is a full featured settlement layer, providing fast finality and cheap TX cost. This makes it a great fit for use-cases that would require appchains or L3s in other ecosystems.</p>"},{"location":"use-cases/for-zk-apps/#registering-your-smart-contract","title":"Registering your smart contract","text":"<p>See Your First Smart Contract for details.</p>"},{"location":"use-cases/for-zk-apps/#bring-your-own-accounts","title":"Bring your own accounts","text":"<p>See Hyl\u00e9 for Identity Providers</p>"}]}