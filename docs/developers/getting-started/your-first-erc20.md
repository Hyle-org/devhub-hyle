# Your first smart contract

We'll use [our sample token transfer example](https://github.com/Hyle-org/examples/tree/simple_erc20/simple-erc20) as the basis for this tutorial.

Read more in our [anatomy of a smart contract](../general-doc/anatomy-smart-contracts.md).

## Prerequisites

- A working knowledge of zkVM basics.
- [Install Rust](https://www.rust-lang.org/tools/install) (you'll need `rustup` and Cargo).
- [Start a single-node devnet](./devnet.md). We recommend activating [dev-mode](https://dev.risczero.com/api/generating-proofs/dev-mode) during your early development phase for faster iteration upon code changes with `-e RISC0_DEV_MODE=1`.
- For our example, you'll need to [install RISC Zero](https://dev.risczero.com/api/zkvm/install).

## Content of a smart contract

Hyl√© smart contracts include:

- **Owner**: put anything you like. This field is currently not leveraged but will be in future versions.
- **Verifier**: the proof system (e.g. "risc0" or "gnark-groth16-te-BN254").
- **Program ID**: the unique identifier for your program in that proof system.
- **Contract name**: the unique identifier for your contract.
- **State digest**: current state commitment of the contract, usually a MerkleRootHash of the contract's state.

Read more about the [anatomy of smart contracts on Hyl√©](../general-doc/anatomy-smart-contracts.md).

## Quick start: Register your contract on your local node

To build all methods and register the smart contract on the local node [from the source](https://github.com/Hyle-org/examples/blob/simple_erc20/simple-erc20/host/src/main.rs), run:

```bash
cargo run -- register 1000
```

On the node's logs, you should see a line stating: `üìù Registering new contract simple_token`.

To send 2 tokens to *Bob*, sending a blob transaction and a proof transaction associated with that, you can run:

```bash
cargo run -- transfer faucet.simple_token bob.simple_token 2
```

This will:

1. Send a blob transaction to transfer 2 tokens from `faucet` to `bob`
2. Generate a ZK proof of that transfer
3. Send the proof to the devnet.

Your node will then:

1. Verify the proof
1. Settle the blob transaction
1. Update the contract State

On node's logs you should see:

```bash
INFO hyle::data_availability::node_state::verifiers: ‚úÖ Risc0 proof verified.
INFO hyle::data_availability::node_state::verifiers: üîé Program outputs: Transferred 2 to bob.simple_token
```

And after a slot:

```bash
INFO hyle::data_availability::node_state: Settle tx TxHash("[..]")
```

You can check onchain balance:

```bash
cargo run -- balance faucet.simple_token
cargo run -- balance bob.simple_token
```

<!-- Reformuler -->
In this example, we do not verify the identity of the person who initiates the transaction. We use `.simple_token` as a suffix for the "from" and "to" transfer fields: usually, we'd use the identity scheme as the suffix.

!!! note
    More information about identity management will be added to the documentation in January 2025.

### Verifying your contract's state

Your contract's state digest is visible at: `https://hyleou.hyle.eu/contract/$CONTRACT_NAME`

After Hyl√© verifies your proof, your transaction is settled, updating the state of the contract.

You can see your transaction on Hyl√©'s explorer: `https://hyleou.hyle.eu/transaction/$TX_HASH`


## Detailed explanation

### Execute your project locally in development mode

We recommend activating [dev-mode](https://dev.risczero.com/api/generating-proofs/dev-mode) during your early development phase for faster iteration upon code changes with `-e RISC0_DEV_MODE=1`.

You may also want to get insights into the execution statistics of your project: add the environment variable `RUST_LOG="[executor]=info"` before running your project.

The full command to run your project in development mode while getting execution statistics is:

```bash
RUST_LOG="[executor]=info" RISC0_DEV_MODE=1 cargo run
```

### Content of the contract

Find the full code in [our examples repository](https://github.com/Hyle-org/examples/blob/simple_erc20/simple-erc20/host/src/main.rs).

Initial setup:

```rs
use anyhow::bail;
use anyhow::Result;
use clap::{Parser, Subcommand};
use contract::Token;
use contract::TokenContract;
use hyle::model::BlobTransaction;
use hyle::model::ProofData;
use hyle::model::ProofTransaction;
use hyle::model::RegisterContractTransaction;
use risc0_zkvm::Receipt;
use risc0_zkvm::{default_prover, ExecutorEnv};
use sdk::erc20::ERC20;
use sdk::HyleOutput;
use sdk::{ContractInput, Digestable};

// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{GUEST_ELF, GUEST_ID};
```

Set up commands and CLI. You need a unique `contract_name`.. Here, we use `"simple_token"`.

```rs
#[derive(Parser)]
#[command(author, version, about, long_about = None)]
#[command(propagate_version = true)]
struct Cli {
    #[command(subcommand)]
    command: Commands,

    #[clap(long, short)]
    reproducible: bool,

    #[arg(long, default_value = "http://localhost:4321")]
    pub host: String,

    #[arg(long, default_value = "simple_token")]
    pub contract_name: String,
}

#[derive(Subcommand)]
enum Commands {
    Register {
        supply: u128,
    },
    Transfer {
        from: String,
        to: String,
        amount: u128,
    },
    Balance {
        of: String,
    },
}
```

Set up information about your contract. To register the contract, you'll need:

- `owner`: we put "examples" as the `owner`, but you can put anything you like. This field is currently not leveraged; it will be in future versions.
- `verifier`: for this example, the verifier is `risc0`
- `program_id`: RISC Zero programs are identified by their image ID, without a prefix.
- `state_digest`: usually a MerkleRootHash of the contract's initial state. For this example, we use a hexadecimal representation of the state encoded in binary format. The state digest cannot be empty, even if your app is stateless.
- `contract_name` as set up above.

Then, send a transaction that will register the contract.

```rs
#[tokio::main]
async fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let cli = Cli::parse();

    let client = hyle::tools::rest_api_client::ApiHttpClient::new(cli.host);

    let contract_name = &cli.contract_name;

    match cli.command {
        Commands::Register { supply } => {
            // Build initial state of contract
            let initial_state = Token::new(supply, format!("faucet.{}", contract_name).into());
            println!("Initial state: {:?}", initial_state);

            // Send the transaction to register the contract
            let register_tx = RegisterContractTransaction {
                owner: "examples".to_string(),
                verifier: "risc0".into(),
                program_id: sdk::ProgramId(sdk::to_u8_array(&GUEST_ID).to_vec()),
                state_digest: initial_state.as_digest(),
                contract_name: contract_name.clone().into(),
            };
            let res = client
                .send_tx_register_contract(&register_tx)
                .await
                .unwrap()
                .text()
                .await
                .unwrap();

            println!("‚úÖ Register contract tx sent. Tx hash: {}", res);
        }
        Commands::Balance { of } => {
            // Fetch the state from the node
            let state: Token = client
                .get_contract(&contract_name.clone().into())
                .await
                .unwrap()
                .state
                .into();

            let contract = TokenContract::init(state, "".into());
            let balance = contract.balance_of(&of).unwrap();
            println!("Balance of {}: {}", of, balance);
        }
        Commands::Transfer { from, to, amount } => {
            // Fetch the initial state from the node
            let initial_state: Token = client
                .get_contract(&contract_name.clone().into())
                .await
                .unwrap()
                .state
                .into();
```

In [the explorer](https://hyleou.hyle.eu/), this will look like this:

```rs
{
    "tx_hash": "321b7a4b2228904fc92979117e7c2aa6740648e339c97986141e53d967e08097",
    "owner": "examples",
    "verifier": "risc0",
    "program_id":"e085fa46f2e62d69897fc77f379c0ba1d252d7285f84dbcc017957567d1e812f",
    "state_digest": "fd00e876481700000001106661756365742e687964656e74697479fd00e876481700000000",
    "contract_name": "simple_token"
}
```

Now, let's build the blob transaction.

```rs
            // ----
            // Build the blob transaction
            // ----

            let action = sdk::erc20::ERC20Action::Transfer {
                recipient: to.clone(),
                amount,
            };
            let blobs = vec![sdk::Blob {
                contract_name: contract_name.clone().into(),
                data: sdk::BlobData(
                    bincode::encode_to_vec(action, bincode::config::standard())
                        .expect("failed to encode BlobData"),
                ),
            }];
            let blob_tx = BlobTransaction {
                identity: from.into(),
                blobs,
            };

            // Send the blob transaction
            let blob_tx_hash = client.send_tx_blob(&blob_tx).await.unwrap();
            println!("‚úÖ Blob tx sent. Tx hash: {}", blob_tx_hash);
```

Hyl√© transactions are settled in two steps, following [pipelined proving principles](../general-doc/pipelined-proving.md). After this step, your transaction is sequenced, but not settled.

For the transaction to be settled, it needs to be proven. You'll start with building the contract input, specifying:

- the initial state as set above
- the identity of the transaction initiator
- the transaction hash, which can be found in the explorer after sequencing (currently, this can be ignored; it will be necessary after an upcoming update)
- information about the blobs.
  - private input for proof generation in `private_blob`
  - `blobs`: full list of blobs in the transaction (must match the blob transaction)
  - `index`: each blob of a transaction must be proven separately for now, so you need to specify the index of the blob you're proving.

```rs
        // ----
        // Prove the state transition
        // ----

            // Build the contract input
            let inputs = ContractInput::<Token> {
                initial_state,
                identity: from.clone().into(),
                tx_hash: "".into(),
                private_blob: sdk::BlobData(vec![]),
                blobs: blobs.clone(),
                index: sdk::BlobIndex(0),
            };
```

Now that the contract input is built, you can generate your zero-knowledge proof using Risc0:

```rs
            // Generate the zk proof
            let receipt = prove(cli.reproducible, inputs).unwrap();

            let proof_tx = ProofTransaction {
                blob_tx_hash,
                proof: ProofData::Bytes(borsh::to_vec(&receipt).expect("Unable to encode receipt")),
                contract_name: contract_name.clone().into(),
            };
```

Finally, send the proof transaction to Hyl√© for verification and settlement.

```rs
            // Send the proof transaction
            let proof_tx_hash = client
                .send_tx_proof(&proof_tx)
                .await
                .unwrap()
                .text()
                .await
                .unwrap();
            println!("‚úÖ Proof tx sent. Tx hash: {}", proof_tx_hash);
        }
    }
}
```